<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Notebook</title>
      <link href="/2049/09/01/Note/"/>
      <url>/2049/09/01/Note/</url>
      
        <content type="html"><![CDATA[<h3 id="2019-11-25"><a href="#2019-11-25" class="headerlink" title="2019-11-25"></a>2019-11-25</h3><p>毕设开题报告已经展示过了，但是还是有很多的问题。不知是老师对相关领域的不熟悉，还是我自己的理解有问题，也许我需要做的还是有很多吧。决定这周熬夜做一个demo出来找老师看看。实在不行也可以按照老师给的想法，不局限于做IDA的插件，也许机器学习算法可以自己实现呢，不需要什么python的库呢。总之，自己加油，做出个样子吧。</p><a id="more"></a><h3 id="2019-11-23"><a href="#2019-11-23" class="headerlink" title="2019-11-23"></a>2019-11-23</h3><p>昨天和前天做完开题报告，今天回到公司上班了，经过开题报告，觉得这一段时间自己还是划水太多了。所以回到公司就想鹏哥问有没有样本可以分析。还是觉得按照自己学习爱看书的尿性，是真的很难进步，至少有样本在分析可以给自己一种紧迫感。</p><h3 id="2019-11-14"><a href="#2019-11-14" class="headerlink" title="2019-11-14"></a>2019-11-14</h3><p>10月底去了一趟西安，感触很多，不过越来越不想再出去玩了，一是资金，二是时间。自从上次分析完那批样本，部门经理似乎已经不管我这个打白工的实训生了，没有再给过我样本来分析，也好，自己看书也不错，但总是心里不踏实。</p><p>看《IDA Pro》了解了很多IDA使用的细节方面的东西，毕设是打算做一个IDA的反混淆插件，多珍惜时间吧。别人的时间不知为何就那么随意浪费，自己先珍惜好自己的时间吧。这个周末把开题报告写完吧，一直在犹豫要不要花钱买一个机器学习的在线课程来学一下，听了前面的一章的课，惊叹别人的逻辑时如此缜密。</p><p>最近发现看书看着看着会很困，所以就去刷看雪上和XCTF上的逆向题，也还好，还处于入门阶段，也一直想在先知投个稿试试，但是觉得自己解决的问题基本别人都有解答了的啊，苦恼，我想赚点钱啊！</p><h3 id="2019-10-17"><a href="#2019-10-17" class="headerlink" title="2019-10-17"></a>2019-10-17</h3><ol><li>这两天在公司没有样本分析，于是就看起了《IDA Pro》，慢慢看书梳理经历过的知识对我来说是一个很好的方法。</li><li>和同学约好周末一起去都江堰了。</li><li>认识的一个朋友又去深信服了，月薪10k+，3年后我会去哪里呢？</li></ol><h3 id="2019-10-13"><a href="#2019-10-13" class="headerlink" title="2019-10-13"></a>2019-10-13</h3><ol><li>这个星期在公司主要分析了宏病毒，使用VBE调试VB代码，很恶心的是居然使用宏代码进行注入，到最后也没能完全把注入的PE代码给提取出来，准备在自己的电脑上在试试吧。</li><li>毕设由于种种问题不能去研究所跟导师做了，现在很烦。</li><li>这个月的事不多，但都挺让人心烦意乱的了。</li></ol><h3 id="2019-10-07"><a href="#2019-10-07" class="headerlink" title="2019-10-07"></a>2019-10-07</h3><ol><li>这个新博客已经完善得差不多了，本来想加上评论系统的，但是一直出问题，而且发现评论系统的网站的访问速度有点慢，遂弃！</li><li>原来写过CSDN，也自己搭建过VPS上的blog，最终还是用这个吧，简单明了。</li><li>新的开始，保持记录吧！</li></ol><h3 id="2019-10-03"><a href="#2019-10-03" class="headerlink" title="2019-10-03"></a>2019-10-03</h3><ol><li>新建了依托于github的博客。</li><li>发现其实<code>hexo</code>挺强大的，后面也可以添加一些第三方服务，评论啊什么的，明天再弄吧！</li></ol><h3 id="2019-09-16"><a href="#2019-09-16" class="headerlink" title="2019-09-16"></a>2019-09-16</h3><ol><li>今天重新弄了一下这个博客，刚开始把什么开发过程全忘了，只能小心翼翼的在<code>Xshell</code>上弄，从删掉最丑的背景图开始，仔细检查服务器上的代码和本地的代码是否一致……</li><li>为了不让github提示我的代码有漏洞，决定将<code>Django</code>版本升级到<code>2.1.11</code>, 修改了<code>requirements.txt</code>中<code>django</code>对应的版本，使用<code>pip install -r requirements.txt</code>进行升级。</li><li>然后就遇到一个500(<code>Server error</code>)的<code>Bug</code>，经大佬们提醒，我暂时打开了<code>Debug</code>模式，仔细查看，才想起这是当初遇到的<code>Bug</code>,只要在<code>Python</code>的<code>base.py</code>中修改一下代码就可以了。</li><li>之后打算给小破站配个免费的<code>SSL</code>证书，然后鼓捣了一下午加一个晚上，服务器差点搞崩了，了解了<code>yum, python</code>之间的依赖关系，最后通过<code>Letsencrypt</code>的方法还是走不通，问了一下*哥，他说用<code>cloudfare+cdn</code>要好一点。</li><li>去查了一下这些个配置方法，好多，不想看，主要是思路和我这半天了解到的不太一样，没看懂。</li><li>回到搜索“最简单的免费配置<code>SSL</code>证书”上来，发现一个叫<code>Freessl</code>的网站，看他域名这么简单，应该也挺简单的吧！果然，证书生成、域名检测、部署配置一条龙打通，值得一提的是它的一键部署是将你本地生成的证书和私钥文件通过<code>SSH KEY</code>/服务器密码的方式直接传到你的服务器上，然后只需要在服务器上修改<code>nginx</code>配置，重启<code>nginx</code>就可以了。</li><li>最后，明天会有好事发生！Ebrn</li></ol><h3 id="2019-09-05"><a href="#2019-09-05" class="headerlink" title="2019-09-05"></a>2019-09-05</h3><ol><li>今天分析一个韩国的<code>hwp</code>样本，不知道自己为什么和喵喵比起来分析得那么慢，他说在网上搜索就直接有现成的分析报告，但是我的好像都没有，而且看日期还是前个星期才编译的呢。</li><li>样本属于宏病毒（实际上就是嵌套在文档中的脚本文件），<code>hwp</code>使用的是<code>PostScript</code>,早上看了其他类似的分析报告，了解了大致的分析思路，一整个下午就在调试，通过<code>OD</code>加载<code>hwp</code>的<code>gbb</code>可执行文件，来调试通过<code>hwpscan2</code>扫描出来的<code>ps</code>脚本，最后在内存中<code>Dump</code>出来了一个<code>PE</code>文件，用<code>ida</code>查看之后，发现是使用<code>Delphi</code>编译的<code>Dll</code>文件，和昨天分析那个一样，但是主要的功能和用<code>Systemtracer</code>监测到的不一样，估计还有其他的<code>PE</code>文件没有<code>dump</code>出来，或者<code>shellcode</code>。</li><li>越来越发现自己是一个赖不住寂寞的人，也才想着来自己的网站倾述自己一天的生活吧！</li></ol><h3 id="2019-09-03"><a href="#2019-09-03" class="headerlink" title="2019-09-03"></a>2019-09-03</h3><ol><li>今天分析一个<code>Delphi</code>编写的<code>Dll</code>，很多函数都是不能直接反编译的，开始了解花指令。</li><li>练习<code>PWN</code>，遇到整数溢出的题，属于上界溢出，由此可以利用栈溢出，很有意思，不过最后还是有点不太明白为什么要进入交互模式才能得到<code>flag</code>.</li><li>收集奖学金和保研的材料时，看着自己大三这一年的碌碌无为，参加了不少比赛，因为菜，而毫无作为！感到伤心。</li></ol><h3 id="2019-09-02"><a href="#2019-09-02" class="headerlink" title="2019-09-02"></a>2019-09-02</h3><ol><li>借鉴Sakura大佬的博客，我也写一个简短的生活记录吧！</li><li>暑假结束了，实习没有结束，一直在做病毒分析的工作，渐渐对二进制逆向和<code>pwn</code>产生了浓厚的兴趣。</li><li>保研虽然我们专业只有我和另外一位大佬竞争，按照往年的名额，感觉也可以，但我心里还是隐隐担心差那么一点点。</li><li>九推投了信工所，和之前联系的李*老师邮件交流，回复很快，挺开心。</li><li>校招投了奇安信，打算如果可以的话，之前自己去找实习吧。</li><li>在知乎上问了一个问题，得到了很多大佬的回答，感触良多，嗯，找准自己的方向，潜心修行吧！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feelings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django Error：no module named _sqlite3</title>
      <link href="/2019/11/04/Django-Error%EF%BC%9Ano-module-named-sqlite3/"/>
      <url>/2019/11/04/Django-Error%EF%BC%9Ano-module-named-sqlite3/</url>
      
        <content type="html"><![CDATA[<ul><li>简述：在配置服务器端的Django代码文件时，有一步需要将项目的静态文件收集到根目录下的static目录下，需要执行下面的这个命令：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><p>有可能会出现这个错误。解决方法如下：</p><ul><li><p>退出虚拟环境，如果用的是virtualenv的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></li><li><p>安装sqlite-devel，依据自己的系统选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install sqlite-devel       #centos</span><br><span class="line">$ apt-get install sqlite-devel   #debian</span><br></pre></td></tr></table></figure></li><li><p>然后重新编译自己的python环境，进入到自己的python安装包中，之前写过如何安装python的一片文章，就是将安装过程重新走一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install    <span class="comment">#这一步可能要用到管理员权限，sudo</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA Pro阅读笔记</title>
      <link href="/2019/10/23/IDA-Pro%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/23/IDA-Pro%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="《IDA-Pro权威指南（第二版）》阅读笔记"><a href="#《IDA-Pro权威指南（第二版）》阅读笔记" class="headerlink" title="《IDA Pro权威指南（第二版）》阅读笔记"></a>《IDA Pro权威指南（第二版）》阅读笔记</h3><p>趁着上班没有样本分析的时间把这本书看完吧！记录一些自己印象深刻的知识点。有些自己已经比较熟悉的点不会列出来了。</p><a id="more"></a><h4 id="第一部分-IDA简介"><a href="#第一部分-IDA简介" class="headerlink" title="第一部分 IDA简介"></a>第一部分 IDA简介</h4><h5 id="第1章-反汇编简介"><a href="#第1章-反汇编简介" class="headerlink" title="第1章 反汇编简介"></a>第1章 反汇编简介</h5><ol><li>模糊测试：模糊测试是一种发现漏洞的技术，它为程序输入大量不常见的输入，希望其中某些输入能对程序造成可被检测、分许，最终被利用的错误。</li><li>x86汇编语言的两种语法：Intel、AT&amp;T，gdb使用AT&amp;T语法，MASM、TASM、NASM使用Intel语法。</li><li>反汇编的算法有线性扫描、递归下降两种。</li></ol><h5 id="第2章-逆向与反汇编"><a href="#第2章-逆向与反汇编" class="headerlink" title="第2章 逆向与反汇编"></a>第2章 逆向与反汇编</h5><p>这一工具主要介绍了一些小工具。</p><ol><li><p>nm：摘要工具，用来列举目标文件的符号。</p></li><li><p>ldd：摘要工具，用来列举可执行文件所需的动态库，这才想起来之前做Pwn的时候，看到有别人用这个命令查看可执行文件的依赖库。</p></li></ol><h5 id="第3章-IDA-Pro背景知识"><a href="#第3章-IDA-Pro背景知识" class="headerlink" title="第3章 IDA Pro背景知识"></a>第3章 IDA Pro背景知识</h5><p>这一章主要讲了IDA的开发历史及其反盗版的一些措施，大致介绍了本书的一些关键性内容，其中讲插件的章节是在第17章，这是后面我要详细看的地方。</p><h4 id="第二部分-IDA基本用法"><a href="#第二部分-IDA基本用法" class="headerlink" title="第二部分 IDA基本用法"></a>第二部分 IDA基本用法</h4><h5 id="第4章-IDA入门"><a href="#第4章-IDA入门" class="headerlink" title="第4章 IDA入门"></a>第4章 IDA入门</h5><p>介绍了IDA使用的一些小技巧，并没有值得我记录的，要说我积累出来的就是<code>Esc</code>和<code>Ctrl+W</code>的使用了，还有<code>Space</code>,<code>Tab</code>,<code>N</code>,<code>Y</code>,<code>A</code>这些快捷键的使用，得益于参加的之前的实验室的项目。</p><ol><li>当你不小心拖动了一些窗口后，发现想移动却移动不回去了，使用Windows &gt; Reset Desktop可以恢复原始的布局。</li></ol><h5 id="第5章-IDA数据显示窗口"><a href="#第5章-IDA数据显示窗口" class="headerlink" title="第5章 IDA数据显示窗口"></a>第5章 IDA数据显示窗口</h5><p>介绍了IDA的一些常见的显示窗口，我算是比较熟悉了，这里就不记录了。<br>经常用到的有反汇编窗口、16进制窗口、字符串窗口、导入窗口、导出窗口、伪代码窗口。</p><h5 id="第6章-反汇编导航"><a href="#第6章-反汇编导航" class="headerlink" title="第6章 反汇编导航"></a>第6章 反汇编导航</h5><ol><li>对栈帧有了比较新的认识：<blockquote><p>编译器通过栈帧（也叫做激活记录）使得对函数参数和局部变量进行分配和释放的过程对程<br>序员透明。在将控制权转交给函数之前，编译器会插入代码，将函数参数放入栈帧内，并分配足<br>够的内存，以保存函数的局部变量。鉴于栈帧的结构，该函数的返回地址也存储在新的栈帧内。<br>使用栈帧使得递归成为可能，因为每个递归函数调用都有它自己的栈帧，这恰好将当前调用与前<br>一次调用分隔开来。</p></blockquote></li><li>对fastcall的新认识：<blockquote><p>fastcall约定是stdcall约定的一个变体，它向CPU寄存器（而非程序栈）最多传递两个参数。<br>Microsoft Visual C/C++ 和GNU gcc/g++（3.4及更低版本）编译器能够识别函数声明中的fastcall<br>修饰符。如果指定使用fastcall约定，则传递给函数的前两个参数将分别位于ECX和EDX寄存器<br>中。剩余的其他参数则以类似于stdcall约定的方式从右到左放入栈上。同样与stdcall约定类似<br>的是，在返回其调用方时，fastcall函数负责从栈中删除参数。下面的声明中即使用了fastcall<br>修饰符：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">demo_fastcall</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>;</span><br><span class="line">; demo_fastcall(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//programmmer calls demo_fastcall</span></span><br><span class="line">push <span class="number">4</span></span><br><span class="line">push <span class="number">3</span></span><br><span class="line">mov edx, <span class="number">2</span></span><br><span class="line">mov ecx, <span class="number">1</span></span><br><span class="line">call demo_fastcall</span><br></pre></td></tr></table></figure></li></ol><h5 id="第7章-反汇编操作"><a href="#第7章-反汇编操作" class="headerlink" title="第7章 反汇编操作"></a>第7章 反汇编操作</h5><p>也是自己比较熟悉的地方吧，数据的转换，数组的设置，函数的操作，类型的设置，在自己实习的时候做样本分析时都体验过了，那个远控木马至今印象深刻。</p><h5 id="第8章-数据类型与数据结构"><a href="#第8章-数据类型与数据结构" class="headerlink" title="第8章 数据类型与数据结构"></a>第8章 数据类型与数据结构</h5><ol><li>关于数组的成员的访问，本章中列出了三种类型的数组：全局变量的数组、栈生成的数组以及堆生成的数组。前两种数组的访问方式基本一致，都是直接获取数组变量的地址来进行赋值，而堆生成的数组由于是由<code>malloc</code>或者<code>new</code>等方法动态得到的，在IDA中静态分析时并不能得到其真正的地址，所以需要通过寄存器先获取其基址，再根据偏移访问其成员，这和结构体的访问类似。</li><li>同样也有对结构体的访问，也包括三中类型：全局的、栈分配的、堆分配的。如果一个结构体在堆中分配，那么对编译器来说，引用该结构体的唯一线索就是指向该结构体起始地址的指针。而另外两种在编译时是能够计算出其固定地址的。</li><li>解析头文件：要解析头文件，可以使用File&gt;Load File&gt;Parse C Header File（文件&gt;加载文件&gt;解析C 头<br>文件）选择你想要解析的头文件。</li><li>遇到虚函数的问题：虚函数是用于实现多态行为的，虚函数的地址在编译时不能确定，只能在即将调用进行时确定（通过虚函数表）。<blockquote><p>且C++中程序会以ecx作为this指针的载体传递给虚成员函数。</p></blockquote></li></ol><h5 id="第9章-交叉引用与绘图功能"><a href="#第9章-交叉引用与绘图功能" class="headerlink" title="第9章 交叉引用与绘图功能"></a>第9章 交叉引用与绘图功能</h5><ol><li><p>三种代码交叉引用：读取交叉引用、写入交叉引用、偏移交叉引用。</p><blockquote><p>一般而言，以一个程序指令字节为目标的写入交叉引用表示这是一段自修改代码，这种代码通常被视为无效代码，在恶意软件使用的“去模糊例程”（de-obfuscation routine）中经常可以发现这类代码。<br>偏移量交叉引用表示的是引用的是某个位置的地址，并非内容。</p></blockquote></li><li><p>关于<strong>基本块</strong>：</p><blockquote><p>在计算机程序中，基本块是一条或数条指令的组合，它拥有唯一一个指向块起始位置的入口点和唯一一个指向块结束位置的退出点。<br>一般来说，除最后一条指令外，基本块中的每条指令都将控制权转交给它后面的“继任”指令。同样，除第一条指令外，基本块中的每条指令都从它“前任”指令那里接收控制权。<br>通常，为判定基本块，应忽略函数调用指令并未将控制权转交到当前函数这一事实，除非已知被调用的函数无法正常返回。基本块在行为方面有一个重要的特点，即一旦基本块中的第一条指令开始执行，块中的其他指令都会执行，直到最后一条指令。这个特点会对程序的运行时检测产生重大影响，因为这时不再需要为程序中的每一条指令设置一个断点，或者逐步执行程序，以记录程序执行的每一条指令。相反，你可以为每个基本块的第一条指令设置断点，当这些断点被触发时，相关块中的每一条指令都被标记为“已执行”。Pedram Amini 的PaiMei③框架中的Process Stalker 组件就是以这种方式执行的。</p></blockquote></li><li><p><code>F12</code>可以生成一个函数的外部流程图，不过很难看！<code>Ctrl+F12</code>可以生成整个二进制文件函数调用图，也很难看！</p></li><li><p>选定一个函数可以生成以其为源头或者目标的交叉引用图，View-&gt;Graphs-&gt;Xrefs from/to.</p></li><li><p>图形化的其他工具：</p><blockquote><p>自IDA 引入集成化反汇编图形模式后，这些困难有一部分得到了解决。但是，IDA 主要是一个反汇编器，生成图形并不是它的主要用途。对专用的图形分析工具感兴趣的读者可以研究专门用于此类目的的应用程序，如<code>BinNavi</code>，这款工具是Halvar Flake 的公司<code>Zynamics</code>开发的。</p></blockquote></li></ol><h5 id="第10章-IDA的多种面孔"><a href="#第10章-IDA的多种面孔" class="headerlink" title="第10章 IDA的多种面孔"></a>第10章 IDA的多种面孔</h5><p>介绍了IDA的控制台模式，在各种平台上的不同面孔，目前我只需关注Windows上的IDA控制台版本（idaw.exe），其实没什么好说的，书中的实际应用也还没有接触过。<br>另外还提了一下IDA的批量模式，批量模式是为了自动处理任务，这似乎和我后面打算做的插件有点关系，先在这儿提一下吧，有具体的参数说明。</p><blockquote><p>使用批量模式的主要目的是启动IDA，使它运行一段特定的IDC 脚本，并在该脚本完成后立即终止。</p></blockquote><h4 id="第三部分-IDA高级应用"><a href="#第三部分-IDA高级应用" class="headerlink" title="第三部分 IDA高级应用"></a>第三部分 IDA高级应用</h4><h5 id="第11章-定制IDA"><a href="#第11章-定制IDA" class="headerlink" title="第11章 定制IDA"></a>第11章 定制IDA</h5><p>ida目录下的cfg目录中的<code>ida.cfg, idagui.cfg, idatui.cfg</code>是IDA的设置文件，另外也可以新建一个<code>idauser.cfg</code>来重写其中的设置，这样便于在不同的ida中使用。<br>idagui.cfg是图形界面的配置，idatui.cfg是控制台模式的配置。</p><h5 id="第12章-使用FLIRT签名来识别库"><a href="#第12章-使用FLIRT签名来识别库" class="headerlink" title="第12章 使用FLIRT签名来识别库"></a>第12章 使用FLIRT签名来识别库</h5><p>FLIRT签名技术是用来识别可执行文件中的一些静态库的函数的，这样可以使逆向分析人员专注于程序本身的代码的分析。</p><ol><li><p>关于<code>Main</code>和<code>_start</code>:</p><blockquote><p>程序的入口点是即将执行的第一条指令的地址。因此，许多熟练的C 程序员错误地认为这就是main 函数的地址，但事实并非如此。程序的文件类型，而不是创建程序所使用的语言，决定了向这个程序提交命令行参数的方式。为了使加载器加载命令行参数的方式与程序预期接收参数的方式（例如，通过向main 提交参数）保持一致，程序必须在将控制权转交给main 之前执行一段初始化代码。IDA 将这段初始化代码作为程序的入口点，并将其标记为_start。<br>这段初始化代码还负责必须在main 运行之前完成的初始化任务。在C++程序中，这段代码负责确保在执行main 之前调用全局声明对象的构造函数。同样，为了在程序真正终止前调用所有全局对象的析构函数，必须插入在main 之后执行的清理代码（cleanup code）。</p></blockquote></li><li><p>如何生成签名文件：</p><blockquote><p>创建签名文件的基本过程听起来并不复杂，可以归结为4 个看似简单的步骤。<br>a. 获得一个你希望为其创建签名文件的静态库。<br>b. 利用其中一个FLAIR 解析器为该库创建一个模式文件。<br>c. 运行sigmake.exe 来处理生成的模式文件，并生成一个签名文件。<br>d. 将新的签名文件复制到<code>&lt;IDADIR&gt;/sig</code> 目录中，安装这个文件。</p></blockquote></li></ol><p>在之前的CTF经历中遇到过需要自己制作sig文件的题目，但是当时自己并没有仔细看，现在大概应该懂了。</p><h5 id="第13章-扩展IDA的知识"><a href="#第13章-扩展IDA的知识" class="headerlink" title="第13章 扩展IDA的知识"></a>第13章 扩展IDA的知识</h5><p>这一章主要是介绍til和ids的扩展功能，其主要作用就是让用户可以自定义设置自己的函数声明相关配置文件，这样在IDA自动分析的过程中就会识别出对应的函数的调用约定、参数类型、数量等。以后遇到具体的应用的时候可以再来重新仔细的看一遍。</p><ol><li>库函数中函数序号：<blockquote><p>序号是与每个导出函数有关的整数索引。使用序号可通过整数查询表迅速定位一个函数。若通过将函数名称与字符串进行比较来定位函数，则很缓慢。</p></blockquote></li><li>创建ids文件：<blockquote><p>IDA 的idsutils 实用工具用于创建.ids 文件。这些实用工具包括两个库解析器：从Windows DLL 中提取信息的dll2idt 和从ar 库中提取信息的ar2idt.exe。无论使用哪一个解析器，其输出都是一个.idt 文本文件，它每行显示一个导出函数，并将导出函数的序号与函数名称对应起来。</p></blockquote></li></ol><p><img src="//spwpun.github.io/2019/10/23/IDA-Pro阅读笔记/20191102094833.png" alt="20191102094833"><br>3. 修改注释，使用loadint实用工具，后续需要花点时间来研究一下怎么创建一个ids文件和til文件。</p><h5 id="第14章-修补二进制文件及其他IDA的限制"><a href="#第14章-修补二进制文件及其他IDA的限制" class="headerlink" title="第14章 修补二进制文件及其他IDA的限制"></a>第14章 修补二进制文件及其他IDA的限制</h5><blockquote><p>IDA 并不是一个二进制文件编辑器。任何时候，如果你想要使用IDA 修补一个二进制文件，请记住这个事实。但是，它是一款特别有用的工具，可帮助你输入并显示潜在的更改。掌握IDA的全部功能，并结合IDA 通过适当的脚本或外部程序生成的信息，修补二进制文件也会变得简单可行。</p></blockquote><p>IDA 对二进制文件的修改这一方面感觉确实不行，如果要修改二进制文件，还是用专用的二进制编辑器吧，例如010 Editor、Winhex，扯一句，最近发现Winhex的功能真的挺强大的。</p><h4 id="第四部分-扩展IDA的功能"><a href="#第四部分-扩展IDA的功能" class="headerlink" title="第四部分 扩展IDA的功能"></a>第四部分 扩展IDA的功能</h4><h5 id="第15章-编写IDA脚本"><a href="#第15章-编写IDA脚本" class="headerlink" title="第15章  编写IDA脚本"></a>第15章  编写IDA脚本</h5><h6 id="IDC脚本的特性"><a href="#IDC脚本的特性" class="headerlink" title="IDC脚本的特性"></a>IDC脚本的特性</h6><p>IDC语言和C类似，但还是有很多区别的。</p><p>IDC使用关键字<code>auto</code>来声明一个局部变量，使用关键字<code>extern</code>来声明一个全局变量，但声明全局变量时不能为其提供初始值；</p><p>IDC并不支持C风格的数组，对于字符串这类的变量，支持和python一样的分片操作；</p><p>IDC并不严格限制变量的作用域，你可以在变量声明的花括号外面访问变量；</p><p>IDC中的<code>Message</code>函数类似于C中的<code>printf</code>函数；</p><p>IDC仅支持在独立的<code>.idc</code>文件中声明函数，<code>static</code>关键字用于声明用户自定义的函数，在IDC命令对话框中不能定义函数，因为这相当于在函数中定义函数，而IDC不支持嵌套声明；</p><p>IDC也支持类对象，但是不使用public、private类似的访问说明符，所有的成员都是有效公共类，且如果要在类中创建数据成员，只需要一个给类的数据成员的赋值语句就行；</p><p>IDC程序文件的基本结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt; //useful include directive</span></span></span><br><span class="line"><span class="comment">//declare addtional functions as required</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something fun here</span></span><br><span class="line">    AddHotkey(<span class="string">"z"</span>, <span class="string">"func"</span>); <span class="comment">//Now 'z' invokes </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="IDC常用的函数"><a href="#IDC常用的函数" class="headerlink" title="IDC常用的函数"></a>IDC常用的函数</h6><ol><li><p>读取和修改数据的函数</p><p><code>long Byte(long addr)</code>，从虚拟地址addr 处读取一个字节值。</p><p><code>long Word(long addr)</code>，从虚拟地址addr 处读取一个字（2 字节）值。</p><p><code>long Dword(long addr)</code>，从虚拟地址addr 处读取一个双字（4 字节）值。</p><p><code>void PatchByte(long addr, long val)</code>，设置虚拟地址addr 处的一个字节值。</p><p><code>void PatchWord(long addr, long val)</code>，设置虚拟地址addr 处的一个字值。</p><p><code>void PatchDword(long addr, long val)</code>，设置虚拟地址addr 处的一个双字值。</p><p><code>bool isLoaded(long addr)</code>，如果addr 包含有效数据，则返回1，否则返回0。</p></li><li><p>用户交互函数</p><p><code>void Message(string format, ...)</code>，在输出窗口打印一条格式化消息。这个函数类似于C 语言的printf 函数，并接受printf 风格的格式化字符串。</p><p><code>void print(...)</code>，在输出窗口中打印每个参数的字符串表示形式。</p><p><code>void Warning(string format, ...)</code>，在对话框中显示一条格式化消息。</p><p><code>string AskStr(string default, string prompt)</code>，显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0。</p><p><code>string AskFile(long doSave, string mask, string prompt)</code>，显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据（doSave=1），或选择现有的文件读取数据（doSave=0）。你可以根据mask（如<em>.</em>或*.idc）过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0。</p><p><code>long AskYN(long default, string prompt)</code>，用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1 为是，0 为否，-1 为取消）。返回值是一个表示选定答案的整数。</p><p><code>long ScreenEA()</code>，返回当前光标所在位置的虚拟地址。</p><p><code>bool Jump(long addr)</code>，跳转到反汇编窗口的指定地址。</p></li><li><p>字符串操纵函数</p><ul><li><input disabled type="checkbox"> string form(string format, …)//preIDA5.6，返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C 语言的sprintf 函数。</li><li><input disabled type="checkbox"> string sprintf(string format,…)//IDA5.6+，在IDA5.6 中，sprintf 用于替代form（参见上面）。</li><li><input disabled type="checkbox"> long atol(string val)，将十进制值val 转换成对应的整数值。</li><li><input disabled type="checkbox"> long xtol(string val)，将十六进制值val（可选择以0x 开头）转换成对应的整数值。</li><li><input disabled type="checkbox"> string ltoa(long val, long radix)，以指定的radix（2、8、10 或16）返回val 的字符串值。</li><li><input disabled type="checkbox"> long ord(string ch)，返回单字符字符串ch 的ASCII 值。</li><li><input disabled type="checkbox"> long strlen(string str)，返回所提供字符串的长度。</li><li><input disabled type="checkbox"> long strstr(string str, string substr)，返回str 中substr 的索引。如果没有发现子字符串，则返回-1。</li><li><input disabled type="checkbox"> string substr(string str, long start, long end)，返回包含str 中由start 到end-1位置的字符的子字符串。如果使用分片（ IDA5.6 及更高版本）， 此函数等同于str[start:end]。</li></ul></li><li><p>文件输入输出函数</p><ul><li><input disabled type="checkbox"> …这部分有点多了，单独写一篇出来吧，还有后面的IDAPython的相关函数，以便之后写插件的时候用到。</li></ul></li></ol><h6 id="IDAPython编写插件"><a href="#IDAPython编写插件" class="headerlink" title="IDAPython编写插件"></a>IDAPython编写插件</h6><ul><li>编写python脚本需要导入三个核心的模块：idaapi、idautils、idc。</li><li>需要定义一个plugin类作为插件的入口函数，参数idaapi.plugin_t是IDA的插件类，后续会讲到，例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classs PluginName_Plugin_t(idaapi.plugin_t):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>然后需要注册plugin：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># register IDA plugin</span><br><span class="line">def PLUGIN_ENTRY():</span><br><span class="line">return PluginName_Plugin_t()</span><br></pre></td></tr></table></figure><h5 id="第16章-IDA软件开发工具包"><a href="#第16章-IDA软件开发工具包" class="headerlink" title="第16章 IDA软件开发工具包"></a>第16章 IDA软件开发工具包</h5><p>这一章讲的是IDA的SDK的使用方法，涉及到SDK的安装配置、应用编程接口，总的来说是让你如何系统的去使用IDC编写IDA的插件的这样一个体系结构。</p><p>有用的SDK数据类型：area_t, func_t, segment_t, idc_value_t, idainfo, struc_t, member_t, op_t, insn_t. 这些类型标明了IDA中的各个功能展现的数据形式，也就是可以通过编程将其进行操纵。</p><p>这一章也有一些常用的SDK函数，同上一章一样，我会单独将其列出来，方便以后查找，这一章的这些函数与IDC脚本相比，能够进行更加细化的控制。</p><h5 id="第17章-IDA插件体系结构"><a href="#第17章-IDA插件体系结构" class="headerlink" title="第17章 IDA插件体系结构"></a>第17章 IDA插件体系结构</h5><p>插件是经过编译的、功能更加强大的IDC脚本。</p><ol><li><p>插件的安装：我先挑最简单的来说，安装插件只需要将编译好的插件模块复制到<code>&lt;IDADIR&gt;/plugins</code>目录中即可，不过需要注意的是尽量在完全关闭IDA的情况下进行此操作，因为Windows系统不能覆写一个正在使用的插件，而在IDA打开的时候，你想要的覆写的插件可能设置了PLUGIN_FIX标志且证在运行。</p></li><li><p>编写插件：这里把插件上升为一个模块来解释，IDA模块都是以适用于执行插件的平台的共享库组件实现，而每个模块必须导出某个特定类的一个变量，对插件来说，就是plugin_t，这个类在SDK的loader.hpp文件中定义。【稍微查了一下：hpp = h + cpp, 先简单这么理解吧】<br>plugin_t类中的字段包括：version, flags, init, term, run, comment, help, wanted_name, wanted_hotkey.<br>以上的成员就涵盖了编写一个插件需要做的大致事务，根据名称能简单推断出各个字段的函数，其中term字段是一个函数指针，当插件卸载时，调用相关函数。【term即为terminate的缩写，好像我挺习惯这样记忆的】</p></li><li><p>构建插件：在Windows上，插件是有效的DLL文件（.plw/.p64），在Linux/Mac上，插件则是有效的共享文件对象（.plx/plx64, .pmc/pmc64）。构建插件需要简化版本的生成文件（makefile）和GNU工具，在Windows上使用MinGW。</p></li><li><p>可以在已编译的插件中扩展IDC，但现在还没有办法扩展IDAPython。</p></li><li><p>脚本化插件：创建Python插件的过程非常简单，只需要定义一个名为PLUGIN_ENTRY的函数，该函数返回plugin_t（在模块idaapi中定义）的一个实例。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">idabook_plugin_t</span><span class="params">(plugin_t)</span>:</span></span><br><span class="line">flags = <span class="number">0</span></span><br><span class="line">wanted_name = <span class="string">"IdaBook Python Plugin"</span></span><br><span class="line">    wanted_hotkey = <span class="string">"Alt-8"</span></span><br><span class="line">      comment = <span class="string">"IdaBook Python Plugin"</span></span><br><span class="line">      help = <span class="string">"Something helpful"</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">          msg(<span class="string">"IdaBook Python Plugin init called.\n"</span>)</span><br><span class="line">          <span class="keyword">return</span> PLUGIN_OK</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">          msg(<span class="string">"IdaBook Plugin term called.\n"</span>)</span><br><span class="line">          </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">          warning(<span class="string">"IdaBook plugin run(%d) called"</span> % arg)</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">PLUGIN_ENTRY</span><span class="params">()</span>:</span></span><br><span class="line">          <span class="keyword">return</span> idabook_plugin_t()</span><br></pre></td></tr></table></figure></li></ol><p>上面是使用IDAPython写的一个小型插件，下面是使用IDC写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">idabook_plugin_t</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">idabook_plugin_t</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>.flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>.wanted_name = <span class="string">"IdaBook IDC Plugin"</span>;</span><br><span class="line"><span class="keyword">this</span>.wanted_hotkey = <span class="string">"Alt-9"</span>;</span><br><span class="line"><span class="keyword">this</span>.comment = <span class="string">"IdaBook IDC Plugin"</span>;</span><br><span class="line"><span class="keyword">this</span>.help = <span class="string">"Something helpful"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init()&#123;</span><br><span class="line">Message(<span class="string">"IdaBook plugin init called.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> PLUGIN_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">term()&#123;</span><br><span class="line">Message(<span class="string">"IdaBook plugin term called.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(arg)&#123;</span><br><span class="line">Warning(<span class="string">"IdaBook plugin run(%d) called.\n"</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">PLUGIN_ENTRY</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">idabook_plugin_t</span>();</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h5 id="第18章-二进制文件与IDA加载器模块"><a href="#第18章-二进制文件与IDA加载器模块" class="headerlink" title="第18章 二进制文件与IDA加载器模块"></a>第18章 二进制文件与IDA加载器模块</h5><p>粗略看了一下，感觉未来一段时间暂时不会接触到，主要是讲如何去构建一个简单的加载器来识别未知的文件类型什么的，想到这，要是以后自己写出某个文件的IDA加载器放在github上，应该能体现我的编码能力吧。</p><h5 id="第19章-IDA处理器模块"><a href="#第19章-IDA处理器模块" class="headerlink" title="第19章 IDA处理器模块"></a>第19章 IDA处理器模块</h5><p>本章介绍IDA处理器模块的构建流程，是IDA模块化中最复杂的，我感觉比较硬核了，未来一段时间自己也不会接触吧，这也是我想买一本这个实体书的原因，万一后面有需要用到可以再来仔细看看。在本章中介绍的是针对Python的编译文件pyc的逆向处理器的构建过程，同上一章有类似之处。</p><h4 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h4><p>后面的这两部分打算略过看吧，有些技术深度确实现在看看不懂，就只细看我要去学习的相关章节吧。</p><h5 id="第20章-编译器变体"><a href="#第20章-编译器变体" class="headerlink" title="第20章 编译器变体"></a>第20章 编译器变体</h5><p>源代码相同，但是编译器不同，也就是构建选项不同所带来的二进制代码是截然不同的，这是因为编译器选择了不停的算法来实现各种高级结构。</p><p>这一章中提到了switch代码在Borland编译器和Visual C++下不同的的汇编代码结构，前者将跳转表嵌入进了函数当中，后者将跳转表放在邻近函数位置处，更好的区分了数据和代码，不会给程序的行为造成影响。</p><h5 id="第21章-模糊代码分析"><a href="#第21章-模糊代码分析" class="headerlink" title="第21章 模糊代码分析"></a>第21章 模糊代码分析</h5><p>模糊代码，反逆向分析。模糊是一种是某物变得模糊、混乱，令人困惑、迷惑，以防止他人理解被模糊的项目的行为。这一章介绍了主流的模糊代码技术，是我要阅读的重点。</p><h6 id="1-反静态分析技巧"><a href="#1-反静态分析技巧" class="headerlink" title="1.反静态分析技巧"></a>1.反静态分析技巧</h6><ul><li>call/jmp loc_XXXX + 1:形如这样的汇编代码，执行了一次调用，调用对象就在下一个指令的中间，由于IDA认为这个函数会返回，则继续反汇编接着的地址，然后真正的被调用指令却没有被反汇编。</li><li>xor eax, eax  jz loc_XXXX ：这两句汇编等于无条件跳转jmp，其与loc_XXXX之间的代码从未执行，仅起到迷惑分析人员的作用。</li></ul><p><strong>a. 动态计算目标地址</strong></p><p>这里的动态计算指的是接下来的执行地址在运行时计算得出。</p><ul><li>通过操作寄存器运算，得到真正的执行地址，然后将其赋值给栈顶处，再执行返回执行，就能跳转到执行地址，也就是（push，ret）结合的一种形式，在之前练习pwn的入门题目时遇到过。</li><li>通过FS段存放的异常函数指针链表，设置异常，调用异常处理函数，根据操作系统提供的CONTEXT结构体的参数信息恢复程序执行流程。</li><li>加壳处理，UPX，ASPack，ASProtect，tElock，Burneye，Shiva，VMProtect。</li></ul><p><strong>b. 导入的函数模糊</strong></p><p>这类技巧可以令dumpbin，ldd，objdump等工具失效，无法列出库依赖关系。</p><ul><li><p>使用Loadlibrary和GetProcAddress动态获取函数地址，使用函数。</p></li><li><p>由于每一个Windows程序都会加载kernel32.dll，而上一种方法中的两个函数都处于这个dll中，所以可以通过获取kernel32.dll的导入表，查找相关函数，对比hash值，定位具体的函数入口地址，实现函数功能。【这里参见Skape<a href="http%3A%2F%2Fwww.hick.org%2Fcode%2Fskape%2Fpapers%2Fwin32-shellcode.pdf">的论文</a>“Understanding Windows Shellcode”，这个方法也是在之前我遇到的一个样本中出现的方法，现在看起来真是醍醐灌顶啊。】</p></li></ul><h6 id="2-反动态分析技巧"><a href="#2-反动态分析技巧" class="headerlink" title="2.反动态分析技巧"></a>2.反动态分析技巧</h6><p>这部分同反调试的技术差不多，检测虚拟化、检测调试器、反调试标志的设置，此处略过。</p><h6 id="3-使用IDA对二进制文件进行“静态去模糊”"><a href="#3-使用IDA对二进制文件进行“静态去模糊”" class="headerlink" title="3. 使用IDA对二进制文件进行“静态去模糊”"></a>3. 使用IDA对二进制文件进行“静态去模糊”</h6><p><strong>面向脚本的去模糊</strong></p><p>基于脚本的去模糊方案无法构建“万能式”的解决方案，现有包装器的任何细微变化都会使得脚本失效。脚本的针对性比较强。【这也导致我突然意识到我做的毕设似乎没有那么简单】</p><p><strong>面向模拟的去模糊</strong></p><p>基于模拟执行来实现去模糊，介绍了一个ida的插件<code>x86emu</code>，作为一个IDA的嵌入式x86指令的模拟器，后续对我的帮助也该会挺大的吧。</p><p><strong>基于虚拟机的模糊</strong></p><p>这主要是说VMProtect，感觉到达自己的知识瓶颈，我已经完全无法理解了。</p><blockquote><p>当前，恶意软件大多是模糊程序。因此，如果你希望研究一个恶意软件样本的内部运行机制，几乎可以肯定，你需要完成某种类型的去模糊任务。无论你是采用调试器辅助的动态去模糊方法，还是不想运行可能恶意的代码，而选择使用脚本或模拟对二进制文件进行去模糊处理，你的最终目标都是生成一个可以被完全反汇编、正确分析的去模糊二进制文件。多数情况下，最后的分析都要由IDA 之类的工具来完成。鉴于此（即使用IDA 进行分析），尝试从头至尾使用IDA 似乎有一定的道理。</p></blockquote><hr><p>注：暂时写到这儿吧，后面的部分我感觉我看了收获也不是太多吧，以后接触到再来看吧，觉得入手一本实体书，闲来无事翻一翻！</p>]]></content>
      
      
      
        <tags>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片测试</title>
      <link href="/2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="设置-config-yml"><a href="#设置-config-yml" class="headerlink" title="设置_config.yml"></a>设置<code>_config.yml</code></h3><p>将<code>post_asset_folder</code>设置为<code>true</code>.</p><p><img src="//spwpun.github.io/2019/10/18/图片测试/config.png" alt="config"></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><code>npm install hexo-asset-image --save</code></p><a id="more"></a><p><img src="//spwpun.github.io/2019/10/18/图片测试/1571383044609.png" alt="1571383044609"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>新建文章，添加图片到对应的文件夹下，使用<code>markdown</code>格式添加图片到文章中：</p><p><img src="//spwpun.github.io/2019/10/18/图片测试/1571383180135.png" alt="1571383180135"></p><h3 id="图片URL问题"><a href="#图片URL问题" class="headerlink" title="图片URL问题"></a>图片URL问题</h3><p>在文章中的图片链接为相对路径，即<code>Title/pic.jpg</code>类似的，但是插件的脚本文件有点问题，在CSDN上找到了一位大佬修改后的脚本，贴在下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">  <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">  $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>大佬的原文链接：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用KMS激活Office</title>
      <link href="/2019/10/14/KMS%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
      <url>/2019/10/14/KMS%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>KMS技术是通过Key Manager Service服务的激活机制来激活Windows或者office的，能获取正版的产品密钥，不过密钥有有效期，不是永久的，所以等到有效期到了之后需要重新获取密钥。相比网上的一些破解软件来说要好的多。</p><a id="more"></a><h4 id="打开最新的KMS-Tools-by-Ratiborus-会出现多个应用选项。"><a href="#打开最新的KMS-Tools-by-Ratiborus-会出现多个应用选项。" class="headerlink" title="打开最新的KMS Tools by Ratiborus,会出现多个应用选项。"></a>打开最新的KMS Tools by Ratiborus,会出现多个应用选项。</h4><p><img src="https://img-blog.csdnimg.cn/20191014203629977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="KMS 界面"></p><h4 id="点击”KMSoffline”-进入KMSoffline-x64-v2-1-3界面-有Main、Tools-andSettings、About四个菜单选项。"><a href="#点击”KMSoffline”-进入KMSoffline-x64-v2-1-3界面-有Main、Tools-andSettings、About四个菜单选项。" class="headerlink" title="点击”KMSoffline”,进入KMSoffline x64 v2.1.3界面,有Main、Tools andSettings、About四个菜单选项。"></a>点击”KMSoffline”,进入KMSoffline x64 v2.1.3界面,有Main、Tools andSettings、About四个菜单选项。</h4><p><img src="https://img-blog.csdnimg.cn/20191014203712167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="KMSOffice"></p><h4 id="在下方”Product”处，可以选择激活Windows和office-当然office需要自己安装。"><a href="#在下方”Product”处，可以选择激活Windows和office-当然office需要自己安装。" class="headerlink" title="在下方”Product”处，可以选择激活Windows和office,当然office需要自己安装。"></a>在下方”Product”处，可以选择激活Windows和office,当然office需要自己安装。</h4><p><img src="https://img-blog.csdnimg.cn/20191014203751419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="选择Product"></p><h4 id="然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的："><a href="#然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的：" class="headerlink" title="然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的："></a>然后点击右下方的”Information”可以查看Windows的版本信息或者office的版本信息，查看是否激活，有效期（）等什么的：</h4><p><img src="https://img-blog.csdnimg.cn/2019101420382834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="查询信息"><br>   例如：下方是Windows的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  == Windows(R), ProfessionalWorkstation edition</span><br><span class="line">     Windows(R) Operating System, VOLUME_KMSCLIENT channel</span><br><span class="line">                          SKU ID: 82bbc092-bc50-4e16-8e18-b74fc486aec3</span><br><span class="line">    Partial Product Key: 6Q84J</span><br><span class="line">    KMS-host Machine: </span><br><span class="line">          KMS-Server PID: 03612-00206-557-633704-03-2052-17763.0000-1232019</span><br><span class="line">Expiration Date/Time: 179.20:24,  until 2020/4/11   //这里显示到2020/04/11过期。</span><br><span class="line">      Activation interval: 00.02:00</span><br><span class="line">         Renewal interval: 16.04:23</span><br><span class="line">             License Status: --- LICENSED ---</span><br><span class="line">      ---------------------------------------</span><br></pre></td></tr></table></figure><h4 id="所以”Product”选择office，查看信息，确定office版本，点击”Install-Key”-生成产品密钥，中间的白框框中就会出现提示信息，"><a href="#所以”Product”选择office，查看信息，确定office版本，点击”Install-Key”-生成产品密钥，中间的白框框中就会出现提示信息，" class="headerlink" title="所以”Product”选择office，查看信息，确定office版本，点击”Install Key”,生成产品密钥，中间的白框框中就会出现提示信息，"></a>所以”Product”选择office，查看信息，确定office版本，点击”Install Key”,生成产品密钥，中间的白框框中就会出现提示信息，</h4><p><img src="https://img-blog.csdnimg.cn/20191014203917105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="Install Key"><br>最后的是密钥，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">       ---------------------------------------</span><br><span class="line"> == Installation GVLK keys Office 19</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_KMS_Client_AE-ppd.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_KMS_Client_AE-ul-oob.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_KMS_Client_AE-ul.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-pl.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-ppd.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-ul-oob.xrm-ms</span><br><span class="line">Install License:</span><br><span class="line">ProPlus2019VL_MAK_AE-ul-phn.xrm-ms</span><br><span class="line">Uninstall key: 8MBCX</span><br><span class="line"></span><br><span class="line">Office 19, Office19ProPlus2019VL_KMS_Client_AE edition</span><br><span class="line">NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP //这个是产品密钥</span><br></pre></td></tr></table></figure><h4 id="最后将上面的产品密钥复制到左下方的”Own-Key”中，点击右下方的”Activate”（激活）就可以激活了，"><a href="#最后将上面的产品密钥复制到左下方的”Own-Key”中，点击右下方的”Activate”（激活）就可以激活了，" class="headerlink" title="最后将上面的产品密钥复制到左下方的”Own Key”中，点击右下方的”Activate”（激活）就可以激活了，"></a>最后将上面的产品密钥复制到左下方的”Own Key”中，点击右下方的”Activate”（激活）就可以激活了，</h4><p>激活成功是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       ---------------------------------------</span><br><span class="line">== Activating Office 19, Office19ProPlus2019VL_KMS_Client_AE edition</span><br><span class="line"></span><br><span class="line"> Setting KMS-Service 10.3.0.20:1688 ...</span><br><span class="line"> KMS-Service 10.3.0.20:1688 successfully installed</span><br><span class="line"></span><br><span class="line"> Install KMS-Emulator ...</span><br><span class="line">              -------=======-------</span><br><span class="line"> === Product successfully activated ===</span><br><span class="line">              -------=======-------</span><br></pre></td></tr></table></figure><hr><p>一个俄罗斯人写的，<a href="https://filecr.com/windows/ratiborus-kms-tools/" target="_blank" rel="noopener">KMS Tools by Ratiborus</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMS </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年下半年规划</title>
      <link href="/2019/08/23/2019%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%A7%84%E5%88%92/"/>
      <url>/2019/08/23/2019%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="学业"><a href="#学业" class="headerlink" title="学业"></a>学业</h3><ol><li>争取保研，现在的想法就保到本校吧，老师熟悉，环境熟悉，至于说出去闯的事，等十月份确定了之后，投投简历，找个实习，出去闯一闯。</li><li>现在大概率已经决定走逆向方向了，在实习期间一定要多学多问，下半年争取吃完《0day》和《加密与解密》这两本书。</li><li>渗透测试在我看来，还是挺有意思的，有空的话去试试关注的网站吧，毕竟现在了解的方面也算比较多了，尝试挖挖一些简单的漏洞。</li><li>和导师确定好方向之后要慢慢养成看论文的习惯。</li><li>在练习的英语口语也不要放弃，其实学习英语口语不可避免的学习英语的语法知识什么的，这次英语六级果然考砸了，下半年再去试试吧，顺便试试口试。</li></ol><a id="more"></a><h3 id="人际交往"><a href="#人际交往" class="headerlink" title="人际交往"></a>人际交往</h3><ol><li>多理解理解别人，不要把什么事都自己想当然；</li><li>对于自己喜欢的人，不强求吧，顺其自然，确实大四各自的去向也太不稳定了，当初想着趁着最后一年赶紧谈个恋爱的想法现在想来真是幼稚，要说大学三年在感情方面学到了什么，那就是认识到了很多优秀的人，不过在别人眼中我永远只是个好人！哈哈，不要悲伤，一两年之后回来再看就会觉得没什么了。</li><li>多和老师交流，要学会多问关键性的问题，少问人生规划类的问题，人生规划适合自己才行，大部分老师都是以自身经历来告诫学生。</li><li>人前要活泼、开朗，人后得学会自我提升、自我思考。</li></ol><h3 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h3><ol><li>国庆回家一趟，一个暑假没回去，我很想家，家人一定希望我回去的。</li><li>寒假回去记得和老哥说一下，一起去拍个全家福吧！</li><li>周末的时间抽空打个电话给妈妈，老爸和我从来都是只说正事，和妈妈能瞎扯很久，毕竟他们年纪大了，子女离那么远，内心肯定是孤独的。</li></ol><h3 id="金钱观"><a href="#金钱观" class="headerlink" title="金钱观"></a>金钱观</h3><ol><li>合理分配资金。</li><li>可以学一点投资的知识，把剩余的钱用来赚取其他利益。</li><li>学会投资在学习上，不管是专业学习，还是其他的生活技能的学习。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Feelings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hide&amp;Seek Algorithm</title>
      <link href="/2019/04/11/Hide&amp;Seek-Algorithm/"/>
      <url>/2019/04/11/Hide&amp;Seek-Algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="Hide-amp-Seek-Algorithm"><a href="#Hide-amp-Seek-Algorithm" class="headerlink" title="Hide&amp;Seek Algorithm"></a>Hide&amp;Seek Algorithm</h3><p>通过减少调色板矩阵的颜色数，再复制增加一倍，再通过某种方法嵌入消息，这里是实现了将读入的图片的颜色减至128色，然后复制成为256色，这样数据索引矩阵中的值可以选择两个索引，一个小索引、一个大索引，使其分别代表不同的信息即可，例如0、1。关于调色板矩阵和索引矩阵可以看我上一篇文章。</p><a id="more"></a><h3 id="Code-Design"><a href="#Code-Design" class="headerlink" title="Code Design"></a>Code Design</h3><p>matlab不是我擅长的语言，hh，想想我也没什么擅长的语言！</p><h4 id="隐藏函数"><a href="#隐藏函数" class="headerlink" title="隐藏函数"></a>隐藏函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function [ newdata, newmap ] = MyHideSeek( data, map, msg )</span><br><span class="line">%自我实现的最简单的Hide&amp;Seek算法</span><br><span class="line">%data:原始索引矩阵</span><br><span class="line">%map:原始调色板矩阵</span><br><span class="line">%msg:需要隐藏的消息</span><br><span class="line">newdata = data;</span><br><span class="line">newmap = [map;map];</span><br><span class="line">size_data = prod(size(data));</span><br><span class="line">len_msg = length(msg);%消息的长度</span><br><span class="line">lenstr = de2bi(len_msg, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">msgasc = double(msg);</span><br><span class="line">msgstr = de2bi(msgasc, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">msgstr = msgstr<span class="string">';</span></span><br><span class="line"><span class="string">len_map = length(map); %原始调色板的颜色个数</span></span><br><span class="line"><span class="string">if size_data &lt; 7*(len_msg+1)</span></span><br><span class="line"><span class="string">    error('</span>The message is too long to embed!\n<span class="string">');</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">%改变索引矩阵的值来隐藏信息</span></span><br><span class="line"><span class="string">%存入长度</span></span><br><span class="line"><span class="string">for i = 1:7</span></span><br><span class="line"><span class="string">    if lenstr(i) == 1       %规定消息为1时使用大的索引</span></span><br><span class="line"><span class="string">        newdata(i) = newdata(i) + len_map;</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">%存入msg</span></span><br><span class="line"><span class="string">for j = 8:7*(len_msg + 1)</span></span><br><span class="line"><span class="string">    if msgstr(j-7) == 1</span></span><br><span class="line"><span class="string">        newdata(j) = newdata(j) +len_map;</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><h4 id="提取函数"><a href="#提取函数" class="headerlink" title="提取函数"></a>提取函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span> = <span class="title">MyHideSeekExtract</span>(<span class="params"> newdata, newmap </span>)</span></span><br><span class="line">%MyHideSeek提取函数</span><br><span class="line">%newdata:隐含信息的数据索引矩阵</span><br><span class="line">%newmap:复制后的调色板矩阵</span><br><span class="line">len_map = length(newmap)/<span class="number">2</span>;%原始map的长度</span><br><span class="line">len = zeros(<span class="number">1</span>,<span class="number">7</span>);%用来存放提取出来的消息长度</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:<span class="number">7</span></span><br><span class="line">    <span class="keyword">if</span> newdata(i) &gt; len_map</span><br><span class="line">        len(i) = <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">len = bi2de(len);</span><br><span class="line">msg = zeros(<span class="number">7</span>,len);</span><br><span class="line">%提取消息</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">8</span>:<span class="number">7</span>*(len + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> newdata(j) &gt;len_map</span><br><span class="line">        msg(j<span class="number">-7</span>) = <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">%将消息转为字符串</span><br><span class="line">msgasc = bi2de(msg<span class="string">');</span></span><br><span class="line"><span class="string">msg = char(msgasc);</span></span><br><span class="line"><span class="string">msg = msg'</span>;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear;</span><br><span class="line">im = imread(<span class="string">'comic.png'</span>);</span><br><span class="line">[data, map] = rgb2ind(im, <span class="number">128</span>); %将图片的颜色减少至<span class="number">128</span>色，由于数据索引矩阵的数据时uint8所以这里的最大为<span class="number">128</span>色，超过就无法还原了</span><br><span class="line">msg = <span class="string">'flag&#123;This_1s_for_my_Hide_&amp;_Seek.&#125;'</span>;</span><br><span class="line">[newdata, newmap] = MyHideSeek(data, map, msg);</span><br><span class="line">imshow(data, map);title(<span class="string">'Origin'</span>);</span><br><span class="line">figure;imshow(newdata, newmap); title(<span class="string">'Steg'</span>);</span><br><span class="line">flag = MyHideSeekExtract(newdata, newmap);</span><br><span class="line">fprintf(<span class="string">'flag:%s\n'</span>, flag);</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>比较前后两张图片，肉眼分别不出差异：<br><img src="https://img-blog.csdnimg.cn/20190411153722923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xwbHA5ODIy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看输出的文本信息：<br><img src="https://img-blog.csdnimg.cn/20190411153836836.png" alt="在这里插入图片描述"></p><hr><p>注：之前一直不清楚hide&amp;seek算法是什么，虽然拍了几张上课的照片，但是不懂，同学的提示让我突然想到了我拍的照片的含义，果然上课不好好听课是不行的，在此向她致谢~<br>hide&amp;seek算法还有其他的编码方式，这只是其中一种最简单的。关键在改变调色板矩阵之后的嵌入方式的选择，这是多样的。</p><p>ex: First posted in <a href="https://blog.csdn.net/lplp9822/article/details/89212456" target="_blank" rel="noopener">CSDN blog</a></p>]]></content>
      
      
      <categories>
          
          <category> Steganography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hide&amp;Seek </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>About</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>Hello,<br>  Visitors!<br>  I’m a undergraduate from China.This is the third process of my blog building, you also could find me on the Internet by typing “spwpun”. That word was designed by the Caser Encryption with my real name.<br>  In this blog, I will write some articles about Information Security，or Cyber Security，especially Malicious Code Analysis and Reverse in CTF. Now I’m just a beginner of this period, but I’m very glad to recivive your proposals about tech-communication.<br>  In later, I would try to write posts in English more. I know my English isn’t very well, so please forgive it.<br>  Your friends!<br>  Spwpun.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
